const WebSocket = require("ws")
const http = require("http")
const fs = require("fs")
const path = require("path")

// Crea server HTTP
const server = http.createServer((req, res) => {
  if (req.url === "/" || req.url === "/index.html") {
    fs.readFile(path.join(__dirname, "index.html"), (err, data) => {
      if (err) {
        res.writeHead(404)
        res.end("File not found")
        return
      }
      res.writeHead(200, { "Content-Type": "text/html" })
      res.end(data)
    })
  } else {
    res.writeHead(404)
    res.end("Not found")
  }
})

// Crea WebSocket server
const wss = new WebSocket.Server({ server })

// Game state - SEMPLIFICATO
const rooms = new Map()
const players = new Map()

function generateRoomCode() {
  return "ROOM" + Math.random().toString(36).substr(2, 4).toUpperCase()
}

function generateSecretNumber() {
  return Math.floor(Math.random() * 100) + 1
}

function broadcastToRoom(roomCode, message) {
  const room = rooms.get(roomCode)
  if (!room) return

  console.log(`üì° Broadcasting to room ${roomCode}:`, message.type)

  room.players.forEach((player) => {
    const ws = players.get(player.id)
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify(message))
        console.log(`‚úÖ Sent to ${player.name}`)
      } catch (error) {
        console.error(`‚ùå Error sending to ${player.name}:`, error)
      }
    } else {
      console.log(`‚ö†Ô∏è Player ${player.name} not connected`)
    }
  })
}

// WebSocket connection handler
wss.on("connection", (ws) => {
  console.log("üîó New WebSocket connection")

  ws.send(
    JSON.stringify({
      type: "connected",
      message: "Connected to server!",
    }),
  )

  ws.on("message", (data) => {
    try {
      const message = JSON.parse(data)
      console.log(`üì® Received: ${message.type}`, message)

      switch (message.type) {
        case "createRoom":
          {
            console.log(`üè† Creating room for ${message.playerName}`)

            const roomCode = generateRoomCode()
            const room = {
              roomCode,
              players: [
                {
                  id: message.playerId,
                  name: message.playerName,
                  score: 0,
                  isHost: true,
                },
              ],
              gameStarted: false,
              secretNumber: null,
              chat: [
                {
                  playerName: "Sistema",
                  message: `üöÄ Stanza ${roomCode} creata!`,
                  timestamp: Date.now(),
                },
              ],
              currentRound: 0,
              currentPlayerIndex: 0,
              maxAttempts: 3,
              currentAttempts: 0,
              turnTimeLimit: 30,
            }

            rooms.set(roomCode, room)
            players.set(message.playerId, ws)

            console.log(`‚úÖ Room ${roomCode} created`)

            ws.send(
              JSON.stringify({
                type: "roomCreated",
                gameData: room,
              }),
            )
          }
          break

        case "joinRoom":
          {
            console.log(`üö™ ${message.playerName} joining ${message.roomCode}`)

            const room = rooms.get(message.roomCode)
            if (!room) {
              console.log(`‚ùå Room ${message.roomCode} not found`)
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Stanza non trovata!",
                }),
              )
              break
            }

            // Check if player already exists
            const existingPlayer = room.players.find((p) => p.id === message.playerId)
            if (!existingPlayer) {
              room.players.push({
                id: message.playerId,
                name: message.playerName,
                score: 0,
                isHost: false,
              })

              room.chat.push({
                playerName: "Sistema",
                message: `üöÄ ${message.playerName} si √® unito!`,
                timestamp: Date.now(),
              })
            }

            players.set(message.playerId, ws)

            console.log(`‚úÖ ${message.playerName} joined room ${message.roomCode}`)

            // Send to joiner
            ws.send(
              JSON.stringify({
                type: "roomJoined",
                gameData: room,
              }),
            )

            // Broadcast to all
            broadcastToRoom(message.roomCode, {
              type: "gameUpdate",
              gameData: room,
            })
          }
          break

        case "startGame":
          {
            console.log(`üéÆ Start game request for room ${message.roomCode}`)

            const room = rooms.get(message.roomCode)
            if (!room) {
              console.log(`‚ùå Room not found: ${message.roomCode}`)
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Stanza non trovata!",
                }),
              )
              break
            }

            console.log(`üìä Room state: players=${room.players.length}, started=${room.gameStarted}`)

            const player = room.players.find((p) => p.id === message.playerId)
            if (!player) {
              console.log(`‚ùå Player not found: ${message.playerId}`)
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Giocatore non trovato!",
                }),
              )
              break
            }

            if (!player.isHost) {
              console.log(`‚ùå Player ${player.name} is not host`)
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Solo l'host pu√≤ iniziare!",
                }),
              )
              break
            }

            if (room.players.length < 2) {
              console.log(`‚ùå Not enough players: ${room.players.length}`)
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Servono almeno 2 giocatori!",
                }),
              )
              break
            }

            if (room.gameStarted) {
              console.log(`‚ö†Ô∏è Game already started`)
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Gioco gi√† iniziato!",
                }),
              )
              break
            }

            // START THE GAME!
            console.log(`üöÄ Starting game for room ${message.roomCode}`)

            room.gameStarted = true
            room.secretNumber = generateSecretNumber()
            room.currentRound = 1
            room.currentPlayerIndex = 0
            room.currentAttempts = 0

            room.chat.push({
              playerName: "Sistema",
              message: `üéØ Battaglia iniziata! Indovinate il numero (1-100)`,
              timestamp: Date.now(),
            })

            room.chat.push({
              playerName: "Sistema",
              message: `üéÆ √à il turno di ${room.players[0].name}!`,
              timestamp: Date.now(),
            })

            console.log(`‚úÖ Game started! Secret number: ${room.secretNumber}`)

            // Broadcast to all players
            broadcastToRoom(message.roomCode, {
              type: "gameUpdate",
              gameData: room,
            })

            console.log(`üì° Game start broadcasted to all players`)
          }
          break

        case "guess":
          {
            console.log(`üéØ Guess from ${message.playerName}: ${message.guess}`)

            const room = rooms.get(message.roomCode)
            if (!room || !room.gameStarted) {
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Gioco non attivo!",
                }),
              )
              break
            }

            const currentPlayer = room.players[room.currentPlayerIndex]
            if (!currentPlayer || currentPlayer.id !== message.playerId) {
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: `‚ùå Non √® il tuo turno! √à il turno di ${currentPlayer?.name || "qualcuno"}`,
                }),
              )
              break
            }

            if (room.currentAttempts >= room.maxAttempts) {
              ws.send(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Hai esaurito i tentativi!",
                }),
              )
              break
            }

            room.currentAttempts++
            const guess = Number.parseInt(message.guess)
            let hint = ""
            let correct = false

            if (guess === room.secretNumber) {
              correct = true
              hint = "üéâ CORRETTO!"

              // Add points
              currentPlayer.score += 10

              room.chat.push({
                playerName: "Sistema",
                message: `üèÜ ${message.playerName} ha indovinato ${guess}! +10 punti`,
                timestamp: Date.now(),
              })

              // New round
              setTimeout(() => {
                room.secretNumber = generateSecretNumber()
                room.currentRound++
                room.currentPlayerIndex = 0
                room.currentAttempts = 0

                room.chat.push({
                  playerName: "Sistema",
                  message: `üîÑ Round ${room.currentRound}! Nuovo numero generato`,
                  timestamp: Date.now(),
                })

                broadcastToRoom(message.roomCode, {
                  type: "gameUpdate",
                  gameData: room,
                })
              }, 2000)
            } else if (guess < room.secretNumber) {
              hint = "üìà Troppo basso!"
              room.chat.push({
                playerName: "Sistema",
                message: `${message.playerName}: ${guess} - Troppo basso!`,
                timestamp: Date.now(),
              })
            } else {
              hint = "üìâ Troppo alto!"
              room.chat.push({
                playerName: "Sistema",
                message: `${message.playerName}: ${guess} - Troppo alto!`,
                timestamp: Date.now(),
              })
            }

            // Send result to guesser
            ws.send(
              JSON.stringify({
                type: "guessResult",
                result: { hint, correct, attemptsLeft: room.maxAttempts - room.currentAttempts },
              }),
            )

            // Next turn if attempts exhausted and not correct
            if (room.currentAttempts >= room.maxAttempts && !correct) {
              room.chat.push({
                playerName: "Sistema",
                message: `‚ùå ${message.playerName} ha esaurito i tentativi!`,
                timestamp: Date.now(),
              })

              setTimeout(() => {
                room.currentPlayerIndex = (room.currentPlayerIndex + 1) % room.players.length
                room.currentAttempts = 0

                room.chat.push({
                  playerName: "Sistema",
                  message: `üéØ √à il turno di ${room.players[room.currentPlayerIndex].name}!`,
                  timestamp: Date.now(),
                })

                broadcastToRoom(message.roomCode, {
                  type: "gameUpdate",
                  gameData: room,
                })
              }, 1500)
            }

            // Broadcast update
            broadcastToRoom(message.roomCode, {
              type: "gameUpdate",
              gameData: room,
            })
          }
          break

        case "chat":
          {
            const room = rooms.get(message.roomCode)
            if (room) {
              room.chat.push({
                playerName: message.playerName,
                message: message.message,
                timestamp: Date.now(),
              })

              broadcastToRoom(message.roomCode, {
                type: "gameUpdate",
                gameData: room,
              })
            }
          }
          break

        case "ping":
          ws.send(JSON.stringify({ type: "pong" }))
          break

        default:
          console.log(`‚ùì Unknown message type: ${message.type}`)
      }
    } catch (error) {
      console.error("‚ùå Error processing message:", error)
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Server error: " + error.message,
        }),
      )
    }
  })

  ws.on("close", () => {
    console.log("üîå Connection closed")

    // Cleanup
    for (const [playerId, playerWs] of players.entries()) {
      if (playerWs === ws) {
        players.delete(playerId)

        // Remove from rooms
        for (const [roomCode, room] of rooms.entries()) {
          const playerIndex = room.players.findIndex((p) => p.id === playerId)
          if (playerIndex !== -1) {
            const player = room.players[playerIndex]
            room.players.splice(playerIndex, 1)

            if (room.players.length === 0) {
              rooms.delete(roomCode)
              console.log(`üóëÔ∏è Room ${roomCode} deleted (empty)`)
            } else {
              if (player.isHost && room.players.length > 0) {
                room.players[0].isHost = true
              }

              broadcastToRoom(roomCode, {
                type: "gameUpdate",
                gameData: room,
              })
            }
            break
          }
        }
        break
      }
    }
  })

  ws.on("error", (error) => {
    console.error("‚ùå WebSocket error:", error)
  })
})

const PORT = process.env.PORT || 3000
const HOST = process.env.HOST || "0.0.0.0"

server.listen(PORT, HOST, () => {
  console.log(`üöÄ Server running on ${HOST}:${PORT}`)
  console.log(`üåê Open http://localhost:${PORT} to play`)
})
