<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>🔥 ULTIMATE BOSS RUSH - HELL'S NIGHTMARE EDITION 🔥</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(45deg, #0a0a0a, #1a0033, #330066, #660033, #0a0a0a);
            background-size: 500% 500%;
            animation: epicGradient 12s ease infinite;
            color: #ffffff;
            overflow: hidden;
            touch-action: manipulation;
        }

        @keyframes epicGradient {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 0%; }
            50% { background-position: 100% 100%; }
            75% { background-position: 0% 100%; }
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            overflow-y: auto;
        }

        .screen.active {
            display: flex;
        }

        /* Enhanced Menu Styling */
        .menu-content {
            text-align: center;
            max-width: min(1200px, 95vw);
            padding: min(3rem, 5vw);
            background: rgba(0, 0, 0, 0.95);
            border-radius: 25px;
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff0000, #ff1493, #ff4500, #ff6b6b, #dc143c) 1;
            box-shadow: 0 0 80px rgba(255, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            margin: 1rem;
        }

        .game-title {
            font-size: clamp(2rem, 8vw, 4.5rem);
            font-weight: 900;
            background: linear-gradient(45deg, #ff0000, #ff1493, #ff4500, #ff6b6b, #dc143c, #8b0000);
            background-size: 400% 400%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: hellText 3s ease infinite;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: clamp(1rem, 4vw, 1.6rem);
            color: #ff0000;
            margin-bottom: 2rem;
            text-shadow: 0 0 25px #ff0000;
            animation: hellPulse 2s ease infinite;
            font-family: 'Rajdhani', sans-serif;
        }

        @keyframes hellText {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes hellPulse {
            0%, 100% { opacity: 1; transform: scale(1); text-shadow: 0 0 25px #ff0000; }
            50% { opacity: 0.7; transform: scale(1.08); text-shadow: 0 0 40px #ff0000, 0 0 60px #ff4500; }
        }

        .menu-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(280px, 80vw), 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .menu-btn {
            padding: clamp(1rem, 3vw, 1.8rem) clamp(1.5rem, 4vw, 2.5rem);
            font-size: clamp(0.9rem, 3vw, 1.3rem);
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s ease;
            background: linear-gradient(45deg, rgba(255, 0, 0, 0.2), rgba(255, 20, 147, 0.2));
            color: white;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            touch-action: manipulation;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .menu-btn:hover::before,
        .menu-btn:active::before {
            left: 100%;
        }

        .menu-btn:hover,
        .menu-btn:active {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 25px rgba(255, 0, 0, 0.6);
            border-color: #ff0000;
        }

        .menu-btn.primary {
            background: linear-gradient(45deg, #ff0000, #ff1493, #ff4500, #dc143c);
            background-size: 300% 300%;
            animation: hellGradient 2s ease infinite;
            font-size: clamp(1rem, 3.5vw, 1.6rem);
        }

        .menu-btn.home-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: clamp(0.8rem, 2vw, 1rem) clamp(1.2rem, 3vw, 2rem);
            font-size: clamp(0.8rem, 2.5vw, 1.1rem);
            background: linear-gradient(45deg, #ff0000, #ff1493);
            border: 2px solid #ff0000;
            border-radius: 15px;
            z-index: 1000;
        }

        .menu-btn.new-feature {
            background: linear-gradient(45deg, #00ff00, #32cd32, #00ff7f, #90ee90);
            border-color: #00ff00;
            animation: newFeatureGlow 2s ease infinite alternate;
        }

        @keyframes newFeatureGlow {
            0% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.4); }
            100% { box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }
        }

        @keyframes hellGradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Mobile Controls */
        .mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 0.8));
            display: none;
            z-index: 1000;
            pointer-events: none;
        }

        .mobile-controls.active {
            display: block;
        }

        .mobile-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: all;
        }

        .mobile-joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(255, 0, 0, 0.8);
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }

        .mobile-action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: all;
        }

        .mobile-action-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 0, 0.8);
            border: 3px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }

        .mobile-action-btn:active {
            background: rgba(255, 0, 0, 1);
            transform: scale(0.95);
        }

        /* Enhanced HUD with Mobile Optimization */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px);
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.95), transparent);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 clamp(1rem, 3vw, 2rem);
            z-index: 10;
            flex-wrap: wrap;
        }

        .hud-section {
            display: flex;
            gap: clamp(0.5rem, 2vw, 1.5rem);
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.9);
            padding: clamp(0.5rem, 2vw, 1rem);
            border-radius: 15px;
            border: 3px solid;
            text-align: center;
            min-width: clamp(80px, 15vw, 120px);
            backdrop-filter: blur(5px);
        }

        .stat-box.bosses { border-color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        .stat-box.lives { border-color: #ff0000; box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); }
        .stat-box.energy { border-color: #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.4); }
        .stat-box.score { border-color: #9932cc; box-shadow: 0 0 20px rgba(153, 50, 204, 0.4); }
        .stat-box.stress { border-color: #ff4500; box-shadow: 0 0 20px rgba(255, 69, 0, 0.6); }

        .stat-label {
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            opacity: 0.9;
            margin-bottom: 0.3rem;
            font-family: 'Rajdhani', sans-serif;
        }

        .stat-value {
            font-size: clamp(1rem, 3vw, 1.4rem);
            font-weight: 900;
        }

        /* Real Leaderboard Styles */
        .leaderboard {
            max-height: 60vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            border: 3px solid #ffd700;
            padding: 1rem;
            margin: 1rem 0;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: clamp(0.8rem, 2vw, 1rem);
            margin-bottom: 0.5rem;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 10px;
            border-left: 4px solid #ff0000;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
        }

        .leaderboard-entry.top3 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(0, 0, 0, 0.8));
            border-left-color: #ffd700;
        }

        .leaderboard-entry.player {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.2), rgba(0, 0, 0, 0.8));
            border-left-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        .leaderboard-rank {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: 900;
            color: #ffd700;
            min-width: clamp(40px, 8vw, 50px);
        }

        .leaderboard-name {
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            flex-grow: 1;
            text-align: left;
            margin-left: 1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-score {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            color: #ff6b6b;
            font-weight: 700;
        }

        /* Enhanced Input Styles */
        .editor-input {
            width: 100%;
            padding: clamp(0.6rem, 2vw, 0.8rem);
            margin: 0.5rem 0;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            border-radius: 10px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
        }

        .editor-input:focus {
            outline: none;
            border-color: #ff1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.5);
        }

        /* Canvas Responsive */
        #gameCanvas {
            display: block;
            background: radial-gradient(circle at center, #1a0033, #0a0a0a);
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff0000, #ff1493, #ff4500, #dc143c) 1;
            max-width: 100%;
            max-height: 100%;
        }

        /* Stats Display Responsive */
        .stats-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(clamp(150px, 30vw, 200px), 1fr));
            gap: clamp(1rem, 3vw, 1.5rem);
            padding: clamp(1rem, 3vw, 2rem);
            background: rgba(255, 0, 0, 0.1);
            border-radius: 20px;
            border: 3px solid #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
            margin: 1rem 0;
        }

        .stat-item {
            text-align: center;
            padding: clamp(0.8rem, 2vw, 1rem);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid rgba(255, 0, 0, 0.3);
        }

        .stat-item .stat-value {
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700;
        }

        /* Level Grid Responsive */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(clamp(200px, 40vw, 240px), 1fr));
            gap: clamp(1rem, 3vw, 1.5rem);
            margin: 2rem 0;
            max-height: 60vh;
            overflow-y: auto;
            padding: 1rem;
        }

        .level-card {
            padding: clamp(1rem, 3vw, 1.5rem);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            border: 3px solid #ff0000;
            cursor: pointer;
            transition: all 0.4s ease;
            text-align: center;
            position: relative;
        }

        .level-card:hover,
        .level-card:active {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(255, 0, 0, 0.6);
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #ff0000, #ff1493);
            color: white;
            padding: clamp(0.8rem, 2vw, 1rem) clamp(1.2rem, 3vw, 2rem);
            border-radius: 15px;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
            z-index: 3000;
            animation: slideInRight 0.5s ease, fadeOut 0.5s ease 4.5s forwards;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            max-width: 80vw;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: translateX(100%); }
        }

        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .hud {
                height: 100px;
                padding: 0 0.5rem;
            }
            
            .hud-section {
                gap: 0.5rem;
            }
            
            .stat-box {
                min-width: 70px;
                padding: 0.5rem;
            }

            .menu-content {
                padding: 1.5rem;
                margin: 0.5rem;
            }

            .boss-editor {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .skill-tree {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .level-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 1rem;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 2rem;
                letter-spacing: 1px;
            }
            
            .game-subtitle {
                font-size: 1rem;
            }
            
            .menu-btn {
                padding: 1rem 1.5rem;
                font-size: 0.9rem;
            }

            .stats-display {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.8rem;
                padding: 1rem;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            .menu-btn:hover {
                transform: none;
                box-shadow: none;
                border-color: transparent;
            }
            
            .menu-btn:active {
                transform: scale(0.98);
                box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4);
            }
        }

        /* Additional mobile game elements */
        .endless-hud, .speedrun-timer, .phase-indicator {
            font-size: clamp(0.8rem, 2vw, 1rem);
            padding: clamp(0.5rem, 2vw, 1rem);
        }

        .stress-indicator {
            width: clamp(40px, 8vw, 60px);
            height: clamp(120px, 25vh, 200px);
            left: clamp(20px, 5vw, 50px);
        }

        .intensity-meter {
            width: clamp(200px, 60vw, 400px);
            height: clamp(15px, 3vh, 20px);
        }

        /* Boss Editor Mobile */
        .boss-editor {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            max-width: 100%;
            margin: 1rem auto;
        }

        .editor-section {
            background: rgba(0, 0, 0, 0.8);
            padding: clamp(1rem, 3vw, 1.5rem);
            border-radius: 15px;
            border: 3px solid #ff1493;
        }

        @media (min-width: 768px) {
            .boss-editor {
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
        }

        /* Skill Tree Mobile */
        .skill-tree {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            max-width: 100%;
            margin: 1rem auto;
        }

        @media (min-width: 768px) {
            .skill-tree {
                grid-template-columns: repeat(3, 1fr);
                gap: 1.5rem;
            }
        }

        @media (min-width: 1024px) {
            .skill-tree {
                grid-template-columns: repeat(4, 1fr);
                gap: 2rem;
            }
        }

        .skill-node {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #666;
            border-radius: 15px;
            padding: clamp(1rem, 3vw, 1.5rem);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .skill-node.available {
            border-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        .skill-node.purchased {
            border-color: #32cd32;
            background: linear-gradient(135deg, rgba(50, 205, 50, 0.2), rgba(0, 0, 0, 0.8));
            box-shadow: 0 0 20px rgba(50, 205, 50, 0.4);
        }

        .skill-node:hover,
        .skill-node:active {
            transform: translateY(-3px) scale(1.02);
        }

        .skill-icon {
            font-size: clamp(1.5rem, 4vw, 2rem);
            margin-bottom: 0.5rem;
        }

        .skill-name {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: #ff0000;
        }

        .skill-cost {
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            color: #ffd700;
        }

        /* Particles */
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff0000;
            border-radius: 50%;
            opacity: 0.8;
            animation: hellParticleFloat 3s linear infinite;
        }

        @keyframes hellParticleFloat {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.8;
            }
            90% {
                opacity: 0.8;
            }
            100% {
                transform: translateY(-10px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .tutorial-content {
            background: rgba(0, 0, 0, 0.95);
            padding: clamp(2rem, 5vw, 3rem);
            border-radius: 25px;
            border: 4px solid #00ff00;
            box-shadow: 0 0 60px rgba(0, 255, 0, 0.6);
            max-width: min(800px, 95vw);
            text-align: center;
        }

        .tutorial-step {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .tutorial-step.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Additional responsive elements */
        .difficulty-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.95);
            color: white;
            padding: clamp(1rem, 4vw, 2rem) clamp(1.5rem, 5vw, 3rem);
            border-radius: 20px;
            font-size: clamp(1.2rem, 4vw, 2rem);
            font-weight: 900;
            text-align: center;
            opacity: 0;
            animation: warningFlash 0.3s ease infinite alternate;
            z-index: 2000;
            max-width: 90vw;
        }

        @keyframes warningFlash {
            0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        .transformation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.3) 70%);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 100;
        }

        .transformation-overlay.active {
            opacity: 1;
            animation: transformationPulse 2s ease infinite;
        }

        @keyframes transformationPulse {
            0%, 100% { background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.3) 70%); }
            50% { background: radial-gradient(circle, transparent 20%, rgba(255, 0, 0, 0.6) 80%); }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    
    <!-- Notification Container -->
    <div id="notificationContainer"></div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-content">
            <div class="tutorial-step active" id="tutorialStep1">
                <h2 style="color: #00ff00; margin-bottom: 1rem;">🎯 Welcome to Hell's Nightmare Edition!</h2>
                <p style="margin-bottom: 2rem;">This is the most brutal bullet hell experience ever created. Are you ready to face the ultimate challenge?</p>
                <button class="menu-btn" onclick="nextTutorialStep()">Continue</button>
            </div>
            <div class="tutorial-step" id="tutorialStep2">
                <h2 style="color: #ff0000; margin-bottom: 1rem;">⚔️ Combat Basics</h2>
                <p style="margin-bottom: 1rem;"><strong>WASD/Virtual Joystick</strong> - Move (precision is key!)</p>
                <p style="margin-bottom: 1rem;"><strong>Mouse/Tap</strong> - Aim and Fire</p>
                <p style="margin-bottom: 1rem;"><strong>Action Buttons</strong> - Special abilities</p>
                <p style="margin-bottom: 2rem;"><strong>Mobile Optimized</strong> - Touch controls included!</p>
                <button class="menu-btn" onclick="nextTutorialStep()">Continue</button>
            </div>
            <div class="tutorial-step" id="tutorialStep3">
                <h2 style="color: #ff1493; margin-bottom: 1rem;">🔥 Advanced Techniques</h2>
                <p style="margin-bottom: 1rem;"><strong>F/🕐 Button</strong> - Bullet Time (limited energy)</p>
                <p style="margin-bottom: 1rem;"><strong>E/🛡️ Button</strong> - Emergency Barrier</p>
                <p style="margin-bottom: 1rem;"><strong>C/💥 Button</strong> - Desperation Attack</p>
                <p style="margin-bottom: 2rem;"><strong>Shift/Precision</strong> - Precision Mode</p>
                <button class="menu-btn" onclick="closeTutorial()">Start Playing!</button>
            </div>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls" id="mobileControls">
        <div class="mobile-joystick" id="mobileJoystick">
            <div class="mobile-joystick-knob" id="mobileJoystickKnob"></div>
        </div>
        <div class="mobile-action-buttons">
            <div class="mobile-action-btn" id="mobileShoot">🔫</div>
            <div class="mobile-action-btn" id="mobileBulletTime">🕐</div>
            <div class="mobile-action-btn" id="mobileBarrier">🛡️</div>
            <div class="mobile-action-btn" id="mobileDesperation">💥</div>
        </div>
    </div>
    
    <div id="gameContainer">
        <!-- Main Menu -->
        <div class="screen active" id="mainMenu">
            <div class="menu-content">
                <h1 class="game-title">ULTIMATE BOSS RUSH</h1>
                <p class="game-subtitle">HELL'S NIGHTMARE EDITION - Where Legends Die</p>
                <button onclick="location.href='cristo.html'">Torna a Cristo</button>

                <div class="menu-buttons">
                    <button class="menu-btn primary" onclick="showScreen('levelSelect')">🔥 ENTER HELL</button>
                    <button class="menu-btn new-feature" onclick="showScreen('endlessMode')">♾️ ENDLESS NIGHTMARE</button>
                    <button class="menu-btn new-feature" onclick="showScreen('speedrun')">⚡ SPEEDRUN MODE</button>
                    <button class="menu-btn" onclick="showScreen('skillTree')">⚡ SURVIVAL SKILLS</button>
                    <button class="menu-btn new-feature" onclick="showScreen('bossEditor')">🛠️ BOSS CREATOR</button>
                    <button class="menu-btn new-feature" onclick="showScreen('leaderboard')">🏆 GLOBAL LEADERBOARD</button>
                    <button class="menu-btn" onclick="showScreen('achievements')">🏆 HALL OF PAIN</button>
                    <button class="menu-btn" onclick="showScreen('stats')">📊 DEATH STATISTICS</button>
                    <button class="menu-btn" onclick="showScreen('controls')">🎯 COMBAT MANUAL</button>
                    <button class="menu-btn new-feature" onclick="startTutorial()">🎓 TUTORIAL</button>
                </div>
                
                <div class="stats-display">
                    <div class="stat-item">
                        <div class="stat-value" id="totalBossesDefeated">0</div>
                        <div>Demons Slain</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="highestLevel">1</div>
                        <div>Deepest Circle</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalScore">0</div>
                        <div>Pain Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="skillPoints">0</div>
                        <div>Soul Fragments</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="globalRank">-</div>
                        <div>Global Rank</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="endlessRecord">0</div>
                        <div>Endless Record</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Global Leaderboard -->
        <div class="screen" id="leaderboard">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">🏆 Global Leaderboard - Hall of Legends</h2>
                
                <div style="display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; justify-content: center;">
                    <button class="menu-btn" onclick="switchLeaderboard('campaign')">Campaign</button>
                    <button class="menu-btn" onclick="switchLeaderboard('endless')">Endless</button>
                    <button class="menu-btn" onclick="switchLeaderboard('speedrun')">Speedrun</button>
                </div>
                
                <div class="leaderboard" id="leaderboardList">
                    <!-- Real leaderboard entries will be generated by JavaScript -->
                </div>
                
                <div style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                    <input type="text" id="playerNameInput" placeholder="Enter your name" class="editor-input" style="max-width: 300px; flex: 1;">
                    <button class="menu-btn" onclick="submitScore()">Submit Score</button>
                </div>
            </div>
        </div>

        <!-- Endless Mode -->
        <div class="screen" id="endlessMode">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">♾️ Endless Nightmare - Survive the Infinite</h2>
                
                <div style="margin-bottom: 2rem;">
                    <p style="font-size: clamp(1rem, 3vw, 1.2rem); margin-bottom: 1rem;">Face an endless stream of increasingly powerful demons!</p>
                    <p style="color: #ff6b6b;">• Difficulty increases every wave</p>
                    <p style="color: #ff6b6b;">• Random boss mutations</p>
                    <p style="color: #ff6b6b;">• Unique power-ups</p>
                    <p style="color: #ff6b6b;">• Global leaderboard competition</p>
                </div>
                
                <div class="stats-display">
                    <div class="stat-item">
                        <div class="stat-value" id="endlessBestWave">0</div>
                        <div>Best Wave</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="endlessBestScore">0</div>
                        <div>Best Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="endlessTotalTime">0</div>
                        <div>Total Time (min)</div>
                    </div>
                </div>
                
                <div class="menu-buttons">
                    <button class="menu-btn primary" onclick="startEndlessMode()">🔥 START ENDLESS HELL</button>
                    <button class="menu-btn" onclick="showScreen('mainMenu')">🏠 BACK TO MENU</button>
                </div>
            </div>
        </div>

        <!-- Speedrun Mode -->
        <div class="screen" id="speedrun">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">⚡ Speedrun Mode - Race Against Time</h2>
                
                <div style="margin-bottom: 2rem;">
                    <p style="font-size: clamp(1rem, 3vw, 1.2rem); margin-bottom: 1rem;">Complete all 20 circles as fast as possible!</p>
                    <p style="color: #ffff00;">• Timer tracks your every second</p>
                    <p style="color: #ffff00;">• No pausing allowed</p>
                    <p style="color: #ffff00;">• Compete for world records</p>
                    <p style="color: #ffff00;">• Special speedrun achievements</p>
                </div>
                
                <div class="stats-display">
                    <div class="stat-item">
                        <div class="stat-value" id="speedrunBestTime">--:--</div>
                        <div>Personal Best</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="speedrunWorldRecord">--:--</div>
                        <div>World Record</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="speedrunAttempts">0</div>
                        <div>Attempts</div>
                    </div>
                </div>
                
                <div class="menu-buttons">
                    <button class="menu-btn primary" onclick="startSpeedrun()">⚡ START SPEEDRUN</button>
                    <button class="menu-btn" onclick="showScreen('mainMenu')">🏠 BACK TO MENU</button>
                </div>
            </div>
        </div>

        <!-- Boss Editor -->
        <div class="screen" id="bossEditor">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">🛠️ Boss Creator - Forge Your Nightmare</h2>
                
                <div class="boss-editor">
                    <div class="editor-section">
                        <h3 style="color: #ff1493; margin-bottom: 1rem;">Boss Properties</h3>
                        <input type="text" id="bossName" placeholder="Boss Name" class="editor-input">
                        <input type="number" id="bossHealth" placeholder="Health" class="editor-input" min="500" max="50000" value="2000">
                        <input type="number" id="bossSpeed" placeholder="Speed" class="editor-input" min="1" max="10" value="3" step="0.1">
                        <input type="number" id="bossPhases" placeholder="Phases" class="editor-input" min="1" max="10" value="3">
                        
                        <label style="color: #ff6b6b;">Difficulty: <span id="difficultyValue">Normal</span></label>
                        <input type="range" id="difficultySlider" class="editor-slider" min="1" max="10" value="5" style="width: 100%; margin: 1rem 0;">
                    </div>
                    
                    <div class="editor-section">
                        <h3 style="color: #ff1493; margin-bottom: 1rem;">Attack Patterns</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <label><input type="checkbox" id="patternBasic" checked> Basic Shots</label>
                            <label><input type="checkbox" id="patternSpiral"> Spiral</label>
                            <label><input type="checkbox" id="patternTracking"> Tracking</label>
                            <label><input type="checkbox" id="patternLaser"> Laser</label>
                            <label><input type="checkbox" id="patternWave"> Wave</label>
                            <label><input type="checkbox" id="patternMeteor"> Meteor</label>
                        </div>
                        
                        <h4 style="color: #ff6b6b; margin: 1rem 0;">Special Abilities</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <label><input type="checkbox" id="abilityRegeneration"> Regeneration</label>
                            <label><input type="checkbox" id="abilityShield"> Shield</label>
                            <label><input type="checkbox" id="abilityTeleport"> Teleport</label>
                            <label><input type="checkbox" id="abilityBerserker"> Berserker Mode</label>
                        </div>
                    </div>
                </div>
                
                <div class="menu-buttons" style="margin-top: 2rem;">
                    <button class="menu-btn primary" onclick="testCustomBoss()">🎮 TEST BOSS</button>
                    <button class="menu-btn" onclick="saveCustomBoss()">💾 SAVE BOSS</button>
                    <button class="menu-btn" onclick="loadCustomBoss()">📁 LOAD BOSS</button>
                    <button class="menu-btn" onclick="shareCustomBoss()">🌐 SHARE BOSS</button>
                </div>
            </div>
        </div>

        <!-- Skill Tree -->
        <div class="screen" id="skillTree">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">Survival Skills - Forge Your Soul</h2>
                <p style="margin-bottom: 2rem; color: #ff0000;">Soul Fragments Available: <span id="availableSkillPoints">0</span></p>
                
                <div class="skill-tree" id="skillTreeGrid">
                    <!-- Skills will be generated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Achievements -->
        <div class="screen" id="achievements">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">Hall of Pain</h2>
                
                <div class="stats-display" id="achievementsList">
                    <!-- Achievements will be generated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Level Selection -->
        <div class="screen" id="levelSelect">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">Choose Your Torment</h2>
                
                <div class="level-grid" id="levelGrid">
                    <!-- Levels will be generated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Statistics -->
        <div class="screen" id="stats">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">Death Statistics</h2>
                
                <div class="stats-display">
                    <div class="stat-item">
                        <div class="stat-value" id="statTotalBosses">0</div>
                        <div>Total Demons Slain</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statHighestLevel">1</div>
                        <div>Deepest Circle Reached</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statBestScore">0</div>
                        <div>Highest Pain Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statTotalDeaths">0</div>
                        <div>Total Deaths</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statSurvivalTime">0</div>
                        <div>Longest Survival (sec)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statAchievements">0</div>
                        <div>Torments Endured</div>
                    </div>
                </div>
                
                <div class="menu-buttons" style="margin-top: 2rem;">
                    <button class="menu-btn" onclick="resetStats()" style="background: linear-gradient(45deg, #ff4500, #ff0000);">
                        🗑️ PURGE SOUL
                    </button>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="screen" id="controls">
            <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
            <div class="menu-content">
                <h2 class="game-subtitle">Combat Manual</h2>
                
                <div style="text-align: left; max-width: 700px; margin: 0 auto;">
                    <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                        <h3 style="color: #ff0000; margin-bottom: 1rem;">Basic Survival</h3>
                        <p><strong>W A S D</strong> or <strong>Virtual Joystick</strong> - Move (precision required)</p>
                        <p><strong>Mouse</strong> or <strong>Tap</strong> - Aim and Fire</p>
                        <p><strong>Space</strong> or <strong>🔫 Button</strong> - Fire</p>
                        <p><strong>Right Click</strong> or <strong>Hold Fire</strong> - Charged shot</p>
                    </div>
                    
                    <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                        <h3 style="color: #ff1493; margin-bottom: 1rem;">Advanced Combat</h3>
                        <p><strong>E</strong> or <strong>🛡️ Button</strong> - Emergency barrier</p>
                        <p><strong>Q</strong> - Analyze boss pattern (limited uses)</p>
                        <p><strong>F</strong> or <strong>🕐 Button</strong> - Bullet time</p>
                        <p><strong>C</strong> or <strong>💥 Button</strong> - Desperation attack</p>
                        <p><strong>V</strong> - Phase skip (costs soul fragments)</p>
                    </div>
                    
                    <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                        <h3 style="color: #32cd32; margin-bottom: 1rem;">Mobile Controls</h3>
                        <p><strong>Virtual Joystick</strong> - Movement control</p>
                        <p><strong>Tap Screen</strong> - Aim and fire</p>
                        <p><strong>Action Buttons</strong> - Special abilities</p>
                        <p><strong>Pinch/Zoom</strong> - Precision mode</p>
                        <p><strong>Double Tap</strong> - Emergency actions</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div class="screen" id="gameScreen">
            <!-- Speedrun Timer -->
            <div class="speedrun-timer" id="speedrunTimer" style="display: none;">
                <div>TIME: <span id="speedrunTime">00:00</span></div>
            </div>
            
            <!-- Endless Mode HUD -->
            <div class="endless-hud" id="endlessHud" style="display: none;">
                <div class="wave-counter">WAVE <span id="currentWave">1</span></div>
                <div class="difficulty-multiplier">x<span id="difficultyMultiplier">1.0</span></div>
            </div>
            
            <div class="hud">
                <div class="hud-section">
                    <div class="stat-box bosses">
                        <div class="stat-label">CIRCLE</div>
                        <div class="stat-value" id="currentLevel">1</div>
                    </div>
                    <div class="stat-box lives">
                        <div class="stat-label">SOULS</div>
                        <div class="stat-value" id="playerLives">1</div>
                    </div>
                    <div class="stat-box energy">
                        <div class="stat-label">ENERGY</div>
                        <div class="stat-value" id="playerEnergy">100</div>
                    </div>
                    <div class="stat-box stress">
                        <div class="stat-label">STRESS</div>
                        <div class="stat-value" id="playerStress">0</div>
                    </div>
                </div>
                
                <div class="health-container">
                    <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; justify-content: center;">
                        <div style="text-align: center;">
                            <div style="font-size: clamp(0.7rem, 2vw, 0.9rem); margin-bottom: 0.3rem;">PLAYER</div>
                            <div style="width: clamp(150px, 30vw, 200px); height: 20px; background: #333; border-radius: 10px; border: 2px solid #ff0000; overflow: hidden;">
                                <div id="playerHealthFill" style="height: 100%; background: linear-gradient(90deg, #ff0000, #ff4500, #ffff00); width: 100%; transition: width 0.3s ease;"></div>
                            </div>
                            <div id="playerHealthText" style="font-size: clamp(0.6rem, 1.5vw, 0.8rem); margin-top: 0.3rem;">100 / 100</div>
                        </div>
                        
                        <div style="text-align: center;">
                            <div style="font-size: clamp(0.7rem, 2vw, 0.9rem); margin-bottom: 0.3rem;">DEMON</div>
                            <div style="width: clamp(200px, 40vw, 300px); height: 20px; background: #333; border-radius: 10px; border: 2px solid #ff1493; overflow: hidden;">
                                <div id="bossHealthFill" style="height: 100%; background: linear-gradient(90deg, #8b0000, #ff0000, #ff4500); width: 100%; transition: width 0.3s ease;"></div>
                            </div>
                            <div id="bossHealthText" style="font-size: clamp(0.6rem, 1.5vw, 0.8rem); margin-top: 0.3rem;">5000 / 5000</div>
                        </div>
                    </div>
                </div>
                
                <div class="hud-section">
                    <div class="stat-box score">
                        <div class="stat-label">PAIN</div>
                        <div class="stat-value" id="playerScore">0</div>
                    </div>
                    <button class="menu-btn home-btn" onclick="forfeitSoul()" style="position: relative; top: 0; left: 0; background: linear-gradient(45deg, #8b0000, #ff0000); padding: clamp(0.5rem, 2vw, 1rem);">
                        💀 FORFEIT
                    </button>
                </div>
            </div>
            
            <!-- Stress Indicator -->
            <div class="stress-indicator" id="stressIndicator">
                <div class="stress-text">STRESS</div>
                <div class="stress-fill" id="stressFill"></div>
            </div>
            
            <!-- Boss Phase Indicator -->
            <div class="phase-indicator" id="phaseIndicator" style="display: none;">
                <div class="phase-title">Demon Phases</div>
                <ul class="phase-list" id="phaseList">
                    <li class="active">Phase I: Awakening</li>
                    <li>Phase II: Rage</li>
                    <li>Phase III: Desperation</li>
                    <li>Phase IV: True Form</li>
                </ul>
            </div>
            
            <!-- Bullet Hell Intensity -->
            <div class="intensity-meter" id="intensityMeter">
                <div class="intensity-fill" id="intensityFill"></div>
            </div>
            
            <!-- Difficulty Warning -->
            <div class="difficulty-warning" id="difficultyWarning" style="display: none;">
                ⚠️ ADAPTIVE HELL PROTOCOL ACTIVATED ⚠️
            </div>
            
            <!-- Transformation Overlay -->
            <div class="transformation-overlay" id="transformationOverlay"></div>
            
            <canvas id="gameCanvas" width="1920" height="1080"></canvas>
        </div>

        <!-- Game Over Screen -->
        <div class="screen" id="gameOver">
            <div style="text-align: center; padding: clamp(2rem, 5vw, 3rem); background: rgba(0, 0, 0, 0.95); border-radius: 25px; border: 4px solid #ff0000; box-shadow: 0 0 60px rgba(255, 0, 0, 0.8); margin: 1rem; max-width: 90vw;">
                <h2 style="font-size: clamp(2rem, 8vw, 4rem); color: #ff0000; margin-bottom: 2rem; text-shadow: 0 0 30px #ff0000;">SOUL CONSUMED</h2>
                <div style="margin: 2rem 0;">
                    <div style="font-size: clamp(1.2rem, 4vw, 1.5rem); margin-bottom: 1rem;">Pain Endured: <span id="finalScore" style="color: #ffd700;">0</span></div>
                    <div style="font-size: clamp(1rem, 3vw, 1.2rem); margin-bottom: 1rem;">Circle Reached: <span id="finalLevel" style="color: #ff4500;">1</span></div>
                    <div style="font-size: clamp(1rem, 3vw, 1.2rem); margin-bottom: 1rem;">Survival Time: <span id="finalTime" style="color: #ff6b6b;">0s</span></div>
                    <div style="font-size: clamp(1rem, 3vw, 1.2rem);">Soul Fragments Earned: <span id="earnedSkillPoints" style="color: #32cd32;">0</span></div>
                </div>
                
                <div class="menu-buttons">
                    <button class="menu-btn primary" onclick="restartGame()">🔄 FACE HELL AGAIN</button>
                    <button class="menu-btn" onclick="showScreen('skillTree')">⚡ STRENGTHEN SOUL</button>
                    <button class="menu-btn" onclick="showScreen('levelSelect')">📋 CHOOSE TORMENT</button>
                    <button class="menu-btn" onclick="showScreen('mainMenu')">🏠 ESCAPE HELL</button>
                </div>
            </div>
        </div>

        <!-- Victory Screen -->
        <div class="screen" id="victory">
            <div style="text-align: center; padding: clamp(2rem, 5vw, 3rem); background: rgba(0, 0, 0, 0.95); border-radius: 25px; border: 4px solid #ffd700; box-shadow: 0 0 60px rgba(255, 215, 0, 0.8); margin: 1rem; max-width: 90vw;">
                <h2 style="font-size: clamp(2rem, 8vw, 4rem); color: #ffd700; margin-bottom: 2rem; text-shadow: 0 0 30px #ffd700;">HELL CONQUERED!</h2>
                <div style="margin: 2rem 0;">
                    <div style="font-size: clamp(1.5rem, 5vw, 2rem); margin-bottom: 1rem; color: #ffd700;">👑 DEMON SLAYER SUPREME! 👑</div>
                    <div style="font-size: clamp(1.2rem, 4vw, 1.5rem); margin-bottom: 1rem;">Final Pain Score: <span id="victoryScore" style="color: #ffd700;">0</span></div>
                    <div style="font-size: clamp(1rem, 3vw, 1.2rem); margin-bottom: 1rem;">All 20 Circles of Hell Conquered!</div>
                    <div style="font-size: clamp(1rem, 3vw, 1.2rem); margin-bottom: 1rem;">Total Survival Time: <span id="victoryTime" style="color: #ff6b6b;">0s</span></div>
                    <div style="font-size: clamp(1rem, 3vw, 1.2rem);">You have transcended mortal limits!</div>
                </div>
                
                <div class="menu-buttons">
                    <button class="menu-btn primary" onclick="showScreen('levelSelect')">🔥 CONQUER AGAIN</button>
                    <button class="menu-btn" onclick="showScreen('achievements')">🏆 VIEW TORMENTS</button>
                    <button class="menu-btn" onclick="showScreen('stats')">📊 VIEW PAIN</button>
                    <button class="menu-btn" onclick="showScreen('mainMenu')">🏠 ASCEND</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Game State with Mobile Support and Real Leaderboard
        let gameState = {
            currentScreen: 'mainMenu',
            currentLevel: 1,
            gameRunning: false,
            gamePaused: false,
            gameMode: 'campaign', // 'campaign', 'endless', 'speedrun', 'custom'
            endlessWave: 1,
            speedrunStartTime: 0,
            tutorialStep: 0,
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            touchControls: {
                joystick: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 },
                shooting: false,
                lastTouchTime: 0
            },
            player: {
                x: 0,
                y: 0,
                health: 100,
                maxHealth: 100,
                lives: 1,
                score: 0,
                energy: 100,
                maxEnergy: 100,
                stress: 0,
                maxStress: 100,
                skills: {},
                emergencyBarriers: 1,
                bulletTimeEnergy: 100,
                analysisUses: 3,
                precisionMode: false,
                invulnerabilityFrames: 0
            },
            boss: null,
            bullets: [],
            enemyBullets: [],
            particles: [],
            powerUpItems: [],
            environmentalHazards: [],
            bossPhases: [],
            currentPhase: 0,
            bulletHellIntensity: 0,
            adaptiveDifficulty: 1.0,
            keys: {},
            mouse: {x: 0, y: 0},
            levelStartTime: 0,
            totalSurvivalTime: 0,
            skillPoints: 0,
            achievements: [],
            bulletTimeActive: false,
            timeScale: 1,
            screenShake: 0,
            transformationActive: false,
            customBoss: null,
            leaderboardType: 'campaign',
            playerName: ''
        };

        // Enhanced Level Data
        const HELL_LEVEL_DATA = [
            {level: 1, boss: "Tormented Wraith", difficulty: "Painful", health: 800, phases: 2, speed: 2.0, attackPatterns: ['basic', 'spiral', 'tracking'], weaknesses: ['light'], mutations: []},
            {level: 2, boss: "Screaming Banshee", difficulty: "Agonizing", health: 1200, phases: 2, speed: 2.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave'], weaknesses: ['silence'], mutations: ['speed_boost']},
            {level: 3, boss: "Burning Demon", difficulty: "Excruciating", health: 1600, phases: 3, speed: 3.0, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor'], weaknesses: ['ice'], mutations: ['armor_plating', 'berserker_mode']},
            {level: 4, boss: "Shadow Fiend", difficulty: "Unbearable", health: 2200, phases: 3, speed: 3.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser'], weaknesses: ['light'], mutations: ['phase_shift', 'regeneration']},
            {level: 5, boss: "Hell Hound Alpha", difficulty: "Merciless", health: 2800, phases: 3, speed: 4.0, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn'], weaknesses: ['holy'], mutations: ['speed_boost', 'berserker_mode', 'pack_hunt']},
            {level: 6, boss: "Infernal Golem", difficulty: "Ruthless", health: 3500, phases: 4, speed: 2.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'earthquake'], weaknesses: ['lightning'], mutations: ['armor_plating', 'shield_generator', 'ground_slam']},
            {level: 7, boss: "Plague Bringer", difficulty: "Sadistic", health: 4200, phases: 4, speed: 3.8, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'poison'], weaknesses: ['purification'], mutations: ['regeneration', 'toxic_aura', 'disease_spread']},
            {level: 8, boss: "Void Stalker", difficulty: "Diabolical", health: 5000, phases: 4, speed: 4.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'void_rift'], weaknesses: ['reality'], mutations: ['phase_shift', 'dimensional_tear', 'void_walk']},
            {level: 9, boss: "Crimson Overlord", difficulty: "Hellish", health: 5800, phases: 5, speed: 4.8, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'blood_rain'], weaknesses: ['divine'], mutations: ['berserker_mode', 'blood_frenzy', 'crimson_shield']},
            {level: 10, boss: "Nightmare Incarnate", difficulty: "Apocalyptic", health: 6600, phases: 5, speed: 5.2, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'fear_aura'], weaknesses: ['courage'], mutations: ['fear_projection', 'nightmare_realm', 'terror_wave']},
            {level: 11, boss: "Abyssal Leviathan", difficulty: "Cataclysmic", health: 7500, phases: 5, speed: 5.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'tidal_wave'], weaknesses: ['earth'], mutations: ['water_mastery', 'tsunami_call', 'depth_pressure']},
            {level: 12, boss: "Chaos Primordial", difficulty: "World-Ending", health: 8400, phases: 6, speed: 6.0, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'chaos_storm'], weaknesses: ['order'], mutations: ['chaos_field', 'reality_warp', 'entropy_wave']},
            {level: 13, boss: "Death's Avatar", difficulty: "Soul-Crushing", health: 9300, phases: 6, speed: 6.3, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'death_ray'], weaknesses: ['life'], mutations: ['death_aura', 'soul_drain', 'reaper_scythe']},
            {level: 14, boss: "Temporal Destroyer", difficulty: "Mind-Breaking", health: 10200, phases: 6, speed: 6.8, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'time_rift'], weaknesses: ['eternity'], mutations: ['time_manipulation', 'temporal_loop', 'chronos_wrath']},
            {level: 15, boss: "Reality Shatterer", difficulty: "Sanity-Ending", health: 11200, phases: 7, speed: 7.2, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'reality_break'], weaknesses: ['truth'], mutations: ['reality_distortion', 'dimension_crack', 'existence_void']},
            {level: 16, boss: "Cosmic Horror", difficulty: "Incomprehensible", health: 12300, phases: 7, speed: 7.8, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'cosmic_storm'], weaknesses: ['understanding'], mutations: ['cosmic_terror', 'star_destroyer', 'galaxy_eater']},
            {level: 17, boss: "Omnipotent Tyrant", difficulty: "Godlike", health: 13500, phases: 8, speed: 8.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'omnislash'], weaknesses: ['humility'], mutations: ['omnipotence', 'divine_wrath', 'absolute_power']},
            {level: 18, boss: "Universal Devourer", difficulty: "Beyond Mortal", health: 14800, phases: 8, speed: 9.0, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'universe_consume'], weaknesses: ['creation'], mutations: ['universal_hunger', 'reality_consumption', 'existence_devour']},
            {level: 19, boss: "Infinity Breaker", difficulty: "Transcendent", health: 16200, phases: 9, speed: 9.8, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'infinity_shatter'], weaknesses: ['finite'], mutations: ['infinity_control', 'endless_power', 'eternal_torment']},
            {level: 20, boss: "The Final Nightmare", difficulty: "ABSOLUTE", health: 18000, phases: 10, speed: 10.5, attackPatterns: ['basic', 'spiral', 'tracking', 'wave', 'meteor', 'laser', 'spawn', 'ultimate_hell'], weaknesses: ['hope'], mutations: ['absolute_power', 'final_form', 'nightmare_incarnate', 'hell_master']}
        ];

        // Enhanced Skill Tree
        const SURVIVAL_SKILLS = {
            'pain_tolerance': {name: 'Pain Tolerance', icon: '🛡️', cost: 10, description: '+50 max health, -25% stress gain', maxLevel: 3},
            'energy_mastery': {name: 'Energy Mastery', icon: '⚡', cost: 8, description: '+25% energy regen, +20 max energy', maxLevel: 4},
            'precision_aim': {name: 'Precision Aim', icon: '🎯', cost: 12, description: '+50% damage, smaller hitbox', maxLevel: 3},
            'bullet_time': {name: 'Bullet Time Master', icon: '⏰', cost: 15, description: '50% less bullet time drain', maxLevel: 2},
            'stress_control': {name: 'Stress Control', icon: '🧘', cost: 20, description: 'Stress decreases over time', maxLevel: 1},
            'barrier_tech': {name: 'Barrier Technology', icon: '🔰', cost: 25, description: '+1 emergency barrier per phase', maxLevel: 2},
            'pattern_reader': {name: 'Pattern Reader', icon: '🔍', cost: 18, description: 'See boss attack telegraphs', maxLevel: 1},
            'soul_link': {name: 'Soul Link', icon: '👻', cost: 30, description: 'Gain energy from enemy deaths', maxLevel: 1},
            'hell_walker': {name: 'Hell Walker', icon: '🔥', cost: 35, description: 'Immune to environmental damage', maxLevel: 1},
            'demon_slayer': {name: 'Demon Slayer', icon: '⚔️', cost: 40, description: '+100% damage to final phases', maxLevel: 1},
            'time_master': {name: 'Time Master', icon: '🌀', cost: 50, description: 'Auto bullet-time when near death', maxLevel: 1},
            'nightmare_ender': {name: 'Nightmare Ender', icon: '💀', cost: 100, description: 'Instant kill bosses below 10% health', maxLevel: 1},
            'endless_warrior': {name: 'Endless Warrior', icon: '♾️', cost: 75, description: '+25% score in endless mode', maxLevel: 1},
            'speedrun_master': {name: 'Speedrun Master', icon: '⚡', cost: 60, description: '+15% movement speed in speedrun', maxLevel: 1},
            'boss_creator': {name: 'Boss Creator', icon: '🛠️', cost: 45, description: 'Unlock advanced boss editor features', maxLevel: 1},
            'mobile_master': {name: 'Mobile Master', icon: '📱', cost: 30, description: 'Enhanced touch controls and mobile UI', maxLevel: 1}
        };

        // Enhanced Achievement System
        const HELL_ACHIEVEMENTS = {
            'first_pain': {name: 'First Pain', description: 'Survive your first demon encounter', icon: '🩸', unlocked: false},
            'stress_master': {name: 'Stress Master', description: 'Reach 100% stress and survive', icon: '🤯', unlocked: false},
            'bullet_dancer': {name: 'Bullet Dancer', description: 'Survive 1000 bullets in one level', icon: '💃', unlocked: false},
            'phase_skipper': {name: 'Phase Skipper', description: 'Skip a boss phase with pure damage', icon: '⏭️', unlocked: false},
            'hell_walker': {name: 'Hell Walker', description: 'Reach Circle 10', icon: '🔥', unlocked: false},
            'demon_slayer': {name: 'Demon Slayer', description: 'Reach Circle 15', icon: '⚔️', unlocked: false},
            'nightmare_ender': {name: 'Nightmare Ender', description: 'Reach Circle 20', icon: '💀', unlocked: false},
            'perfect_hell': {name: 'Perfect Hell', description: 'Complete a level without taking damage', icon: '👑', unlocked: false},
            'speed_demon': {name: 'Speed Demon', description: 'Complete a level in under 30 seconds', icon: '⚡', unlocked: false},
            'ultimate_survivor': {name: 'Ultimate Survivor', description: 'Conquer all 20 Circles of Hell', icon: '🏆', unlocked: false},
            'endless_legend': {name: 'Endless Legend', description: 'Survive 50 waves in endless mode', icon: '♾️', unlocked: false},
            'speedrun_god': {name: 'Speedrun God', description: 'Complete campaign in under 10 minutes', icon: '⚡', unlocked: false},
            'boss_architect': {name: 'Boss Architect', description: 'Create and test 10 custom bosses', icon: '🛠️', unlocked: false},
            'global_champion': {name: 'Global Champion', description: 'Reach top 10 on global leaderboard', icon: '🌍', unlocked: false},
            'tutorial_master': {name: 'Tutorial Master', description: 'Complete the tutorial', icon: '🎓', unlocked: false},
            'mobile_warrior': {name: 'Mobile Warrior', description: 'Complete 10 levels on mobile', icon: '📱', unlocked: false}
        };

        // Real Leaderboard System with Local Storage
        let globalLeaderboard = {
            campaign: [],
            endless: [],
            speedrun: []
        };

        // Canvas and context
        let canvas, ctx;
        let animationId;

        // Initialize the game
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            loadGameData();
            loadLeaderboardData();
            updateUI();
            generateLevelGrid();
            generateSkillTree();
            generateAchievements();
            generateLeaderboard();
            createHellParticles();
            setupEventListeners();
            setupMobileControls();
            
            // Initialize boss editor
            initializeBossEditor();

            // Show mobile controls if on mobile device
            if (gameState.isMobile) {
                showNotification('Mobile controls detected! Touch to play.', 'info');
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        // Enhanced Mobile Controls Setup
        function setupMobileControls() {
            if (!gameState.isMobile) return;

            const joystick = document.getElementById('mobileJoystick');
            const joystickKnob = document.getElementById('mobileJoystickKnob');
            const shootBtn = document.getElementById('mobileShoot');
            const bulletTimeBtn = document.getElementById('mobileBulletTime');
            const barrierBtn = document.getElementById('mobileBarrier');
            const desperationBtn = document.getElementById('mobileDesperation');

            // Joystick controls
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                gameState.touchControls.joystick.active = true;
                gameState.touchControls.joystick.startX = centerX;
                gameState.touchControls.joystick.startY = centerY;
            });

            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!gameState.touchControls.joystick.active) return;

                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 20;
                
                if (distance <= maxDistance) {
                    gameState.touchControls.joystick.currentX = deltaX;
                    gameState.touchControls.joystick.currentY = deltaY;
                } else {
                    const angle = Math.atan2(deltaY, deltaX);
                    gameState.touchControls.joystick.currentX = Math.cos(angle) * maxDistance;
                    gameState.touchControls.joystick.currentY = Math.sin(angle) * maxDistance;
                }

                // Update knob position
                joystickKnob.style.transform = `translate(-50%, -50%) translate(${gameState.touchControls.joystick.currentX}px, ${gameState.touchControls.joystick.currentY}px)`;
            });

            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.touchControls.joystick.active = false;
                gameState.touchControls.joystick.currentX = 0;
                gameState.touchControls.joystick.currentY = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            });

            // Action buttons
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.keys['shoot'] = true;
            });

            shootBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.keys['shoot'] = false;
            });

            bulletTimeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                toggleBulletTime();
            });

            barrierBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                useEmergencyBarrier();
            });

            desperationBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                desperationAttack();
            });

            // Canvas touch controls for aiming and shooting
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                gameState.mouse.x = touch.clientX - rect.left;
                gameState.mouse.y = touch.clientY - rect.top;
                
                // Auto-shoot on touch
                gameState.touchControls.shooting = true;
                gameState.keys['shoot'] = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                gameState.mouse.x = touch.clientX - rect.left;
                gameState.mouse.y = touch.clientY - rect.top;
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.touchControls.shooting = false;
                gameState.keys['shoot'] = false;
            });
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key.toLowerCase()] = true;
                gameState.keys[e.code] = true;
                
                if (gameState.currentScreen === 'gameScreen' && gameState.gameRunning) {
                    switch(e.key.toLowerCase()) {
                        case 'escape':
                            forfeitSoul();
                            break;
                        case 'r':
                            restartCurrentLevel();
                            break;
                        case 'f':
                            toggleBulletTime();
                            break;
                        case 'e':
                            useEmergencyBarrier();
                            break;
                        case 'q':
                            analyzeBossPattern();
                            break;
                        case 'c':
                            desperationAttack();
                            break;
                        case 'v':
                            skipPhase();
                            break;
                        case 'tab':
                            toggleBossInfo();
                            e.preventDefault();
                            break;
                        case 'shift':
                            gameState.player.precisionMode = true;
                            break;
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key.toLowerCase()] = false;
                gameState.keys[e.code] = false;
                
                if (e.key.toLowerCase() === 'shift') {
                    gameState.player.precisionMode = false;
                }
            });
            
            if (!gameState.isMobile) {
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    gameState.mouse.x = e.clientX - rect.left;
                    gameState.mouse.y = e.clientY - rect.top;
                });
                
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        gameState.keys['shoot'] = true;
                    } else if (e.button === 2) {
                        gameState.keys['charged_shot'] = true;
                    }
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        gameState.keys['shoot'] = false;
                    } else if (e.button === 2) {
                        gameState.keys['charged_shot'] = false;
                    }
                });
                
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
        }

        // Real Leaderboard System
        function loadLeaderboardData() {
            const savedLeaderboard = localStorage.getItem('hellBossRushLeaderboard');
            if (savedLeaderboard) {
                globalLeaderboard = JSON.parse(savedLeaderboard);
            } else {
                // Initialize with some sample data
                globalLeaderboard = {
                    campaign: [
                        {rank: 1, name: "Anonymous", score: 150000, level: 8, timestamp: Date.now() - 86400000},
                        {rank: 2, name: "Player", score: 120000, level: 6, timestamp: Date.now() - 172800000},
                        {rank: 3, name: "Challenger", score: 95000, level: 5, timestamp: Date.now() - 259200000}
                    ],
                    endless: [
                        {rank: 1, name: "Survivor", score: 250000, wave: 25, timestamp: Date.now() - 86400000},
                        {rank: 2, name: "Fighter", score: 180000, wave: 18, timestamp: Date.now() - 172800000}
                    ],
                    speedrun: [
                        {rank: 1, name: "Speedster", time: "12:34", score: 500000, timestamp: Date.now() - 86400000}
                    ]
                };
                saveLeaderboardData();
            }
        }

        function saveLeaderboardData() {
            localStorage.setItem('hellBossRushLeaderboard', JSON.stringify(globalLeaderboard));
        }

        function addToLeaderboard(type, playerData) {
            if (!globalLeaderboard[type]) {
                globalLeaderboard[type] = [];
            }

            const leaderboard = globalLeaderboard[type];
            playerData.timestamp = Date.now();
            
            // Add player data
            leaderboard.push(playerData);
            
            // Sort based on type
            if (type === 'speedrun') {
                leaderboard.sort((a, b) => {
                    const timeA = parseTimeToSeconds(a.time);
                    const timeB = parseTimeToSeconds(b.time);
                    return timeA - timeB;
                });
            } else if (type === 'endless') {
                leaderboard.sort((a, b) => b.wave - a.wave || b.score - a.score);
            } else {
                leaderboard.sort((a, b) => b.score - a.score || b.level - a.level);
            }
            
            // Keep only top 50 entries
            globalLeaderboard[type] = leaderboard.slice(0, 50);
            
            // Update ranks
            globalLeaderboard[type].forEach((entry, index) => {
                entry.rank = index + 1;
            });
            
            saveLeaderboardData();
            generateLeaderboard();
        }

        function parseTimeToSeconds(timeString) {
            const parts = timeString.split(':');
            return parseInt(parts[0]) * 60 + parseInt(parts[1]);
        }

        function formatSecondsToTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function generateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            const currentBoard = globalLeaderboard[gameState.leaderboardType] || [];
            
            leaderboardList.innerHTML = '';
            
            if (currentBoard.length === 0) {
                leaderboardList.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">No scores yet. Be the first to submit!</div>';
                return;
            }
            
            currentBoard.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'leaderboard-entry';
                
                if (index < 3) {
                    entryDiv.classList.add('top3');
                }
                
                // Check if this is the current player's entry
                const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
                if (savedData.playerName && entry.name === savedData.playerName) {
                    entryDiv.classList.add('player');
                }
                
                const rankIcons = ['👑', '🥈', '🥉'];
                const rankIcon = index < 3 ? rankIcons[index] : '';
                
                let scoreText = '';
                if (gameState.leaderboardType === 'speedrun') {
                    scoreText = `${entry.time} (${entry.score.toLocaleString()})`;
                } else if (gameState.leaderboardType === 'endless') {
                    scoreText = `Wave ${entry.wave} (${entry.score.toLocaleString()})`;
                } else {
                    scoreText = `Lv.${entry.level} (${entry.score.toLocaleString()})`;
                }
                
                const timeAgo = getTimeAgo(entry.timestamp);
                
                entryDiv.innerHTML = `
                    <div class="leaderboard-rank">${rankIcon}${entry.rank}</div>
                    <div class="leaderboard-name">${entry.name}</div>
                    <div class="leaderboard-score">
                        <div>${scoreText}</div>
                        <div style="font-size: 0.8em; opacity: 0.7;">${timeAgo}</div>
                    </div>
                `;
                
                leaderboardList.appendChild(entryDiv);
            });
        }

        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return 'Just now';
        }

        function switchLeaderboard(type) {
            gameState.leaderboardType = type;
            generateLeaderboard();
        }

        function submitScore() {
            const playerName = document.getElementById('playerNameInput').value.trim();
            if (!playerName) {
                showNotification('Please enter your name!');
                return;
            }
            
            if (playerName.length > 20) {
                showNotification('Name too long! Max 20 characters.');
                return;
            }
            
            // Save player name
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            savedData.playerName = playerName;
            localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
            gameState.playerName = playerName;
            
            // Add current best score to leaderboard
            let playerData = { name: playerName };
            
            if (gameState.leaderboardType === 'campaign') {
                playerData.score = savedData.bestScore || 0;
                playerData.level = savedData.highestLevel || 1;
            } else if (gameState.leaderboardType === 'endless') {
                playerData.score = savedData.endlessBestScore || 0;
                playerData.wave = savedData.endlessBestWave || 0;
            } else if (gameState.leaderboardType === 'speedrun') {
                if (savedData.speedrunBestTime) {
                    playerData.time = formatSecondsToTime(Math.floor(savedData.speedrunBestTime));
                    playerData.score = savedData.bestScore || 0;
                } else {
                    showNotification('No speedrun time to submit!');
                    return;
                }
            }
            
            addToLeaderboard(gameState.leaderboardType, playerData);
            showNotification(`Score submitted for ${playerName}!`, 'achievement');
            
            // Check for global champion achievement
            const currentBoard = globalLeaderboard[gameState.leaderboardType];
            const playerRank = currentBoard.findIndex(entry => entry.name === playerName) + 1;
            if (playerRank <= 10 && playerRank > 0) {
                unlockAchievement('global_champion');
            }
            
            updateUI();
        }

        // Tutorial System
        function startTutorial() {
            gameState.tutorialStep = 1;
            document.getElementById('tutorialOverlay').style.display = 'flex';
            document.getElementById('tutorialStep1').classList.add('active');
        }

        function nextTutorialStep() {
            document.getElementById(`tutorialStep${gameState.tutorialStep}`).classList.remove('active');
            gameState.tutorialStep++;
            
            if (gameState.tutorialStep <= 3) {
                document.getElementById(`tutorialStep${gameState.tutorialStep}`).classList.add('active');
            }
        }

        function closeTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'none';
            unlockAchievement('tutorial_master');
            showNotification('Tutorial Complete! +15 Soul Fragments');
        }

        // Notification System
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            if (type === 'achievement') {
                notification.style.background = 'linear-gradient(45deg, #ffd700, #ffff00)';
                notification.style.color = '#000';
            }
            
            document.getElementById('notificationContainer').appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Endless Mode
        function startEndlessMode() {
            gameState.gameMode = 'endless';
            gameState.endlessWave = 1;
            gameState.adaptiveDifficulty = 1.0;
            showScreen('gameScreen');
        }

        function updateEndlessMode() {
            if (gameState.gameMode !== 'endless') return;
            
            document.getElementById('endlessHud').style.display = 'block';
            document.getElementById('currentWave').textContent = gameState.endlessWave;
            document.getElementById('difficultyMultiplier').textContent = gameState.adaptiveDifficulty.toFixed(1);
            
            if (gameState.boss && gameState.boss.health <= 0) {
                gameState.endlessWave++;
                gameState.adaptiveDifficulty += 0.2;
                
                generateEndlessBoss();
                
                if (gameState.endlessWave >= 50) {
                    unlockAchievement('endless_legend');
                }
            }
        }

        function generateEndlessBoss() {
            const randomLevel = Math.floor(Math.random() * HELL_LEVEL_DATA.length);
            const baseBoss = HELL_LEVEL_DATA[randomLevel];
            
            gameState.boss = {
                x: canvas.width / 2,
                y: 100,
                health: baseBoss.health * gameState.adaptiveDifficulty,
                maxHealth: baseBoss.health * gameState.adaptiveDifficulty,
                speed: baseBoss.speed * (1 + gameState.adaptiveDifficulty * 0.1),
                attackPatterns: [...baseBoss.attackPatterns],
                phases: Math.min(baseBoss.phases + Math.floor(gameState.endlessWave / 10), 10),
                currentPhase: 1,
                attackCooldown: 0,
                moveDirection: 1,
                specialCooldown: 0,
                phaseTransition: false,
                enraged: false,
                bulletCount: 1 + (gameState.endlessWave * 0.1),
                attackSpeed: 1 + (gameState.endlessWave * 0.05)
            };
        }

        // Speedrun Mode
        function startSpeedrun() {
            gameState.gameMode = 'speedrun';
            gameState.speedrunStartTime = Date.now();
            gameState.currentLevel = 1;
            showScreen('gameScreen');
        }

        function updateSpeedrunTimer() {
            if (gameState.gameMode !== 'speedrun') return;
            
            document.getElementById('speedrunTimer').style.display = 'block';
            const elapsed = (Date.now() - gameState.speedrunStartTime) / 1000;
            const minutes = Math.floor(elapsed / 60);
            const seconds = Math.floor(elapsed % 60);
            document.getElementById('speedrunTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            if (gameState.currentLevel >= 20 && elapsed < 600) {
                unlockAchievement('speedrun_god');
            }
        }

        // Boss Editor System
        function initializeBossEditor() {
            const difficultySlider = document.getElementById('difficultySlider');
            difficultySlider.addEventListener('input', (e) => {
                const difficulties = ['Trivial', 'Easy', 'Normal', 'Hard', 'Brutal', 'Nightmare', 'Hell', 'Impossible', 'Godlike', 'ABSOLUTE'];
                document.getElementById('difficultyValue').textContent = difficulties[e.target.value - 1];
            });
        }

        function testCustomBoss() {
            const customBoss = createCustomBossFromEditor();
            if (customBoss) {
                gameState.gameMode = 'custom';
                gameState.customBoss = customBoss;
                showScreen('gameScreen');
                showNotification('Testing custom boss!');
            }
        }

        function saveCustomBoss() {
            const customBoss = createCustomBossFromEditor();
            if (customBoss) {
                const savedBosses = JSON.parse(localStorage.getItem('customBosses') || '[]');
                savedBosses.push(customBoss);
                localStorage.setItem('customBosses', JSON.stringify(savedBosses));
                showNotification('Boss saved successfully!', 'achievement');
                
                if (savedBosses.length >= 10) {
                    unlockAchievement('boss_architect');
                }
            }
        }

        function loadCustomBoss() {
            const savedBosses = JSON.parse(localStorage.getItem('customBosses') || '[]');
            if (savedBosses.length > 0) {
                const boss = savedBosses[savedBosses.length - 1];
                loadBossIntoEditor(boss);
                showNotification('Boss loaded!');
            } else {
                showNotification('No saved bosses found!');
            }
        }

        function shareCustomBoss() {
            const customBoss = createCustomBossFromEditor();
            if (customBoss) {
                const bossCode = btoa(JSON.stringify(customBoss));
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(bossCode).then(() => {
                        showNotification('Boss code copied to clipboard!', 'achievement');
                    });
                } else {
                    showNotification('Boss created! Code: ' + bossCode.substring(0, 20) + '...');
                }
            }
        }

        function createCustomBossFromEditor() {
            const name = document.getElementById('bossName').value.trim();
            if (!name) {
                showNotification('Please enter a boss name!');
                return null;
            }
            
            const attackPatterns = [];
            if (document.getElementById('patternBasic').checked) attackPatterns.push('basic');
            if (document.getElementById('patternSpiral').checked) attackPatterns.push('spiral');
            if (document.getElementById('patternTracking').checked) attackPatterns.push('tracking');
            if (document.getElementById('patternLaser').checked) attackPatterns.push('laser');
            if (document.getElementById('patternWave').checked) attackPatterns.push('wave');
            if (document.getElementById('patternMeteor').checked) attackPatterns.push('meteor');
            
            return {
                name: name,
                health: parseInt(document.getElementById('bossHealth').value),
                speed: parseFloat(document.getElementById('bossSpeed').value),
                phases: parseInt(document.getElementById('bossPhases').value),
                difficulty: parseInt(document.getElementById('difficultySlider').value),
                attackPatterns: attackPatterns,
                abilities: {
                    regeneration: document.getElementById('abilityRegeneration').checked,
                    shield: document.getElementById('abilityShield').checked,
                    teleport: document.getElementById('abilityTeleport').checked,
                    berserker: document.getElementById('abilityBerserker').checked
                }
            };
        }

        function loadBossIntoEditor(boss) {
            document.getElementById('bossName').value = boss.name;
            document.getElementById('bossHealth').value = boss.health;
            document.getElementById('bossSpeed').value = boss.speed;
            document.getElementById('bossPhases').value = boss.phases;
            document.getElementById('difficultySlider').value = boss.difficulty;
            
            document.querySelectorAll('#bossEditor input[type="checkbox"]').forEach(cb => cb.checked = false);
            
            boss.attackPatterns.forEach(pattern => {
                const checkbox = document.getElementById(`pattern${pattern.charAt(0).toUpperCase() + pattern.slice(1)}`);
                if (checkbox) checkbox.checked = true;
            });
            
            Object.entries(boss.abilities).forEach(([ability, enabled]) => {
                const checkbox = document.getElementById(`ability${ability.charAt(0).toUpperCase() + ability.slice(1)}`);
                if (checkbox) checkbox.checked = enabled;
            });
        }

        // Screen management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;
            
            // Show/hide mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (screenId === 'gameScreen' && gameState.isMobile) {
                mobileControls.classList.add('active');
            } else {
                mobileControls.classList.remove('active');
            }
            
            if (screenId === 'gameScreen') {
                if (!gameState.gameRunning) {
                    startGame();
                } else {
                    resumeGame();
                }
            } else {
                if (gameState.gameRunning) {
                    pauseGame();
                }
            }
        }

        // Enhanced Level Management
        function generateLevelGrid() {
            const levelGrid = document.getElementById('levelGrid');
            levelGrid.innerHTML = '';
            
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            const highestLevel = savedData.highestLevel || 1;
            
            HELL_LEVEL_DATA.forEach((levelData, index) => {
                const levelCard = document.createElement('div');
                levelCard.className = 'level-card';
                
                if (levelData.level <= highestLevel) {
                    if (savedData.completedLevels && savedData.completedLevels.includes(levelData.level)) {
                        levelCard.classList.add('completed');
                    }
                    levelCard.classList.add('hell');
                    levelCard.onclick = () => startLevel(levelData.level);
                } else {
                    levelCard.classList.add('locked');
                }
                
                const phaseText = `${levelData.phases} Phases of Torment`;
                const warningText = levelData.level >= 15 ? 'REALITY BREAKING' : 
                                   levelData.level >= 10 ? 'SANITY THREATENING' : 
                                   levelData.level >= 5 ? 'SOUL CRUSHING' : 'PAINFUL';
                
                levelCard.innerHTML = `
                    <div class="level-number">${levelData.level}</div>
                    <div class="level-boss">${levelData.boss}</div>
                    <div class="level-difficulty" style="color: ${getDifficultyColor(levelData.difficulty)}">${levelData.difficulty}</div>
                    <div class="level-phases">${phaseText}</div>
                    <div class="level-warning">${warningText}</div>
                    ${levelData.level > highestLevel ? '<div style="color: #666;">🔒 SOUL REQUIRED</div>' : ''}
                `;
                
                levelGrid.appendChild(levelCard);
            });
        }

        function getDifficultyColor(difficulty) {
            const colors = {
                'Painful': '#ff4500',
                'Agonizing': '#ff1493',
                'Excruciating': '#ff0000',
                'Unbearable': '#dc143c',
                'Merciless': '#8b0000',
                'Ruthless': '#660000',
                'Sadistic': '#4b0000',
                'Diabolical': '#330000',
                'Hellish': '#220000',
                'Apocalyptic': '#110000',
                'Cataclysmic': '#ff6666',
                'World-Ending': '#ff3333',
                'Soul-Crushing': '#ff0033',
                'Mind-Breaking': '#cc0033',
                'Sanity-Ending': '#990033',
                'Incomprehensible': '#660033',
                'Godlike': '#330033',
                'Beyond Mortal': '#ffffff',
                'Transcendent': '#ffd700',
                'ABSOLUTE': '#ff00ff'
            };
            return colors[difficulty] || '#ff0000';
        }

        // Enhanced Skill Tree System
        function generateSkillTree() {
            const skillTreeGrid = document.getElementById('skillTreeGrid');
            skillTreeGrid.innerHTML = '';
            
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            const purchasedSkills = savedData.skills || {};
            
            Object.entries(SURVIVAL_SKILLS).forEach(([skillId, skillData]) => {
                const skillNode = document.createElement('div');
                skillNode.className = 'skill-node';
                
                const currentLevel = purchasedSkills[skillId] || 0;
                const canPurchase = gameState.skillPoints >= skillData.cost && currentLevel < skillData.maxLevel;
                
                if (canPurchase) {
                    skillNode.classList.add('available');
                    skillNode.onclick = () => purchaseSkill(skillId);
                }
                
                if (currentLevel > 0) {
                    skillNode.classList.add('purchased');
                }
                
                skillNode.innerHTML = `
                    <div class="skill-icon">${skillData.icon}</div>
                    <div class="skill-name">${skillData.name}</div>
                    <div style="font-size: clamp(0.7rem, 2vw, 0.8rem); margin-bottom: 0.5rem;">${skillData.description}</div>
                    <div style="font-size: clamp(0.7rem, 1.8vw, 0.8rem); color: #888;">Level: ${currentLevel}/${skillData.maxLevel}</div>
                    <div class="skill-cost">Cost: ${skillData.cost} SF</div>
                `;
                
                skillTreeGrid.appendChild(skillNode);
            });
        }

        function purchaseSkill(skillId) {
            const skillData = SURVIVAL_SKILLS[skillId];
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            
            if (!savedData.skills) savedData.skills = {};
            if (!savedData.skillPoints) savedData.skillPoints = 0;
            
            const currentLevel = savedData.skills[skillId] || 0;
            
            if (savedData.skillPoints >= skillData.cost && currentLevel < skillData.maxLevel) {
                savedData.skillPoints -= skillData.cost;
                savedData.skills[skillId] = currentLevel + 1;
                
                localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
                
                gameState.skillPoints = savedData.skillPoints;
                gameState.player.skills = savedData.skills;
                
                updateUI();
                generateSkillTree();
                applySkillEffects();
                
                showNotification(`${skillData.name} upgraded!`, 'achievement');
            }
        }

        function applySkillEffects() {
            const skills = gameState.player.skills;
            
            if (skills.pain_tolerance) {
                gameState.player.maxHealth = 100 + (skills.pain_tolerance * 50);
                if (gameState.player.health > gameState.player.maxHealth) {
                    gameState.player.health = gameState.player.maxHealth;
                }
            }
            
            if (skills.energy_mastery) {
                gameState.player.maxEnergy = 100 + (skills.energy_mastery * 20);
            }
        }

        // Achievement System
        function generateAchievements() {
            const achievementsList = document.getElementById('achievementsList');
            achievementsList.innerHTML = '';
            
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            const unlockedAchievements = savedData.achievements || [];
            
            Object.entries(HELL_ACHIEVEMENTS).forEach(([achievementId, achievementData]) => {
                const achievementItem = document.createElement('div');
                achievementItem.className = 'stat-item';
                
                const isUnlocked = unlockedAchievements.includes(achievementId);
                
                if (isUnlocked) {
                    achievementItem.style.borderColor = '#32cd32';
                    achievementItem.style.background = 'linear-gradient(135deg, rgba(50, 205, 50, 0.2), rgba(0, 0, 0, 0.8))';
                } else {
                    achievementItem.style.borderColor = '#666';
                    achievementItem.style.opacity = '0.6';
                }
                
                achievementItem.innerHTML = `
                    <div style="font-size: clamp(1.5rem, 4vw, 2rem); margin-bottom: 0.5rem;">${achievementData.icon}</div>
                    <div style="font-size: clamp(0.9rem, 2.5vw, 1.1rem); font-weight: 700; color: ${isUnlocked ? '#32cd32' : '#666'};">${achievementData.name}</div>
                    <div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: ${isUnlocked ? '#ffffff' : '#888'};">${achievementData.description}</div>
                    ${isUnlocked ? '<div style="font-size: clamp(0.7rem, 1.8vw, 0.8rem); color: #ffd700; margin-top: 0.5rem;">✓ ENDURED</div>' : '<div style="font-size: clamp(0.7rem, 1.8vw, 0.8rem); color: #666; margin-top: 0.5rem;">🔒 LOCKED</div>'}
                `;
                
                achievementsList.appendChild(achievementItem);
            });
        }

        function unlockAchievement(achievementId) {
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            if (!savedData.achievements) savedData.achievements = [];
            
            if (!savedData.achievements.includes(achievementId)) {
                savedData.achievements.push(achievementId);
                localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
                
                gameState.skillPoints += 15;
                savedData.skillPoints = (savedData.skillPoints || 0) + 15;
                localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
                
                updateUI();
                generateAchievements();
                
                const achievement = HELL_ACHIEVEMENTS[achievementId];
                showNotification(`🏆 ${achievement.name} Unlocked! +15 Soul Fragments`, 'achievement');
            }
        }

        // Enhanced Game Logic
        function startLevel(level) {
            gameState.gameMode = 'campaign';
            gameState.currentLevel = level;
            showScreen('gameScreen');
        }

        function startGame() {
            gameState.gameRunning = true;
            gameState.gamePaused = false;
            gameState.levelStartTime = Date.now();
            gameState.bulletTimeActive = false;
            gameState.timeScale = 1;
            gameState.currentPhase = 0;
            gameState.bulletHellIntensity = 0;
            gameState.adaptiveDifficulty = 1.0;
            gameState.screenShake = 0;
            gameState.transformationActive = false;
            
            // Initialize player with skills
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            const skills = savedData.skills || {};
            
            gameState.player.x = canvas.width / 2;
            gameState.player.y = canvas.height - 100;
            gameState.player.health = 100 + (skills.pain_tolerance || 0) * 50;
            gameState.player.maxHealth = 100 + (skills.pain_tolerance || 0) * 50;
            gameState.player.energy = 100 + (skills.energy_mastery || 0) * 20;
            gameState.player.maxEnergy = 100 + (skills.energy_mastery || 0) * 20;
            gameState.player.stress = 0;
            gameState.player.emergencyBarriers = 1 + (skills.barrier_tech || 0);
            gameState.player.bulletTimeEnergy = 100;
            gameState.player.analysisUses = 3;
            gameState.player.skills = skills;
            gameState.player.invulnerabilityFrames = 0;
            
            // Initialize boss based on game mode
            if (gameState.gameMode === 'endless') {
                generateEndlessBoss();
            } else if (gameState.gameMode === 'custom' && gameState.customBoss) {
                initializeCustomBoss();
            } else {
                initializeCampaignBoss();
            }
            
            // Clear arrays
            gameState.bullets = [];
            gameState.enemyBullets = [];
            gameState.particles = [];
            gameState.powerUpItems = [];
            gameState.environmentalHazards = [];
            
            updateUI();
            gameLoop();
        }

        function initializeCampaignBoss() {
            const levelData = HELL_LEVEL_DATA[gameState.currentLevel - 1];
            
            gameState.boss = {
                x: canvas.width / 2,
                y: 100,
                health: levelData.health * gameState.adaptiveDifficulty,
                maxHealth: levelData.health * gameState.adaptiveDifficulty,
                speed: levelData.speed,
                attackPatterns: levelData.attackPatterns,
                weaknesses: [...levelData.weaknesses],
                phases: levelData.phases,
                currentPhase: 1,
                attackCooldown: 0,
                moveDirection: 1,
                specialCooldown: 0,
                phaseTransition: false,
                enraged: false,
                bulletCount: 1,
                attackSpeed: 1
            };
            
            initializeBossPhases();
        }

        function initializeCustomBoss() {
            const customBoss = gameState.customBoss;
            
            gameState.boss = {
                x: canvas.width / 2,
                y: 100,
                health: customBoss.health,
                maxHealth: customBoss.health,
                speed: customBoss.speed,
                attackPatterns: customBoss.attackPatterns,
                phases: customBoss.phases,
                currentPhase: 1,
                attackCooldown: 0,
                moveDirection: 1,
                specialCooldown: 0,
                phaseTransition: false,
                enraged: false,
                bulletCount: 1,
                attackSpeed: 1,
                abilities: customBoss.abilities
            };
            
            initializeBossPhases();
        }

        function initializeBossPhases() {
            const phases = gameState.boss.phases;
            gameState.bossPhases = [];
            
            for (let i = 1; i <= phases; i++) {
                gameState.bossPhases.push({
                    phase: i,
                    name: getPhaseNameForLevel(gameState.currentLevel, i),
                    healthThreshold: (phases - i + 1) / phases,
                    completed: false,
                    active: i === 1
                });
            }
            
            updatePhaseDisplay();
        }

        function getPhaseNameForLevel(level, phase) {
            const phaseNames = [
                ['Awakening', 'Fury'],
                ['Stirring', 'Rage', 'Desperation'],
                ['Awakening', 'Anger', 'Fury', 'True Form'],
                ['Dormant', 'Stirring', 'Rage', 'Fury', 'Final Form'],
                ['Slumber', 'Awakening', 'Anger', 'Rage', 'Fury', 'Desperation'],
                ['Rest', 'Stirring', 'Awakening', 'Anger', 'Rage', 'Fury', 'True Power'],
                ['Dormant', 'Stirring', 'Awakening', 'Anger', 'Rage', 'Fury', 'Desperation', 'Final Form'],
                ['Slumber', 'Rest', 'Stirring', 'Awakening', 'Anger', 'Rage', 'Fury', 'Desperation', 'True Form'],
                ['Deep Sleep', 'Slumber', 'Rest', 'Stirring', 'Awakening', 'Anger', 'Rage', 'Fury', 'Desperation', 'ABSOLUTE NIGHTMARE']
            ];
            
            const phaseIndex = Math.min(level - 1, phaseNames.length - 1);
            return phaseNames[phaseIndex][phase - 1] || `Phase ${phase}`;
        }

        function gameLoop() {
            if (!gameState.gameRunning || gameState.gamePaused) return;
            
            update();
            render();
            
            animationId = requestAnimationFrame(gameLoop);
        }

        function update() {
            const deltaTime = gameState.timeScale;
            
            updatePlayer(deltaTime);
            updateBoss(deltaTime);
            updateBullets(deltaTime);
            updateEnemyBullets(deltaTime);
            updateParticles(deltaTime);
            updateEnvironmentalHazards(deltaTime);
            updateStressSystem();
            updateBulletTime();
            updateAdaptiveDifficulty();
            updateScreenShake();
            checkCollisions();
            
            // Mode-specific updates
            if (gameState.gameMode === 'endless') {
                updateEndlessMode();
            } else if (gameState.gameMode === 'speedrun') {
                updateSpeedrunTimer();
            }
            
            checkBossPhaseTransition();
            
            if (gameState.boss.health <= 0) {
                levelComplete();
            } else if (gameState.player.health <= 0 && gameState.player.invulnerabilityFrames <= 0) {
                gameOver();
            }
        }

        function updatePlayer(deltaTime) {
            const player = gameState.player;
            const skills = gameState.player.skills;
            let speed = player.precisionMode ? 2 : 6;
            
            // Apply speedrun skill
            if (gameState.gameMode === 'speedrun' && skills.speedrun_master) {
                speed *= 1.15;
            }
            
            if (skills.precision_aim && player.precisionMode) {
                speed *= 0.5;
            }
            
            speed *= deltaTime;
            
            // Mobile joystick movement
            if (gameState.isMobile && gameState.touchControls.joystick.active) {
                const joystickStrength = 0.1;
                player.x += gameState.touchControls.joystick.currentX * joystickStrength;
                player.y += gameState.touchControls.joystick.currentY * joystickStrength;
            }
            
            // Keyboard movement
            if ((gameState.keys['w'] || gameState.keys['ArrowUp']) && player.y > 50) {
                player.y -= speed;
            }
            if ((gameState.keys['s'] || gameState.keys['ArrowDown']) && player.y < canvas.height - 50) {
                player.y += speed;
            }
            if ((gameState.keys['a'] || gameState.keys['ArrowLeft']) && player.x > 50) {
                player.x -= speed;
            }
            if ((gameState.keys['d'] || gameState.keys['ArrowRight']) && player.x < canvas.width - 50) {
                player.x += speed;
            }
            
            // Keep player in bounds
            player.x = Math.max(50, Math.min(canvas.width - 50, player.x));
            player.y = Math.max(50, Math.min(canvas.height - 50, player.y));
            
            // Shooting
            if ((gameState.keys['shoot'] || gameState.keys[' '] || gameState.keys['Space'] || gameState.touchControls.shooting) && player.energy > 0) {
                if (Math.random() < 0.1) {
                    shoot();
                    player.energy = Math.max(0, player.energy - 2);
                }
            }
            
            if (gameState.keys['charged_shot'] && player.energy >= 10) {
                chargedShot();
                player.energy -= 10;
                gameState.keys['charged_shot'] = false;
            }
            
            // Energy regeneration
            if (player.energy < player.maxEnergy) {
                const regenRate = skills.energy_mastery ? 0.8 : 0.5;
                player.energy = Math.min(player.maxEnergy, player.energy + regenRate);
            }
            
            if (player.invulnerabilityFrames > 0) {
                player.invulnerabilityFrames--;
            }
            
            updateUI();
        }

        function updateBoss(deltaTime) {
            const boss = gameState.boss;
            
            // Enhanced movement patterns
            if (boss.currentPhase >= 3) {
                boss.x += boss.moveDirection * boss.speed * deltaTime * (1 + Math.sin(Date.now() * 0.01) * 0.5);
                if (Math.random() < 0.02) {
                    boss.moveDirection *= -1;
                }
            } else {
                boss.x += boss.moveDirection * boss.speed * deltaTime;
            }
            
            if (boss.x <= 100 || boss.x >= canvas.width - 100) {
                boss.moveDirection *= -1;
            }
            
            // Custom boss abilities
            if (boss.abilities) {
                if (boss.abilities.teleport && Math.random() < 0.001) {
                    boss.x = Math.random() * (canvas.width - 200) + 100;
                }
                
                if (boss.abilities.regeneration && boss.health < boss.maxHealth * 0.5) {
                    boss.health = Math.min(boss.maxHealth, boss.health + 2);
                }
            }
            
            // Attack patterns
            if (boss.attackCooldown <= 0) {
                const pattern = boss.attackPatterns[Math.floor(Math.random() * boss.attackPatterns.length)];
                executeBrutalAttackPattern(pattern);
                
                const baseSpeed = Math.max(15, 45 - (boss.currentPhase * 5) - (gameState.currentLevel * 2));
                boss.attackCooldown = baseSpeed / gameState.adaptiveDifficulty;
            } else {
                boss.attackCooldown -= deltaTime;
            }
            
            if (gameState.currentLevel >= 5 && Math.random() < 0.002 * gameState.adaptiveDifficulty) {
                createBrutalHazard();
            }
        }

        function executeBrutalAttackPattern(pattern) {
            const boss = gameState.boss;
            const bulletSpeed = 4 + boss.currentPhase + (gameState.currentLevel * 0.5);
            const bulletCount = boss.bulletCount * gameState.adaptiveDifficulty;
            
            switch (pattern) {
                case 'basic':
                    for (let i = 0; i < Math.floor(5 * bulletCount); i++) {
                        gameState.enemyBullets.push({
                            x: boss.x + (i - 2) * 25,
                            y: boss.y + 50,
                            vx: (i - 2) * 0.8,
                            vy: bulletSpeed,
                            color: '#ff0000',
                            size: 10,
                            damage: 25
                        });
                    }
                    break;
                    
                case 'spiral':
                    const spiralCount = Math.floor(12 * bulletCount);
                    for (let i = 0; i < spiralCount; i++) {
                        const angle = (i / spiralCount) * Math.PI * 2 + (Date.now() * 0.01);
                        gameState.enemyBullets.push({
                            x: boss.x,
                            y: boss.y + 50,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4 + bulletSpeed,
                            color: '#ff1493',
                            size: 8,
                            damage: 20
                        });
                    }
                    break;
                    
                case 'tracking':
                    const dx = gameState.player.x - boss.x;
                    const dy = gameState.player.y - boss.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    for (let i = 0; i < Math.floor(3 * bulletCount); i++) {
                        gameState.enemyBullets.push({
                            x: boss.x,
                            y: boss.y + 50,
                            vx: (dx / dist) * bulletSpeed + (Math.random() - 0.5) * 2,
                            vy: (dy / dist) * bulletSpeed + (Math.random() - 0.5) * 2,
                            color: '#ff4500',
                            size: 12,
                            damage: 30,
                            tracking: true,
                            trackingStrength: 0.1
                        });
                    }
                    break;
                    
                case 'laser':
                    for (let i = 0; i < 30; i++) {
                        gameState.enemyBullets.push({
                            x: boss.x,
                            y: boss.y + 50 + i * 12,
                            vx: 0,
                            vy: bulletSpeed * 2,
                            color: '#ffff00',
                            size: 18,
                            damage: 35
                        });
                    }
                    break;
                    
                case 'wave':
                    for (let i = 0; i < Math.floor(15 * bulletCount); i++) {
                        const angle = (i / 15) * Math.PI * 2;
                        gameState.enemyBullets.push({
                            x: boss.x,
                            y: boss.y + 50,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3 + bulletSpeed,
                            color: '#9932cc',
                            size: 10,
                            damage: 25,
                            wave: true,
                            waveOffset: i * 0.5
                        });
                    }
                    break;
                    
                case 'meteor':
                    for (let i = 0; i < Math.floor(8 * bulletCount); i++) {
                        gameState.enemyBullets.push({
                            x: Math.random() * canvas.width,
                            y: -50,
                            vx: (Math.random() - 0.5) * 4,
                            vy: bulletSpeed * 1.5,
                            color: '#ff6600',
                            size: 20,
                            damage: 40,
                            meteor: true
                        });
                    }
                    break;
                    
                case 'ultimate_hell':
                    for (let i = 0; i < Math.floor(50 * bulletCount); i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 8 + 4;
                        gameState.enemyBullets.push({
                            x: boss.x,
                            y: boss.y + 50,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            color: '#ff00ff',
                            size: 25,
                            damage: 50,
                            ultimate: true
                        });
                    }
                    break;
            }
            
            gameState.bulletHellIntensity = Math.min(100, gameState.bulletHellIntensity + 5);
        }

        function shoot() {
            const player = gameState.player;
            const skills = gameState.player.skills;
            let damage = 15;
            
            if (skills.precision_aim && player.precisionMode) {
                damage *= 1.5;
            }
            
            // Calculate aim direction
            let targetX = gameState.mouse.x;
            let targetY = gameState.mouse.y;
            
            // For mobile, aim towards boss if no specific target
            if (gameState.isMobile && gameState.boss) {
                targetX = gameState.boss.x;
                targetY = gameState.boss.y;
            }
            
            const dx = targetX - player.x;
            const dy = targetY - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const speed = 10;
            const vx = dist > 0 ? (dx / dist) * speed : 0;
            const vy = dist > 0 ? (dy / dist) * speed : -speed;
            
            gameState.bullets.push({
                x: player.x,
                y: player.y - 20,
                vx: vx,
                vy: vy,
                color: '#00ffff',
                size: 8,
                damage: damage
            });
        }

        function chargedShot() {
            const player = gameState.player;
            const skills = gameState.player.skills;
            let damage = 50;
            
            if (skills.precision_aim) {
                damage *= 2;
            }
            
            gameState.bullets.push({
                x: player.x,
                y: player.y - 20,
                vx: 0,
                vy: -15,
                color: '#ffff00',
                size: 15,
                damage: damage,
                charged: true
            });
        }

        function toggleBulletTime() {
            const player = gameState.player;
            
            if (player.bulletTimeEnergy > 20) {
                gameState.bulletTimeActive = !gameState.bulletTimeActive;
                
                if (gameState.bulletTimeActive) {
                    gameState.timeScale = 0.2;
                } else {
                    gameState.timeScale = 1;
                }
            }
        }

        function updateBulletTime() {
            const player = gameState.player;
            const skills = gameState.player.skills;
            
            if (gameState.bulletTimeActive) {
                const drainRate = skills.bullet_time ? 1 : 2;
                player.bulletTimeEnergy -= drainRate;
                
                if (player.bulletTimeEnergy <= 0) {
                    gameState.bulletTimeActive = false;
                    gameState.timeScale = 1;
                    player.bulletTimeEnergy = 0;
                }
            } else if (player.bulletTimeEnergy < 100) {
                player.bulletTimeEnergy += 0.3;
            }
            
            if (skills.time_master && player.health < player.maxHealth * 0.15 && !gameState.bulletTimeActive) {
                gameState.timeScale = 0.3;
            } else if (!gameState.bulletTimeActive) {
                gameState.timeScale = 1;
            }
        }

        function updateStressSystem() {
            const player = gameState.player;
            const skills = gameState.player.skills;
            
            let stressIncrease = 0;
            
            gameState.enemyBullets.forEach(bullet => {
                const dist = Math.sqrt(
                    Math.pow(bullet.x - player.x, 2) + 
                    Math.pow(bullet.y - player.y, 2)
                );
                
                if (dist < 100) {
                    stressIncrease += (100 - dist) * 0.01;
                }
            });
            
            stressIncrease += gameState.boss.currentPhase * 0.1;
            
            if (skills.pain_tolerance) {
                stressIncrease *= (1 - skills.pain_tolerance * 0.25);
            }
            
            player.stress = Math.min(player.maxStress, player.stress + stressIncrease);
            
            if (skills.stress_control && player.stress > 0) {
                player.stress = Math.max(0, player.stress - 0.2);
            }
            
            if (player.stress >= 80) {
                gameState.screenShake = Math.max(gameState.screenShake, 5);
            }
            
            if (player.stress >= 100) {
                unlockAchievement('stress_master');
            }
        }

        function updateAdaptiveDifficulty() {
            const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
            
            if (survivalTime > 60) {
                gameState.adaptiveDifficulty = Math.min(3.0, gameState.adaptiveDifficulty + 0.01);
                
                if (gameState.adaptiveDifficulty > 2.0) {
                    showDifficultyWarning();
                }
            }
            
            gameState.boss.bulletCount = 1 + (gameState.adaptiveDifficulty - 1) * 0.5;
            gameState.boss.attackSpeed = gameState.adaptiveDifficulty;
        }

        function showDifficultyWarning() {
            const warning = document.getElementById('difficultyWarning');
            warning.style.display = 'block';
            
            setTimeout(() => {
                warning.style.display = 'none';
            }, 2000);
        }

        function updateScreenShake() {
            if (gameState.screenShake > 0) {
                gameState.screenShake *= 0.9;
                if (gameState.screenShake < 0.1) {
                    gameState.screenShake = 0;
                }
            }
        }

        function checkBossPhaseTransition() {
            const boss = gameState.boss;
            const healthPercent = boss.health / boss.maxHealth;
            
            gameState.bossPhases.forEach((phase, index) => {
                if (!phase.completed && healthPercent <= phase.healthThreshold) {
                    if (boss.currentPhase < phase.phase) {
                        triggerPhaseTransition(phase.phase);
                    }
                }
            });
        }

        function triggerPhaseTransition(newPhase) {
            gameState.boss.currentPhase = newPhase;
            gameState.boss.phaseTransition = true;
            gameState.transformationActive = true;
            
            document.getElementById('transformationOverlay').classList.add('active');
            gameState.screenShake = 15;
            
            gameState.boss.speed *= 1.2;
            gameState.boss.bulletCount *= 1.3;
            
            createTransformationEffect();
            
            setTimeout(() => {
                gameState.boss.phaseTransition = false;
                gameState.transformationActive = false;
                document.getElementById('transformationOverlay').classList.remove('active');
            }, 3000);
            
            updatePhaseDisplay();
        }

        function createTransformationEffect() {
            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 15 + 5;
                gameState.particles.push({
                    x: gameState.boss.x,
                    y: gameState.boss.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: '#ff0000',
                    size: Math.random() * 12 + 8,
                    life: 120,
                    maxLife: 120,
                    alpha: 1
                });
            }
        }

        function updatePhaseDisplay() {
            const phaseList = document.getElementById('phaseList');
            phaseList.innerHTML = '';
            
            gameState.bossPhases.forEach((phase, index) => {
                const li = document.createElement('li');
                li.textContent = `Phase ${phase.phase}: ${phase.name}`;
                
                if (phase.phase < gameState.boss.currentPhase) {
                    li.classList.add('completed');
                } else if (phase.phase === gameState.boss.currentPhase) {
                    li.classList.add('active');
                }
                
                phaseList.appendChild(li);
            });
        }

        function useEmergencyBarrier() {
            if (gameState.player.emergencyBarriers > 0) {
                gameState.player.emergencyBarriers--;
                gameState.player.invulnerabilityFrames = 180;
                
                gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                    const dist = Math.sqrt(
                        Math.pow(bullet.x - gameState.player.x, 2) + 
                        Math.pow(bullet.y - gameState.player.y, 2)
                    );
                    return dist > 150;
                });
                
                createBarrierEffect();
                updateUI();
            }
        }

        function createBarrierEffect() {
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                gameState.particles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(angle) * 12,
                    vy: Math.sin(angle) * 12,
                    color: '#00ffff',
                    size: 10,
                    life: 90,
                    maxLife: 90,
                    alpha: 1
                });
            }
        }

        function analyzeBossPattern() {
            if (gameState.player.analysisUses > 0) {
                gameState.player.analysisUses--;
                
                document.getElementById('phaseIndicator').style.display = 'block';
                
                setTimeout(() => {
                    document.getElementById('phaseIndicator').style.display = 'none';
                }, 10000);
                
                updateUI();
            }
        }

        function desperationAttack() {
            if (gameState.player.health < gameState.player.maxHealth * 0.25) {
                const damage = 200;
                
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    gameState.bullets.push({
                        x: gameState.player.x,
                        y: gameState.player.y - 20,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8 - 5,
                        color: '#ff0000',
                        size: 12,
                        damage: damage,
                        desperation: true
                    });
                }
                
                gameState.player.health = Math.max(1, gameState.player.health - 30);
                updateUI();
            }
        }

        function skipPhase() {
            if (gameState.skillPoints >= 50) {
                gameState.skillPoints -= 50;
                
                gameState.boss.health -= gameState.boss.maxHealth * 0.25;
                
                unlockAchievement('phase_skipper');
                updateUI();
            }
        }

        function createBrutalHazard() {
            const hazardTypes = ['hell_meteor', 'lava_geyser', 'soul_vortex', 'reality_tear'];
            const hazardType = hazardTypes[Math.floor(Math.random() * hazardTypes.length)];
            
            const hazard = {
                type: hazardType,
                x: Math.random() * canvas.width,
                y: -50,
                size: 60,
                damage: 50,
                warningTime: 90,
                active: false
            };
            
            gameState.environmentalHazards.push(hazard);
        }

        function updateEnvironmentalHazards(deltaTime) {
            gameState.environmentalHazards = gameState.environmentalHazards.filter(hazard => {
                if (hazard.warningTime > 0) {
                    hazard.warningTime -= deltaTime;
                    return true;
                }
                
                if (!hazard.active) {
                    hazard.active = true;
                }
                
                switch(hazard.type) {
                    case 'hell_meteor':
                        hazard.y += 12 * deltaTime;
                        break;
                    case 'lava_geyser':
                        hazard.y = canvas.height;
                        hazard.size += 3 * deltaTime;
                        break;
                    case 'soul_vortex':
                        hazard.size += 2 * deltaTime;
                        const dx = hazard.x - gameState.player.x;
                        const dy = hazard.y - gameState.player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 200) {
                            gameState.player.x += (dx / dist) * 2;
                            gameState.player.y += (dy / dist) * 2;
                        }
                        break;
                }
                
                const dist = Math.sqrt(
                    Math.pow(hazard.x - gameState.player.x, 2) + 
                    Math.pow(hazard.y - gameState.player.y, 2)
                );
                
                if (dist < hazard.size && hazard.active && gameState.player.invulnerabilityFrames <= 0) {
                    if (!gameState.player.skills.hell_walker) {
                        gameState.player.health -= hazard.damage;
                        gameState.player.invulnerabilityFrames = 60;
                    }
                    return false;
                }
                
                return hazard.y < canvas.height + 100 && hazard.size < 300;
            });
        }

        function updateBullets(deltaTime) {
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                
                return bullet.y > -50 && bullet.y < canvas.height + 50 &&
                       bullet.x > -50 && bullet.x < canvas.width + 50;
            });
        }

        function updateEnemyBullets(deltaTime) {
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                
                if (bullet.tracking && Math.random() < 0.2) {
                    const dx = gameState.player.x - bullet.x;
                    const dy = gameState.player.y - bullet.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    bullet.vx += (dx / dist) * (bullet.trackingStrength || 0.5);
                    bullet.vy += (dy / dist) * (bullet.trackingStrength || 0.5);
                }
                
                if (bullet.wave) {
                    bullet.x += Math.sin(Date.now() * 0.01 + bullet.waveOffset) * 3;
                }
                
                return bullet.y > -50 && bullet.y < canvas.height + 50 &&
                       bullet.x > -50 && bullet.x < canvas.width + 50;
            });
        }

        function updateParticles(deltaTime) {
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;
                particle.life -= deltaTime;
                particle.alpha = particle.life / particle.maxLife;
                
                return particle.life > 0;
            });
        }

        function checkCollisions() {
            // Player bullets vs Boss
            gameState.bullets.forEach((bullet, bulletIndex) => {
                const boss = gameState.boss;
                
                const dist = Math.sqrt(
                    Math.pow(bullet.x - boss.x, 2) + 
                    Math.pow(bullet.y - boss.y, 2)
                );
                
                if (dist < 60) {
                    let damage = bullet.damage;
                    
                    if (gameState.player.skills.nightmare_ender && boss.health < boss.maxHealth * 0.1) {
                        damage = boss.health;
                    }
                    
                    if (gameState.player.skills.demon_slayer && boss.currentPhase >= boss.phases - 1) {
                        damage *= 2;
                    }
                    
                    // Endless mode score bonus
                    if (gameState.gameMode === 'endless' && gameState.player.skills.endless_warrior) {
                        gameState.player.score += Math.floor(damage * 1.25);
                    } else {
                        gameState.player.score += Math.floor(damage);
                    }
                    
                    boss.health -= damage;
                    gameState.bullets.splice(bulletIndex, 1);
                    
                    createHitParticles(bullet.x, bullet.y, bullet.color);
                    updateUI();
                }
            });
            
            // Enemy bullets vs Player
            gameState.enemyBullets.forEach((bullet, bulletIndex) => {
                const player = gameState.player;
                
                if (player.invulnerabilityFrames > 0) return;
                
                let hitboxSize = player.precisionMode ? 15 : 25;
                if (player.skills.precision_aim && player.precisionMode) {
                    hitboxSize = 10;
                }
                
                const dist = Math.sqrt(
                    Math.pow(bullet.x - player.x, 2) + 
                    Math.pow(bullet.y - player.y, 2)
                );
                
                if (dist < hitboxSize) {
                    let damage = bullet.damage || 25;
                    
                    player.health -= damage;
                    gameState.enemyBullets.splice(bulletIndex, 1);
                    player.invulnerabilityFrames = 30;
                    
                    player.stress = Math.min(player.maxStress, player.stress + 10);
                    gameState.screenShake = 8;
                    
                    createHitParticles(bullet.x, bullet.y, '#ff0000');
                    updateUI();
                }
            });
            
            if (gameState.enemyBullets.length >= 1000) {
                unlockAchievement('bullet_dancer');
            }
        }

        function createHitParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    color: color,
                    size: Math.random() * 8 + 3,
                    life: 60,
                    maxLife: 60,
                    alpha: 1
                });
            }
        }

        function levelComplete() {
            gameState.gameRunning = false;
            
            const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
            gameState.totalSurvivalTime += survivalTime;
            
            // Calculate scoring
            const timeBonus = Math.max(0, 20000 - (survivalTime * 100));
            const healthBonus = gameState.player.health * 50;
            const phaseBonus = gameState.boss.phases * 1000;
            const stressBonus = (100 - gameState.player.stress) * 20;
            
            gameState.player.score += timeBonus + healthBonus + phaseBonus + stressBonus;
            
            // Award soul fragments
            let fragmentsEarned = Math.floor(gameState.currentLevel * 2) + 5;
            
            if (gameState.gameMode === 'endless') {
                fragmentsEarned = Math.floor(gameState.endlessWave * 0.5);
            } else if (gameState.gameMode === 'speedrun') {
                fragmentsEarned = Math.floor(survivalTime < 30 ? 50 : 25);
            }
            
            gameState.skillPoints += fragmentsEarned;
            
            // Update statistics
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            savedData.totalBossesDefeated = (savedData.totalBossesDefeated || 0) + 1;
            
            if (gameState.gameMode === 'campaign') {
                savedData.highestLevel = Math.max(savedData.highestLevel || 1, gameState.currentLevel + 1);
            } else if (gameState.gameMode === 'endless') {
                savedData.endlessBestWave = Math.max(savedData.endlessBestWave || 0, gameState.endlessWave);
                savedData.endlessBestScore = Math.max(savedData.endlessBestScore || 0, gameState.player.score);
            } else if (gameState.gameMode === 'speedrun') {
                const currentTime = gameState.totalSurvivalTime;
                if (!savedData.speedrunBestTime || currentTime < savedData.speedrunBestTime) {
                    savedData.speedrunBestTime = currentTime;
                }
            }
            
            savedData.bestScore = Math.max(savedData.bestScore || 0, gameState.player.score);
            savedData.skillPoints = (savedData.skillPoints || 0) + fragmentsEarned;
            savedData.longestSurvival = Math.max(savedData.longestSurvival || 0, survivalTime);
            
            if (!savedData.completedLevels) {
                savedData.completedLevels = [];
            }
            if (gameState.gameMode === 'campaign' && !savedData.completedLevels.includes(gameState.currentLevel)) {
                savedData.completedLevels.push(gameState.currentLevel);
            }
            
            // Mobile achievement
            if (gameState.isMobile) {
                const mobileCompletions = (savedData.mobileCompletions || 0) + 1;
                savedData.mobileCompletions = mobileCompletions;
                if (mobileCompletions >= 10) {
                    unlockAchievement('mobile_warrior');
                }
            }
            
            // Achievement checks
            if (gameState.currentLevel === 1) unlockAchievement('first_pain');
            if (gameState.currentLevel === 10) unlockAchievement('hell_walker');
            if (gameState.currentLevel === 15) unlockAchievement('demon_slayer');
            if (gameState.currentLevel === 20) unlockAchievement('nightmare_ender');
            
            if (survivalTime < 30) {
                unlockAchievement('speed_demon');
            }
            
            if (gameState.player.health === gameState.player.maxHealth) {
                unlockAchievement('perfect_hell');
            }
            
            if (gameState.gameMode === 'endless' && gameState.endlessWave >= 50) {
                unlockAchievement('endless_legend');
            }
            
            if (gameState.gameMode === 'speedrun' && gameState.totalSurvivalTime < 600) {
                unlockAchievement('speedrun_god');
            }
            
            localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
            
            // Auto-submit to leaderboard if player name exists
            if (savedData.playerName) {
                let playerData = { name: savedData.playerName };
                
                if (gameState.gameMode === 'campaign') {
                    playerData.score = gameState.player.score;
                    playerData.level = gameState.currentLevel;
                    addToLeaderboard('campaign', playerData);
                } else if (gameState.gameMode === 'endless') {
                    playerData.score = gameState.player.score;
                    playerData.wave = gameState.endlessWave;
                    addToLeaderboard('endless', playerData);
                } else if (gameState.gameMode === 'speedrun' && gameState.currentLevel >= 20) {
                    playerData.time = formatSecondsToTime(Math.floor(gameState.totalSurvivalTime));
                    playerData.score = gameState.player.score;
                    addToLeaderboard('speedrun', playerData);
                }
            }
            
            if (gameState.gameMode === 'campaign' && gameState.currentLevel >= 20) {
                unlockAchievement('ultimate_survivor');
                document.getElementById('victoryScore').textContent = gameState.player.score.toLocaleString();
                document.getElementById('victoryTime').textContent = Math.floor(gameState.totalSurvivalTime);
                showScreen('victory');
            } else if (gameState.gameMode === 'campaign') {
                setTimeout(() => {
                    gameState.currentLevel++;
                    startGame();
                }, 4000);
            } else {
                // Continue endless or return to menu for other modes
                if (gameState.gameMode === 'endless') {
                    setTimeout(() => {
                        startGame();
                    }, 2000);
                } else {
                    showScreen('mainMenu');
                }
            }
            
            updateUI();
            generateLevelGrid();
        }

        function gameOver() {
            gameState.gameRunning = false;
            
            const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
            
            let soulFragmentsEarned = Math.floor(gameState.currentLevel) + Math.floor(survivalTime / 10);
            
            if (gameState.gameMode === 'endless') {
                soulFragmentsEarned = Math.floor(gameState.endlessWave * 0.5);
            }
            
            gameState.skillPoints += soulFragmentsEarned;
            
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            savedData.totalDeaths = (savedData.totalDeaths || 0) + 1;
            savedData.skillPoints = (savedData.skillPoints || 0) + soulFragmentsEarned;
            savedData.longestSurvival = Math.max(savedData.longestSurvival || 0, survivalTime);
            
            if (gameState.gameMode === 'endless') {
                savedData.endlessBestWave = Math.max(savedData.endlessBestWave || 0, gameState.endlessWave);
                savedData.endlessBestScore = Math.max(savedData.endlessBestScore || 0, gameState.player.score);
            }
            
            localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
            
            document.getElementById('finalScore').textContent = gameState.player.score.toLocaleString();
            document.getElementById('finalLevel').textContent = gameState.gameMode === 'endless' ? 
                `Wave ${gameState.endlessWave}` : gameState.currentLevel;
            document.getElementById('finalTime').textContent = Math.floor(survivalTime);
            document.getElementById('earnedSkillPoints').textContent = soulFragmentsEarned;
            
            showScreen('gameOver');
            updateUI();
        }

        function forfeitSoul() {
            if (confirm('Are you sure you want to forfeit your soul and return to the menu?')) {
                gameState.gameRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                showScreen('mainMenu');
            }
        }

        function restartGame() {
            gameState.gameRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            startGame();
        }

        function restartCurrentLevel() {
            restartGame();
        }

        function toggleBossInfo() {
            const indicator = document.getElementById('phaseIndicator');
            indicator.style.display = indicator.style.display === 'none' ? 'block' : 'none';
        }

        function pauseGame() {
            gameState.gamePaused = true;
        }

        function resumeGame() {
            gameState.gamePaused = false;
            gameLoop();
        }

        // Rendering Functions
        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState.screenShake > 0) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
            }
            
            renderHellBackground();
            renderEnvironmentalHazards();
            renderPlayer();
            renderBoss();
            renderBullets();
            renderEnemyBullets();
            renderParticles();
            
            if (gameState.bulletTimeActive) {
                renderBulletTimeOverlay();
            }
            
            if (gameState.player.stress >= 80) {
                renderStressOverlay();
            }
            
            if (gameState.screenShake > 0) {
                ctx.restore();
            }
        }

        function renderHellBackground() {
            ctx.save();
            ctx.globalAlpha = 0.4;
            
            for (let i = 0; i < 150; i++) {
                const x = (Date.now() * 0.03 + i * 30) % (canvas.width + 100);
                const y = (i * 17) % canvas.height;
                const size = Math.sin(Date.now() * 0.002 + i) * 3 + 3;
                
                const colors = ['#ff0000', '#ff4500', '#ff6600', '#ff8800'];
                ctx.fillStyle = colors[i % colors.length];
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function renderPlayer() {
            const player = gameState.player;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (player.invulnerabilityFrames > 0 && Math.floor(player.invulnerabilityFrames / 5) % 2) {
                ctx.globalAlpha = 0.5;
            }
            
            ctx.fillStyle = player.precisionMode ? '#ffff00' : '#00ffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            
            // Scale for mobile
            const scale = gameState.isMobile ? 1.2 : 1;
            ctx.scale(scale, scale);
            
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(-15, 15);
            ctx.lineTo(-5, 10);
            ctx.lineTo(0, 5);
            ctx.lineTo(5, 10);
            ctx.lineTo(15, 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#ff6b6b';
            ctx.globalAlpha = 0.8;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(-6 + i * 6, 20, 5 - i, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (player.invulnerabilityFrames > 0) {
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            if (player.precisionMode) {
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function renderBoss() {
            const boss = gameState.boss;
            
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            if (boss.phaseTransition) {
                ctx.globalAlpha = 0.7 + Math.sin(Date.now() * 0.02) * 0.3;
            }
            
            const phaseColors = ['#ff1493', '#ff0000', '#8b0000', '#660000', '#330000'];
            ctx.fillStyle = phaseColors[Math.min(boss.currentPhase - 1, phaseColors.length - 1)];
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            
            const size = 60 + (boss.currentPhase * 10);
            ctx.beginPath();
            ctx.rect(-size, -size/2, size*2, size);
            ctx.fill();
            ctx.stroke();
            
            const wingSize = 40 + (boss.currentPhase * 5);
            ctx.beginPath();
            ctx.moveTo(-size - wingSize, -20);
            ctx.lineTo(-size, -30);
            ctx.lineTo(-size, 30);
            ctx.lineTo(-size - wingSize, 20);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(size + wingSize, -20);
            ctx.lineTo(size, -30);
            ctx.lineTo(size, 30);
            ctx.lineTo(size + wingSize, 20);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            const coreSize = 15 + Math.sin(Date.now() * 0.03) * 8 + (boss.currentPhase * 3);
            const coreColors = ['#ffff00', '#ff8800', '#ff4400', '#ff0000', '#8b0000'];
            ctx.fillStyle = coreColors[Math.min(boss.currentPhase - 1, coreColors.length - 1)];
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fill();
            
            if (boss.currentPhase >= 3) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, 0, size + 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (boss.currentPhase >= 5) {
                ctx.globalAlpha = 0.2;
                for (let i = 0; i < 5; i++) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size + (i * 10), 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
        }

        function renderBullets() {
            gameState.bullets.forEach(bullet => {
                ctx.save();
                
                if (bullet.charged || bullet.desperation) {
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = 15;
                }
                
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y + 12, bullet.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        function renderEnemyBullets() {
            gameState.enemyBullets.forEach(bullet => {
                ctx.save();
                
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (bullet.size > 15) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.size + Math.sin(Date.now() * 0.02) * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (bullet.tracking) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                if (bullet.ultimate) {
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = 20;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        function renderParticles() {
            gameState.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.shadowColor = particle.color;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function renderEnvironmentalHazards() {
            gameState.environmentalHazards.forEach(hazard => {
                ctx.save();
                
                if (hazard.warningTime > 0) {
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(hazard.x, hazard.y + 150, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', hazard.x, hazard.y + 155);
                } else {
                    switch(hazard.type) {
                        case 'hell_meteor':
                            ctx.fillStyle = '#ff4500';
                            ctx.shadowColor = '#ff4500';
                            ctx.shadowBlur = 25;
                            ctx.beginPath();
                            ctx.arc(hazard.x, hazard.y, hazard.size, 0, Math.PI * 2);
                            ctx.fill();
                            
                            for (let i = 1; i <= 5; i++) {
                                ctx.globalAlpha = 0.8 - (i * 0.15);
                                ctx.beginPath();
                                ctx.arc(hazard.x, hazard.y - (i * 15), hazard.size * (1 - i * 0.1), 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;
                            
                        case 'lava_geyser':
                            ctx.fillStyle = '#ff6600';
                            ctx.shadowColor = '#ff6600';
                            ctx.shadowBlur = 30;
                            ctx.beginPath();
                            ctx.arc(hazard.x, hazard.y, hazard.size, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                            
                        case 'soul_vortex':
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = '#9932cc';
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 6;
                            ctx.beginPath();
                            ctx.arc(hazard.x, hazard.y, hazard.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2 + (Date.now() * 0.01);
                                const radius = hazard.size * 0.7;
                                ctx.beginPath();
                                ctx.arc(
                                    hazard.x + Math.cos(angle) * radius,
                                    hazard.y + Math.sin(angle) * radius,
                                    5, 0, Math.PI * 2
                                );
                                ctx.fill();
                            }
                            break;
                    }
                }
                
                ctx.restore();
            });
        }

        function renderBulletTimeOverlay() {
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#00ffff';
            ctx.font = `bold ${Math.min(28, canvas.width * 0.04)}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText('BULLET TIME', canvas.width / 2, 60);
            
            ctx.restore();
        }

        function renderStressOverlay() {
            ctx.save();
            ctx.globalAlpha = 0.1 + (gameState.player.stress / 100) * 0.3;
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState.player.stress >= 90) {
                ctx.globalAlpha = 0.8;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.lineTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
        }

        // UI Management
        function updateUI() {
            document.getElementById('currentLevel').textContent = gameState.gameMode === 'endless' ? 
                `W${gameState.endlessWave}` : gameState.currentLevel;
            document.getElementById('playerLives').textContent = gameState.player.lives;
            document.getElementById('playerEnergy').textContent = Math.floor(gameState.player.energy);
            document.getElementById('playerScore').textContent = gameState.player.score.toLocaleString();
            document.getElementById('playerStress').textContent = Math.floor(gameState.player.stress);
            
            const playerHealthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('playerHealthFill').style.width = Math.max(0, playerHealthPercent) + '%';
            document.getElementById('playerHealthText').textContent = 
                `${Math.max(0, Math.floor(gameState.player.health))} / ${gameState.player.maxHealth}`;
            
            if (gameState.boss) {
                const bossHealthPercent = (gameState.boss.health / gameState.boss.maxHealth) * 100;
                document.getElementById('bossHealthFill').style.width = Math.max(0, bossHealthPercent) + '%';
                document.getElementById('bossHealthText').textContent = 
                    `${Math.max(0, Math.floor(gameState.boss.health))} / ${gameState.boss.maxHealth}`;
            }
            
            const stressPercent = (gameState.player.stress / gameState.player.maxStress) * 100;
            document.getElementById('stressFill').style.height = stressPercent + '%';
            
            document.getElementById('intensityFill').style.width = gameState.bulletHellIntensity + '%';
            
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            document.getElementById('totalBossesDefeated').textContent = savedData.totalBossesDefeated || 0;
            document.getElementById('highestLevel').textContent = savedData.highestLevel || 1;
            document.getElementById('totalScore').textContent = (savedData.bestScore || 0).toLocaleString();
            document.getElementById('skillPoints').textContent = savedData.skillPoints || 0;
            document.getElementById('availableSkillPoints').textContent = savedData.skillPoints || 0;
            
            // Calculate global rank based on leaderboard position
            const campaignBoard = globalLeaderboard.campaign || [];
            const playerRank = campaignBoard.findIndex(entry => 
                savedData.playerName && entry.name === savedData.playerName
            ) + 1;
            document.getElementById('globalRank').textContent = playerRank > 0 ? playerRank : '-';
            
            document.getElementById('endlessRecord').textContent = savedData.endlessBestWave || 0;
            
            // Endless mode stats
            document.getElementById('endlessBestWave').textContent = savedData.endlessBestWave || 0;
            document.getElementById('endlessBestScore').textContent = (savedData.endlessBestScore || 0).toLocaleString();
            document.getElementById('endlessTotalTime').textContent = Math.floor((savedData.endlessTotalTime || 0) / 60);
            
            // Speedrun stats
            const bestTime = savedData.speedrunBestTime;
            if (bestTime) {
                const minutes = Math.floor(bestTime / 60);
                const seconds = Math.floor(bestTime % 60);
                document.getElementById('speedrunBestTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Get world record from leaderboard
            const speedrunBoard = globalLeaderboard.speedrun || [];
            if (speedrunBoard.length > 0) {
                document.getElementById('speedrunWorldRecord').textContent = speedrunBoard[0].time;
            }
            
            document.getElementById('speedrunAttempts').textContent = savedData.speedrunAttempts || 0;
            
            // Statistics screen
            document.getElementById('statTotalBosses').textContent = savedData.totalBossesDefeated || 0;
            document.getElementById('statHighestLevel').textContent = savedData.highestLevel || 1;
            document.getElementById('statBestScore').textContent = (savedData.bestScore || 0).toLocaleString();
            document.getElementById('statTotalDeaths').textContent = savedData.totalDeaths || 0;
            document.getElementById('statSurvivalTime').textContent = Math.floor(savedData.longestSurvival || 0);
            document.getElementById('statAchievements').textContent = (savedData.achievements || []).length;
            
            gameState.skillPoints = savedData.skillPoints || 0;
        }

        // Data persistence
        function saveGameData() {
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            localStorage.setItem('hellBossRushSave', JSON.stringify(savedData));
        }

        function loadGameData() {
            const savedData = JSON.parse(localStorage.getItem('hellBossRushSave') || '{}');
            gameState.skillPoints = savedData.skillPoints || 0;
            gameState.player.skills = savedData.skills || {};
            gameState.playerName = savedData.playerName || '';
        }

        function resetStats() {
            if (confirm('Are you sure you want to purge your soul? This will delete all progress, skills, and achievements!')) {
                localStorage.removeItem('hellBossRushSave');
                localStorage.removeItem('customBosses');
                localStorage.removeItem('hellBossRushLeaderboard');
                gameState.currentLevel = 1;
                gameState.skillPoints = 0;
                gameState.player.skills = {};
                gameState.playerName = '';
                loadLeaderboardData();
                updateUI();
                generateLevelGrid();
                generateSkillTree();
                generateAchievements();
                generateLeaderboard();
                showNotification('Soul purged! All progress reset.', 'achievement');
            }
        }

        // Particle system for menu
        function createHellParticles() {
            const particlesContainer = document.getElementById('particles');
            
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (Math.random() * 2 + 3) + 's';
                
                const colors = ['#ff0000', '#ff4500', '#ff6600', '#dc143c', '#8b0000'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                particlesContainer.appendChild(particle);
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
