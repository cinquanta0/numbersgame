<!DOCTYPE html>
<html lang="en">
<head>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    
     <script type="text/javascript">
   window.SDK_OPTIONS = {
      gameId: "unnmh9hjtru4a1sfxm7sjqcxiv69e1s4",
      onEvent: function (a) {
         switch (a.name) {
            case "SDK_GAME_PAUSE":
               // pause game logic / mute audio
               break;
            case "SDK_GAME_START":
               // advertisement done, resume game logic and unmute audio
               break;
            case "SDK_READY":
               // when sdk is ready
               break;
         }
      }
   };
(function (a, b, c) {
   var d = a.getElementsByTagName(b)[0];
   a.getElementById(c) || (a = a.createElement(b), a.id = c, a.src = "https://api.gamemonetize.com/sdk.js", d.parentNode.insertBefore(a, d))
})(document, "script", "gamemonetize-sdk"); 


if (typeof sdk !== 'undefined' && sdk.showBanner !== 'undefined') {
sdk.showBanner();
}


</script>
    
    
    
    
      <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>🌟 STELLAR GUARDIAN - COSMIC DEFENSE FORCE 🌟</title>
  <style>
      
      @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');


#nicknameBox {
  background: rgba(0, 0, 0, 0.8) !important; /* Sfondo nero semi-trasparente */
  color: #ffffff !important; /* Testo bianco invece di grigio scuro */
  box-shadow: 0 0 24px #00bcd4;
  border: 2px solid #00bcd4;
  position: relative;
  z-index: 9999;
  backdrop-filter: blur(5px); /* Aggiunge effetto blur */
}

#nicknameInput, #nicknameBox label, #nicknameBox button {
  color: #ffffff !important; /* Bianco invece di #222 */
  font-size: 1.1rem !important;
  background: rgba(255, 255, 255, 0.1); /* Sfondo leggermente più chiaro per input */
}

#nicknameInput {
  background: rgba(255, 255, 255, 0.9) !important; /* Input con sfondo quasi bianco */
  color: #000000 !important; /* Testo nero nell'input per contrasto */
  border: 1px solid #00bcd4;
  padding: 8px;
}

#nicknameBox button {
  background: #00bcd4 !important;
  color: #000000 !important; /* Testo nero sul pulsante azzurro */
  border: none;
  padding: 8px 15px;
  font-weight: bold;
}


.menu-content {
  background: none !important;           /* NIENTE sfondo */
  box-shadow: none !important;           /* NIENTE ombra */
  border: none !important;               /* NIENTE bordo */
  border-radius: 0 !important;           /* NIENTE angoli */
  padding: 0 !important;                 /* Meno spazio */
  max-width: 100vw !important;
  margin: 0 !important;
  text-align: center;
  font-family: 'Press Start 2P', monospace !important;
}

/* Se vuoi un effetto leggerissimo HUD, puoi aggiungere solo una riga trasparente sotto le scritte */
.menu-title, .game-title, .game-subtitle {
  background: none !important;
  box-shadow: none !important;
  border: none !important;
}

.menu-btn {
  font-family: 'Press Start 2P', monospace !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#ffe700 0%,#00bcd4 100%) !important;
  border: 4px solid #222 !important;
  border-radius: 0 !important;
  box-shadow: 0 4px 0 #ffe700, 0 0 12px #00bcd4 !important;
  color: #222 !important;
  font-size: 1.1rem !important;
  text-shadow: 1px 1px 0 #fff !important;
  padding: 1.2rem 2.3rem !important;
  margin: 0.7rem 0 !important;
  image-rendering: pixelated !important;
}
.menu-btn:active, .menu-btn:hover {
  transform: scale(0.97);
  box-shadow: 0 2px 0 #ffe700, 0 0 16px #ffd700 !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#00bcd4 0%,#ffe700 100%) !important;
  color: #fff !important;
}

/* Se vuoi pulsanti più piccoli/fluttuanti */
.menu-buttons {
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 18px !important;
  background: none !important;
  margin: 18px 0 !important;
}

/* Sottotitoli e nickname floating */
.game-subtitle, #nicknameBox {
  background: none !important;
  box-shadow: none !important;
  border: none !important;
  margin: 18px 0 !important;
}





      /* Sfondo pixel art per i menu */
.galaxy-bg {
  background: url('pixel-art-galaxy.png') repeat !important;
  background-size: 900px 600px !important;
  image-rendering: pixelated !important;
  filter: saturate(1.15) brightness(0.96);
}



/* Titolo pixel art */
.game-title {
  font-family: 'Press Start 2P', monospace !important;
  font-size: 3rem !important;
  color: #ffe700 !important;
  letter-spacing: 0.07em !important;
  text-shadow: 0 0 2px #222, 0 0 8px #ffe700 !important;
  border-bottom: 4px dashed #ffe700 !important;
  padding-bottom: 0.7rem !important;
}


/* Statistiche pixel art */
.stat-item {
  background: url('pixel-dither.png') repeat, #222 !important;
  border: 4px solid #ffe700 !important;
  box-shadow: 0 0 16px #ffd70044 !important;
  font-family: 'Press Start 2P', monospace !important;
  color: #ffe700 !important;
  image-rendering: pixelated !important;
}

.stat-value {
  font-size: 2.0rem !important;
  color: #00bcd4 !important;
  text-shadow: 0 0 2px #222, 0 0 6px #00bcd4 !important;
}
      
      
      /* Galaxy animated background for menu */
.galaxy-bg {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 0;
  pointer-events: none;
  background: radial-gradient(ellipse at 60% 30%, #2c3e50 0%, #0a0a2e 65%);
  animation: menuGalaxyMove 18s linear infinite;
}
@keyframes menuGalaxyMove {
  0% { background-position: 0% 0%; }
  100% { background-position: 100% 100%; }
}

/* Glow and shadow for title */
.game-title {
  text-shadow: 0 0 40px #00bcd4, 0 0 80px #ffd700;
  filter: drop-shadow(0 0 12px #ffd700);
  letter-spacing: 0.12em;
}

/* Animated ship icon */
.menu-ship-anim {
  position: absolute;
  bottom: 50px;
  right: 40px;
  animation: floatShipMenu 3s ease-in-out infinite;
  z-index: 2;
}
.menu-ship-anim img {
  width: 110px;
  filter: drop-shadow(0 0 32px #ffd700);
}
@keyframes floatShipMenu {
  0%,100% { transform: translateY(0);}
  50% { transform: translateY(-18px);}
}

.menu-btn {
  font-family: 'Press Start 2P', monospace !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#ffe700 0%,#00bcd4 100%) !important;
  border: 4px solid #222 !important;
  border-radius: 0 !important;
  box-shadow: 0 4px 0 #ffe700, 0 0 12px #00bcd4 !important;
  color: #222 !important;
  font-size: 1.1rem !important;
  text-shadow: 1px 1px 0 #fff !important;
  padding: 1.2rem 2.3rem !important;
  margin: 0.7rem 0 !important;
  image-rendering: pixelated !important;
}
.menu-btn:active, .menu-btn:hover {
  transform: scale(0.97);
  box-shadow: 0 2px 0 #ffe700, 0 0 16px #ffd700 !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#00bcd4 0%,#ffe700 100%) !important;
  color: #fff !important;
}

/* Animated menu entrance */
.screen.active#mainMenu {
  animation: menuFadeIn 1.1s cubic-bezier(.5,2,.3,1);
}
@keyframes menuFadeIn {
  0% { opacity:0; transform: scale(0.9);}
  100% { opacity:1; transform: scale(1);}
}

/* Statistic cards visual boost */
.stat-value {
  color: #ffd700;
  font-size: 2.1rem;
  text-shadow: 0 0 12px #ffd700;
}
.stat-item {
  background: linear-gradient(135deg,#0a0a2e 80%,#00bcd4 100%);
  border: 2px solid #ffd700;
  box-shadow: 0 0 18px #ffd70066;
}

/* Coin counter glowing */
#coinCount {
  color: #ffd700;
  font-size: 2.2rem;
  text-shadow: 0 0 16px #ffd700;
  animation: coinPulse 1.3s infinite;
}
@keyframes coinPulse {
  0%,100% { filter:brightness(1);}
  50% { filter:brightness(1.4);}
}

/* Footer beautification */
.menu-content > div:last-child {
  margin-top: 2.5rem;
  color: #00bcd4;
  font-size: 1.1rem;
  opacity: 0.7;
  text-shadow: 0 0 10px #00bcd4;
}

/* Parallax for stat items (desktop only) */
@media (min-width: 700px) {
  .stat-item {
    transition: transform 0.18s;
  }
}
      
      
      
      
      
      .loading-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: url('image1.png') center center no-repeat, #0a0a2e;
  background-size: contain;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
  pointer-events: auto;
  transition: opacity 0.6s;
}
.loading-screen.hide {
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.6s;
}
.loading-content {
  text-align: center;
}
.spaceship-loader {
  position: relative;
  width: 90px; height: 90px;
  margin: 0 auto 16px;
  animation: loader-float 2.5s ease-in-out infinite;
}
@keyframes loader-float {
  0%, 100% { transform: translateY(0);}
  50% { transform: translateY(-15px);}
}
.spaceship-loader img {
  width: 90px; height: 90px;
  filter: drop-shadow(0 0 25px #00bcd4cc);
}
.flames {
  position: absolute;
  left: 50%; bottom: 0;
  transform: translateX(-50%);
  width: 30px; height: 40px;
  pointer-events: none;
  background: radial-gradient(circle, #ffd70066 60%, transparent 100%);
  z-index: -1;
  animation: flame-flicker 0.18s infinite alternate;
}
@keyframes flame-flicker {
  0% { filter: blur(1px) brightness(1);}
  100% { filter: blur(4px) brightness(1.9);}
}
.loading-bar {
  width: 220px;
  height: 14px;
  background: #222b;
  border-radius: 8px;
  overflow: hidden;
  margin: 24px auto 0;
  border: 2px solid #00bcd4;
  box-shadow: 0 0 12px #00bcd444;
}
.loading-bar-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #ffd700, #00bcd4, #2196f3, #fff);
  border-radius: 8px;
  transition: width 0.5s;
}
.loading-text {
  margin-top: 12px;
  font-size: 1.5rem;
  color: #fff;
  letter-spacing: 2px;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-shadow: 0 0 12px #00bcd4;
}
body.loading {
  overflow: hidden !important;
}
      
      .ship-image {
  width: 100%;
  max-width: 120px;
  animation: float 3s ease-in-out infinite;
  transition: transform 0.3s ease;
}

.ship-image:hover {
  transform: scale(1.1) rotate(2deg);
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

      
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
          -webkit-tap-highlight-color: transparent;
          -webkit-touch-callout: none;
          -webkit-user-select: none;
          user-select: none;
      }

      body {
          font-family: 'Orbitron', monospace;
          background: linear-gradient(45deg, #0a0a2e, #16213e, #1a237e, #3f51b5, #0a0a2e);
          background-size: 500% 500%;
          animation: cosmicGradient 15s ease infinite;
          color: #ffffff;
          touch-action: manipulation;
      }

      @keyframes cosmicGradient {
          0%, 100% { background-position: 0% 50%; }
          25% { background-position: 100% 0%; }
          50% { background-position: 100% 100%; }
          75% { background-position: 0% 100%; }
      }

      #gameContainer {
          width: 100vw;
          height: 100vh;
          position: relative;
      }

      /* Enhanced Mobile Controls */
      .mobile-controls {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          height: clamp(180px, 28vh, 220px);
          background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 0.9));
          display: none;
          z-index: 1000;
          pointer-events: none;
          padding: clamp(15px, 3vw, 25px);
      }

      .mobile-controls.active {
          display: block;
      }

      .mobile-joystick {
          position: absolute;
          bottom: clamp(20px, 4vw, 30px);
          left: clamp(20px, 4vw, 30px);
          width: clamp(100px, 18vw, 140px);
          height: clamp(100px, 18vw, 140px);
          background: rgba(0, 188, 212, 0.15);
          border: 3px solid rgba(0, 188, 212, 0.6);
          border-radius: 50%;
          pointer-events: all;
          touch-action: none;
          display: flex;
          align-items: center;
          justify-content: center;
      }

      .mobile-joystick-knob {
          width: clamp(35px, 7vw, 50px);
          height: clamp(35px, 7vw, 50px);
          background: rgba(0, 188, 212, 0.9);
          border: 2px solid #fff;
          border-radius: 50%;
          transition: all 0.1s ease;
          pointer-events: none;
          box-shadow: 0 0 15px rgba(0, 188, 212, 0.5);
      }

      .mobile-action-buttons {
          position: absolute;
          bottom: clamp(20px, 4vw, 30px);
          right: clamp(20px, 4vw, 30px);
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          row-gap: clamp(16px, 4vw, 24px);
          column-gap: clamp(16px, 4vw, 24px);
          pointer-events: all;
      }

      .mobile-action-btn {
          width: clamp(60px, 12vw, 80px);
          height: clamp(60px, 12vw, 80px);
          background: rgba(0, 188, 212, 0.9);
          border: 3px solid #fff;
          border-radius: 50%;
          color: white;
          font-size: clamp(1.2rem, 3vw, 1.6rem);
          font-weight: bold;
          display: flex;
          align-items: center;
          justify-content: center;
          touch-action: manipulation;
          user-select: none;
          transition: all 0.2s ease;
          box-shadow: 0 4px 15px rgba(0, 188, 212, 0.4);
      }

      .mobile-action-btn:active {
          background: rgba(0, 188, 212, 1);
          transform: scale(0.9);
          box-shadow: 0 0 20px rgba(0, 188, 212, 0.8);
      }

      .mobile-action-btn.special {
          background: rgba(255, 215, 0, 0.9);
          border-color: #ffd700;
          box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
      }

      .mobile-action-btn.special:active {
          background: rgba(255, 215, 0, 1);
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      }

      /* Orientation Selector - Enhanced */
      .orientation-selector {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.95);
          border-radius: 25px;
          border: 3px solid #00bcd4;
          padding: clamp(2rem, 6vw, 3rem);
          text-align: center;
          z-index: 5000;
          display: none; /* Hidden by default */
          max-width: 90vw;
          backdrop-filter: blur(15px);
      }

      .orientation-selector.active {
          display: block;
      }

      .orientation-buttons {
          display: flex;
          gap: clamp(1rem, 3vw, 1.5rem);
          margin-top: clamp(1.5rem, 4vw, 2rem);
          flex-wrap: wrap;
          justify-content: center;
      }

      .orientation-btn {
          padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2rem);
          background: linear-gradient(45deg, #00bcd4, #2196f3);
          border: none;
          border-radius: 15px;
          color: white;
          font-family: 'Orbitron', monospace;
          font-weight: 700;
          cursor: pointer;
          transition: all 0.3s ease;
          min-width: clamp(140px, 25vw, 180px);
          font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      }

      .orientation-btn:hover,
      .orientation-btn:active {
          transform: scale(1.05);
          box-shadow: 0 0 20px rgba(0, 188, 212, 0.6);
      }

      /* Enhanced Responsive Styles */
      .portrait-mode .mobile-controls {
          height: clamp(200px, 30vh, 250px);
      }

      .landscape-mode .mobile-controls {
          height: clamp(140px, 22vh, 180px);
      }

      .landscape-mode .mobile-joystick {
          width: clamp(90px, 15vw, 120px);
          height: clamp(90px, 15vw, 120px);
      }

      .landscape-mode .mobile-action-buttons {
          grid-template-columns: repeat(4, 1fr);
          gap: clamp(8px, 2vw, 12px);
      }

      .landscape-mode .mobile-action-btn {
          width: clamp(50px, 10vw, 65px);
          height: clamp(50px, 10vw, 65px);
          font-size: clamp(1rem, 2.5vw, 1.3rem);
      }

   .screen {
  display: none;
  opacity: 0;
  pointer-events: none;
  width: 100%;
  min-height: 100vh;
  height: auto;
  overflow-y: auto;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  padding: clamp(1rem, 3vw, 2rem);
  transition: opacity .7s cubic-bezier(.5,2,.3,1);
}

.screen.active {
  display: flex;
  opacity: 1;
  pointer-events: auto;
}

.menu-content {
  background: none !important;
  box-shadow: none !important;
  border: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 auto !important;
  max-width: 100vw !important;
  text-align: center !important;
  font-family: 'Press Start 2P', monospace !important;
}

      .game-title {
          font-size: clamp(2.5rem, 10vw, 5rem);
          font-weight: 900;
          background: linear-gradient(45deg, #00bcd4, #2196f3, #3f51b5, #9c27b0, #e91e63, #ff9800);
          background-size: 400% 400%;
          background-clip: text;
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          animation: stellarText 4s ease infinite;
          margin-bottom: clamp(1rem, 3vw, 1.5rem);
          text-shadow: 0 0 40px rgba(0, 188, 212, 0.6);
          letter-spacing: clamp(1px, 0.5vw, 3px);
      }

      .game-subtitle {
          font-size: clamp(1.2rem, 4vw, 2rem);
          color: #00bcd4;
          margin-bottom: clamp(2rem, 5vw, 3rem);
          text-shadow: 0 0 25px #00bcd4;
          animation: stellarPulse 3s ease infinite;
          font-family: 'Rajdhani', sans-serif;
      }

      @keyframes stellarText {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
      }

      @keyframes stellarPulse {
          0%, 100% { opacity: 1; transform: scale(1); text-shadow: 0 0 25px #00bcd4; }
          50% { opacity: 0.8; transform: scale(1.05); text-shadow: 0 0 40px #00bcd4, 0 0 60px #2196f3; }
      }

      .menu-buttons {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(min(300px, 85vw), 1fr));
          gap: clamp(1.5rem, 4vw, 2rem);
          margin-bottom: clamp(2rem, 5vw, 3rem);
      }

      .menu-btn {
          padding: clamp(1.2rem, 4vw, 2rem) clamp(2rem, 5vw, 3rem);
          font-size: clamp(1rem, 3.5vw, 1.4rem);
          font-family: 'Orbitron', monospace;
          font-weight: 700;
          border: none;
          border-radius: 20px;
          cursor: pointer;
          transition: all 0.4s ease;
          background: linear-gradient(45deg, rgba(0, 188, 212, 0.2), rgba(33, 150, 243, 0.2));
          color: white;
          border: 3px solid transparent;
          position: relative;
          overflow: hidden;
          text-transform: uppercase;
          touch-action: manipulation;
          min-height: clamp(60px, 12vw, 80px);
      }

      .menu-btn::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, transparent, rgba(0, 188, 212, 0.4), transparent);
          transition: left 0.6s ease;
      }

      .menu-btn:hover::before,
      .menu-btn:active::before {
          left: 100%;
      }

      .menu-btn:hover,
      .menu-btn:active {
          transform: translateY(-4px) scale(1.02);
          box-shadow: 0 8px 25px rgba(0, 188, 212, 0.4);
          border-color: #00bcd4;
      }

      .menu-btn.primary {
          background: linear-gradient(45deg, #00bcd4, #2196f3, #3f51b5, #9c27b0);
          background-size: 300% 300%;
          animation: stellarGradient 3s ease infinite;
          font-size: clamp(1.2rem, 4vw, 1.8rem);
          padding: clamp(1.5rem, 5vw, 2.5rem) clamp(2.5rem, 6vw, 3.5rem);
      }

      .menu-btn.home-btn {
          position: absolute;
          top: clamp(20px, 4vw, 30px);
          left: clamp(20px, 4vw, 30px);
          padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2.5rem);
          font-size: clamp(0.9rem, 3vw, 1.2rem);
          background: linear-gradient(45deg, #00bcd4, #2196f3);
          border: 2px solid #00bcd4;
          border-radius: 15px;
          z-index: 1000;
      }

      @keyframes stellarGradient {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
      }

      /* HUD Enhancements */
      .hud {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: clamp(120px, 20vh, 160px);
          background: linear-gradient(180deg, rgba(0, 0, 0, 0.95), transparent);
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 0 clamp(1rem, 4vw, 2rem);
          z-index: 10;
          flex-wrap: wrap;
          gap: clamp(0.5rem, 2vw, 1rem);
      }

      .hud-section {
          display: flex;
          gap: clamp(0.8rem, 3vw, 1.5rem);
          align-items: center;
          flex-wrap: wrap;
      }

      .stat-box {
          background: rgba(0, 0, 0, 0.9);
          padding: clamp(0.6rem, 2vw, 1rem);
          border-radius: 15px;
          border: 2px solid;
          text-align: center;
          min-width: clamp(80px, 15vw, 120px);
          backdrop-filter: blur(5px);
      }

      .stat-box.level { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); }
      .stat-box.lives { border-color: #00bcd4; box-shadow: 0 0 15px rgba(0, 188, 212, 0.6); }
      .stat-box.energy { border-color: #4caf50; box-shadow: 0 0 15px rgba(76, 175, 80, 0.4); }
      .stat-box.score { border-color: #9c27b0; box-shadow: 0 0 15px rgba(156, 39, 176, 0.4); }

      .stat-label {
          font-size: clamp(0.7rem, 2vw, 0.9rem);
          opacity: 0.9;
          margin-bottom: 0.2rem;
          font-family: 'Rajdhani', sans-serif;
          font-weight: 600;
      }

      .stat-value {
          font-size: clamp(1rem, 3vw, 1.4rem);
          font-weight: 900;
      }

      .health-container {
          display: flex;
          gap: clamp(1rem, 3vw, 1.5rem);
          align-items: center;
          flex-wrap: wrap;
          justify-content: center;
      }

      .health-bar-wrapper {
          text-align: center;
      }

      .health-bar {
          width: clamp(140px, 30vw, 200px);
          height: clamp(16px, 3vh, 20px);
          background: #333;
          border-radius: 10px;
          border: 2px solid;
          overflow: hidden;
      }

      .health-fill {
          height: 100%;
          transition: width 0.3s ease;
      }

      .health-text {
          font-size: clamp(0.7rem, 2vw, 0.9rem);
          margin-top: 0.3rem;
          font-weight: 600;
      }

      #gameCanvas {
  display: block;
  background: radial-gradient(circle at center, #1a237e, #0a0a2e);
  border: 3px solid;
  border-image: linear-gradient(45deg, #00bcd4, #2196f3, #3f51b5, #9c27b0) 1;
  width: 1280px;
  height: 720px;
  margin: 0 auto;
  image-rendering: pixelated; /* per evitare blur se viene ingrandito */
}

      /* Enhanced Stats Display */
      .stats-display {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(clamp(160px, 35vw, 200px), 1fr));
          gap: clamp(1.5rem, 4vw, 2rem);
          padding: clamp(1.5rem, 4vw, 2.5rem);
          background: rgba(0, 188, 212, 0.1);
          border-radius: 20px;
          border: 3px solid #00bcd4;
          box-shadow: 0 0 30px rgba(0, 188, 212, 0.4);
          margin: clamp(1rem, 3vw, 2rem) 0;
      }

      .stat-item {
          text-align: center;
          padding: clamp(1rem, 3vw, 1.5rem);
          background: rgba(0, 0, 0, 0.5);
          border-radius: 15px;
          border: 2px solid rgba(0, 188, 212, 0.3);
          transition: all 0.3s ease;
      }

      .stat-item:hover {
          transform: translateY(-2px);
          box-shadow: 0 5px 20px rgba(0, 188, 212, 0.3);
      }

      .stat-item .stat-value {
          font-size: clamp(1.5rem, 4vw, 2rem);
          font-weight: 900;
          color: #ffd700;
          text-shadow: 0 0 15px #ffd700;
          margin-bottom: 0.5rem;
      }

      /* Level Grid Enhancements */
      .level-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(clamp(200px, 40vw, 250px), 1fr));
          gap: clamp(1.5rem, 4vw, 2rem);
          margin: clamp(2rem, 5vw, 3rem) 0;
          max-height: 65vh;
          overflow-y: auto;
          padding: clamp(1rem, 3vw, 1.5rem);
      }

      .level-card {
          padding: clamp(1.5rem, 4vw, 2rem);
          background: rgba(0, 0, 0, 0.8);
          border-radius: 20px;
          border: 3px solid #00bcd4;
          cursor: pointer;
          transition: all 0.4s ease;
          text-align: center;
          position: relative;
          min-height: clamp(160px, 25vh, 200px);
      }

      .level-card:hover,
      .level-card:active {
          transform: translateY(-5px) scale(1.02);
          box-shadow: 0 10px 30px rgba(0, 188, 212, 0.6);
      }

      .level-card.locked {
          opacity: 0.5;
          cursor: not-allowed;
          border-color: #666;
      }

      .level-number {
          font-size: clamp(2rem, 6vw, 2.5rem);
          font-weight: 900;
          color: #ffd700;
          margin-bottom: clamp(0.5rem, 2vw, 1rem);
          text-shadow: 0 0 20px #ffd700;
      }

      .level-boss {
          font-size: clamp(1.1rem, 3vw, 1.4rem);
          font-weight: 700;
          color: #00bcd4;
          margin-bottom: clamp(0.5rem, 2vw, 1rem);
      }

      .level-difficulty {
          font-size: clamp(1rem, 2.5vw, 1.2rem);
          margin-bottom: clamp(0.5rem, 2vw, 1rem);
          font-weight: 600;
      }

      .level-phases, .level-warning {
          font-size: clamp(0.9rem, 2vw, 1rem);
          opacity: 0.8;
          margin-bottom: 0.4rem;
      }

      /* Mobile-specific optimizations */
      @media (max-width: 768px) {
          .hud {
              height: clamp(100px, 18vh, 130px);
              padding: 0 clamp(0.5rem, 2vw, 1rem);
          }
          
          .hud-section {
              gap: clamp(0.5rem, 2vw, 1rem);
          }
          
          .stat-box {
              min-width: clamp(70px, 12vw, 90px);
              padding: clamp(0.5rem, 2vw, 0.8rem);
          }

          .menu-content {
              padding: clamp(1.5rem, 5vw, 2rem);
              margin: clamp(0.5rem, 2vw, 1rem);
          }

          .health-container {
              gap: clamp(0.5rem, 2vw, 1rem);
          }

          .health-bar {
              width: clamp(120px, 25vw, 160px);
              height: clamp(14px, 2.5vh, 18px);
          }
      }

      @media (max-width: 480px) {
          .game-title {
              font-size: clamp(2rem, 8vw, 3rem);
              letter-spacing: 1px;
          }
          
          .game-subtitle {
              font-size: clamp(1rem, 3vw, 1.3rem);
          }
          
          .menu-btn {
              padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2rem);
              font-size: clamp(0.9rem, 3vw, 1.1rem);
          }

          .stats-display {
              grid-template-columns: repeat(2, 1fr);
              gap: clamp(1rem, 3vw, 1.5rem);
              padding: clamp(1rem, 3vw, 1.5rem);
          }

          .mobile-joystick {
              width: clamp(90px, 16vw, 110px);
              height: clamp(90px, 16vw, 110px);
          }

          .mobile-action-btn {
              width: clamp(55px, 11vw, 70px);
              height: clamp(55px, 11vw, 70px);
              font-size: clamp(1.1rem, 2.8vw, 1.4rem);
          }
      }

      /* Landscape orientation optimizations */
      @media (orientation: landscape) and (max-height: 500px) {
          .hud {
              height: clamp(80px, 16vh, 100px);
              padding: 0 clamp(0.5rem, 2vw, 1rem);
          }

          .menu-content {
              padding: clamp(1rem, 3vw, 1.5rem);
              max-height: 85vh;
              overflow-y: auto;
          }

          .game-title {
              font-size: clamp(2rem, 6vh, 3rem);
          }

          .game-subtitle {
              font-size: clamp(1rem, 3vh, 1.5rem);
              margin-bottom: clamp(1rem, 3vh, 1.5rem);
          }

          .mobile-controls {
              height: clamp(130px, 25vh, 160px);
          }

          .mobile-joystick {
              width: clamp(80px, 14vw, 100px);
              height: clamp(80px, 14vw, 100px);
              bottom: clamp(15px, 3vh, 25px);
              left: clamp(15px, 3vh, 25px);
          }

          .mobile-action-buttons {
              bottom: clamp(15px, 3vh, 25px);
              right: clamp(15px, 3vh, 25px);
              grid-template-columns: repeat(4, 1fr);
              gap: clamp(8px, 2vw, 12px);
          }

          .mobile-action-btn {
              width: clamp(45px, 9vw, 60px);
              height: clamp(45px, 9vw, 60px);
              font-size: clamp(0.9rem, 2.2vw, 1.2rem);
          }
      }

      /* Touch-specific improvements */
      @media (hover: none) and (pointer: coarse) {
          .menu-btn:hover {
              transform: none;
              box-shadow: none;
              border-color: transparent;
          }
          
          .menu-btn:active {
              transform: scale(0.98);
              box-shadow: 0 4px 15px rgba(0, 188, 212, 0.4);
          }

          .level-card:hover {
              transform: none;
              box-shadow: none;
          }

          .level-card:active {
              transform: scale(0.98);
              box-shadow: 0 4px 15px rgba(0, 188, 212, 0.4);
          }

          .stat-item:hover {
              transform: none;
              box-shadow: none;
          }
      }

      /* Notification System */
      .notification {
          position: fixed;
          top: clamp(20px, 4vw, 30px);
          right: clamp(20px, 4vw, 30px);
          background: linear-gradient(45deg, #00bcd4, #2196f3);
          color: white;
          padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2rem);
          border-radius: 15px;
          border: 2px solid #00bcd4;
          box-shadow: 0 0 20px rgba(0, 188, 212, 0.6);
          z-index: 3000;
          animation: slideInRight 0.5s ease, fadeOut 0.5s ease 4.5s forwards;
          font-size: clamp(0.9rem, 2.5vw, 1.1rem);
          max-width: 80vw;
          font-weight: 600;
      }

      @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
      }

      @keyframes fadeOut {
          to { opacity: 0; transform: translateX(100%); }
      }

      /* Particle System */
      .particles {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          overflow: hidden;
      }

      .particle {
          position: absolute;
          width: 4px;
          height: 4px;
          background: #00bcd4;
          border-radius: 50%;
          opacity: 0.8;
          animation: stellarParticleFloat 4s linear infinite;
      }

      @keyframes stellarParticleFloat {
          0% {
              transform: translateY(100vh) rotate(0deg);
              opacity: 0;
          }
          10% {
              opacity: 0.8;
          }
          90% {
              opacity: 0.8;
          }
          100% {
              transform: translateY(-10px) rotate(360deg);
              opacity: 0;
          }
      }

      /* Additional Effects */
      .transformation-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: radial-gradient(circle, transparent 30%, rgba(0, 188, 212, 0.3) 70%);
          opacity: 0;
          transition: opacity 0.5s ease;
          pointer-events: none;
          z-index: 100;
      }

      .transformation-overlay.active {
          opacity: 1;
          animation: transformationPulse 2s ease infinite;
      }

      @keyframes transformationPulse {
          0%, 100% { background: radial-gradient(circle, transparent 30%, rgba(0, 188, 212, 0.3) 70%); }
          50% { background: radial-gradient(circle, transparent 20%, rgba(0, 188, 212, 0.6) 80%); }
      }

      .difficulty-warning {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 188, 212, 0.95);
          color: white;
          padding: clamp(1.5rem, 5vw, 2.5rem) clamp(2rem, 6vw, 3rem);
          border-radius: 20px;
          font-size: clamp(1.5rem, 5vw, 2.5rem);
          font-weight: 900;
          text-align: center;
          opacity: 0;
          animation: warningFlash 0.3s ease infinite alternate;
          z-index: 2000;
          max-width: 90vw;
      }

      @keyframes warningFlash {
          0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
          100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
      }

      /* HUD Elements */
      .endless-hud, .speedrun-timer, .phase-indicator {
          font-size: clamp(0.9rem, 2.5vw, 1.2rem);
          padding: clamp(0.8rem, 3vw, 1.2rem);
          background: rgba(0, 0, 0, 0.8);
          border-radius: 12px;
          border: 2px solid #00bcd4;
          position: absolute;
          top: clamp(20px, 4vw, 30px);
          right: clamp(20px, 4vw, 30px);
          z-index: 100;
          font-weight: 600;
      }

      .energy-meter {
          position: absolute;
          bottom: clamp(20px, 4vw, 30px);
          left: 50%;
          transform: translateX(-50%);
          width: clamp(180px, 45vw, 320px);
          height: clamp(14px, 3vh, 18px);
          background: rgba(0, 0, 0, 0.8);
          border: 2px solid #00bcd4;
          border-radius: 10px;
          overflow: hidden;
      }

      .energy-fill {
          height: 100%;
          background: linear-gradient(90deg, #4caf50, #8bc34a, #cddc39, #ffeb3b);
          transition: width 0.3s ease;
      }
      body.portrait-mode #gameCanvas {
          width: 100vw;
          height: 80vh;
      }

      body.landscape-mode #gameCanvas {
          width: 100vw;
          height: 100vh;
      }

      /* Control Adjustment Overlay */
      .control-adjustment-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.95);
          z-index: 7000;
          display: none;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          padding: clamp(1rem, 4vw, 2rem);
          backdrop-filter: blur(15px);
      }

      .control-adjustment-overlay.active {
          display: flex;
      }

      .adjustment-area {
          position: relative;
          width: 90vw;
          height: 80vh;
          max-width: 800px;
          max-height: 600px;
          border: 3px dashed #00bcd4;
          background: rgba(0, 188, 212, 0.05);
          border-radius: 20px;
          overflow: hidden;
      }

      .draggable-control {
          position: absolute;
          cursor: grab;
          touch-action: none; /* Prevent default touch actions */
          z-index: 10;
      }

      .draggable-control.dragging {
          cursor: grabbing;
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
          border-color: #ffd700 !important;
      }

      .adjustment-buttons {
          margin-top: 2rem;
          display: flex;
          gap: 1rem;
          flex-wrap: wrap;
          justify-content: center;
          z-index: 20; /* Assicurati che sia sopra i controlli drag */
          position: relative; /* oppure absolute se preferisci */
        }
   
   /* PATCH: Migliora spazio di gioco e controlli su mobile */
@media (pointer: coarse), (max-width: 700px) {
  /* Pulsanti più piccoli */
  .mobile-controls {
    height: clamp(84px, 15vh, 110px) !important;
    padding: clamp(5px, 2vw, 12px) !important;
    background: linear-gradient(180deg, transparent, rgba(0,0,0,0.6)) !important;
  }
  .mobile-joystick {
    width: clamp(44px, 10vw, 60px) !important;
    height: clamp(44px, 10vw, 60px) !important;
    left: clamp(7px, 2vw, 14px) !important;
    bottom: clamp(8px, 2vw, 12px) !important;
    border-width: 2px !important;
  }
  .mobile-joystick-knob {
    width: clamp(17px, 3.5vw, 23px) !important;
    height: clamp(17px, 3.5vw, 23px) !important;
    border-width: 1.5px !important;
  }
  .mobile-action-buttons {
    bottom: clamp(8px, 2vw, 12px) !important;
    right: clamp(7px, 2vw, 14px) !important;
    row-gap: clamp(6px, 2vw, 10px) !important;
    column-gap: clamp(6px, 2vw, 10px) !important;
  }
  .mobile-action-btn {
    width: clamp(28px, 7vw, 36px) !important;
    height: clamp(28px, 7vw, 36px) !important;
    font-size: clamp(0.9rem, 2vw, 1.1rem) !important;
    border-width: 2px !important;
    box-shadow: 0 2px 8px #00bcd444;
  }
  .mobile-action-btn.special {
    font-size: clamp(0.9rem, 2vw, 1.1rem) !important;
  }

  /* HUD e barra superiore più compatte */
  .hud {
    height: clamp(50px, 9vh, 65px) !important;
    padding: 0 clamp(0.2rem, 1vw, 0.5rem) !important;
    gap: 0.3rem !important;
  }
  .stat-box {
    min-width: 38px !important;
    padding: 0.25rem 0.1rem !important;
    font-size: 0.65rem !important;
  }
  .stat-value {
    font-size: 0.92rem !important;
  }
  .health-bar {
    height: 9px !important;
    width: 45px !important;
  }
  .menu-btn.home-btn {
    font-size: 0.75rem !important;
    padding: 0.4rem 0.5rem !important;
    min-width: 20px !important;
  }

  /* Game canvas più ampio e spazioso */
  body.portrait-mode #gameCanvas {
    width: 100vw !important;
    height: 92vh !important;
    max-height: 92vh !important;
    margin-top: 0 !important;
  }
  body.landscape-mode #gameCanvas {
    width: 100vw !important;
    height: 100vh !important;
    max-height: 100vh !important;
    margin-top: 0 !important;
  }

  /* Le barre e pulsanti fuori dal canvas coprono meno spazio */
  .energy-meter {
    height: 8px !important;
    width: clamp(90px, 30vw, 140px) !important;
    bottom: clamp(3px, 1vw, 6px) !important;
  }
}
   
    /* PATCH: landscape ottimizzato per mobile */
  @media (pointer: coarse), (max-width: 900px) {
    body.landscape-mode #gameCanvas {
      width: 100vw !important;
      height: 100vh !important;
      max-height: 100vh !important;
      margin: 0 !important;
    }
    .hud {
      height: 44px !important;
      padding: 0 8px !important;
      font-size: 0.95em !important;
      gap: 0.3em !important;
    }
    .mobile-controls {
      height: 60px !important;
      padding: 6px !important;
      bottom: 0 !important;
      background: linear-gradient(180deg, transparent, rgba(0,0,0,0.45)) !important;
    }
    .mobile-joystick {
      width: 44px !important;
      height: 44px !important;
      left: 8px !important;
      bottom: 8px !important;
    }
    .mobile-action-buttons {
      right: 8px !important;
      bottom: 8px !important;
    }
    .mobile-action-btn {
      width: 32px !important;
      height: 32px !important;
      font-size: 1rem !important;
    }
    /* Nascondi info secondarie per più spazio */
    .stat-box.level,
    .stat-box.energy,
    .stat-box.lives,
    .stat-box.score {
      font-size: 0.88em !important;
    }
    .game-subtitle, .game-title {
      font-size: 1.1em !important;
    }
  }
   
   
  /* PATCH: Joystick mobile più grande ma non esagerato */
@media (pointer: coarse), (max-width: 900px) {
  .mobile-joystick {
    width: clamp(84px, 16vw, 108px) !important;
    height: clamp(84px, 16vw, 108px) !important;
    left: clamp(14px, 4vw, 22px) !important;
    bottom: clamp(14px, 4vw, 22px) !important;
    border-width: 3px !important;
    box-shadow: 0 0 13px #00bcd4cc;
  }
  .mobile-joystick-knob {
    width: clamp(34px, 7vw, 46px) !important;
    height: clamp(34px, 7vw, 46px) !important;
    border-width: 2px !important;
  }
}

@media (max-width: 600px) {
  /* Solo un po' più grande su telefoni piccoli */
  .mobile-joystick {
    width: clamp(90px, 22vw, 120px) !important;
    height: clamp(90px, 22vw, 120px) !important;
    left: clamp(10px, 4vw, 18px) !important;
    bottom: clamp(10px, 4vw, 18px) !important;
  }
  .mobile-joystick-knob {
    width: clamp(38px, 8vw, 54px) !important;
    height: clamp(38px, 8vw, 54px) !important;
  }
}
   
   
   .duel-lobby {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  background: linear-gradient(135deg, #141e30 80%, #243b55 100%);
  border-radius: 24px; box-shadow: 0 0 80px #00bcd466;
  padding: 2.5rem 2.5rem 2.2rem 2.5rem; text-align: center;
  z-index: 9000; min-width: 380px; max-width: 95vw; min-height: 290px;
  animation: popin 0.7s cubic-bezier(.5,2,.3,1);
}
@keyframes popin { 0%{transform:scale(0.7) translate(-50%,-50%);} 100%{transform:scale(1) translate(-50%,-50%);} }
.duel-header { font-size: 2.1rem; color: #ffd700; font-weight: bold; margin-bottom: 1.3rem; }
.duel-players { display: flex; align-items: center; justify-content: center; gap: 2.7rem; }
.duel-player { display: flex; flex-direction: column; align-items: center; }
.duel-ship { width: 98px; height: 98px; animation: float 2.2s infinite; border-radius: 16px; background: #222; }
@keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-12px);} }
.duel-nick { margin-top:0.8rem; color: #00bcd4; font-weight: bold; font-size:1.15rem; }
.duel-vs { font-size: 2.7rem; color: #fff; font-weight: bold; text-shadow: 0 0 25px #ffd700; animation: pulse 1.3s infinite; }
@keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.14);} }
.duel-status { margin-top: 1.5rem; color: #fff; font-size: 1.2rem; min-height: 34px; }
.menu-btn { margin-top: 1.6rem; }
.hidden { display: none !important; }

.duel-countdown {
  position: fixed; top: 40%; left: 50%; transform: translate(-50%,-50%);
  font-size: 5rem; color: #ffd700; text-shadow: 0 0 45px #00bcd4;
  font-family: 'Orbitron', monospace; z-index: 9100;
  background: rgba(0,0,0,0.7); border-radius: 20px; padding: 1.5rem 3rem;
  animation: popin 0.55s cubic-bezier(.5,2,.3,1);
}

.duel-end {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: linear-gradient(135deg, #2b2e4a 70%, #ffd700 100%);
  border-radius: 26px; box-shadow: 0 0 60px #ffd70088;
  padding: 2.5rem 3.5rem; text-align: center; z-index: 9200; min-width: 380px;
  animation: popin 0.7s cubic-bezier(.5,2,.3,1);
}
#duelEndTitle { font-size:2.7rem; font-weight:900; margin-bottom:1.2rem;}
#duelEndStats { font-size:1.2rem; margin-bottom:1.7rem; }
@media (max-width: 600px) {
  .duel-lobby, .duel-end { min-width: 94vw; padding: 1.2rem; }
  .duel-ship { width: 64px; height:64px; }
  .duel-header { font-size:1.3rem; }
}
   
   
 @keyframes slideInLeft {0%{transform:translateX(-200px);opacity:0;}100%{transform:translateX(0);opacity:1;}}
@keyframes slideInRight {0%{transform:translateX(200px);opacity:0;}100%{transform:translateX(0);opacity:1;}}
@keyframes pulseVS {0%,100%{transform:scale(1);}50%{transform:scale(1.15);}}
   
   
/* Barra emoji compatta per mobile e tablet - per tutte le modalità */
@media (pointer: coarse), (max-width: 700px) {
  #duelEmojiBar {
    bottom: 8px !important;
    padding: 0.15em 0.4em !important; /* Ancora più compatta */
    gap: 6px !important; /* Spazio ridotto tra elementi */
    border-radius: 9px !important; /* Bordi leggermente più piccoli */
    font-size: 0.9rem !important; /* Font più piccolo */
    min-width: unset !important;
    min-height: 32px !important; /* Altezza fissa ridotta */
  }
  
  #duelEmojiBar .menu-btn {
    font-size: 0.85rem !important; /* Bottoni più piccoli */
    padding: 0.25em 0.4em !important; /* Padding ridotto */
    min-width: 26px !important; /* Larghezza minima ridotta */
    border-radius: 6px !important;
  }
  
  /* Emoji più piccole */
  #duelEmojiBar .emoji {
    font-size: 16px !important;
    padding: 0.2em 0.3em !important;
    min-width: 24px !important;
    border-radius: 5px !important;
  }
  
  #duelOpponentHealthBar {
    top: 8px !important;
    left: 8px !important;
    padding: 0.3em 0.6em !important; /* Leggermente più compatta */
    min-width: 100px !important; /* Ridotta */
    font-size: 0.85em !important; /* Font più piccolo */
    border-radius: 7px !important;
  }
  
  /* Nascondi la barra round su mobile per tutte le modalità tranne duello */
  #scoreRound {
    display: none !important;
  }
  
  /* Mostra la barra round solo in modalità duello (se il body ha classe duel) */
  body.duel-mode #scoreRound,
  body.duel1v1-mode #scoreRound,
  body[data-mode="duel1v1"] #scoreRound {
    display: block !important;
    font-size: 0.85em !important;
    padding: 0.1em 0.25em !important;
  }
  
  #scorePlayer1, #scorePlayer2 {
    font-size: 0.85em !important; /* Font ridotto */
    padding: 0.1em 0.25em !important; /* Padding ridotto */
  }
}

/* Per schermi molto piccoli (smartphone in portrait) */
@media (max-width: 480px) {
  #duelEmojiBar {
    padding: 0.1em 0.3em !important;
    gap: 4px !important;
    font-size: 0.8rem !important;
    min-height: 28px !important;
  }
  
  #duelEmojiBar .menu-btn {
    font-size: 0.75rem !important;
    padding: 0.2em 0.3em !important;
    min-width: 22px !important;
  }
  
  #duelEmojiBar .emoji {
    font-size: 14px !important;
    padding: 0.15em 0.25em !important;
    min-width: 20px !important;
  }
}
   
   
   
   </style>
</head>
<body>
  
  <div id="loadingScreen" class="loading-screen active">
  <div class="loading-content">
    <div class="spaceship-loader">
      <img src="navicella1.png" id="loaderShip" />
      <div class="flames"></div>
    </div>
    <div class="loading-text" id="loadingText">LOADING GALAXY...</div>
    <div class="loading-bar">
      <div class="loading-bar-fill" id="loadingBarFill"></div>
    </div>
  </div>
</div>
  
    <div class="particles" id="particles"></div>
  
  <div id="notificationContainer"></div>
  
  <!-- Orientation Selector -->
  <div class="orientation-selector" id="orientationSelector">
      <h2 style="color: #00bcd4; margin-bottom: 1rem; font-size: clamp(1.5rem, 5vw, 2rem);">Choose Your Battle Orientation</h2>
      <p style="margin-bottom: 1rem; font-size: clamp(1rem, 3vw, 1.2rem);">Select how you want to play:</p>
      <div class="orientation-buttons">
          <button class="orientation-btn" onclick="setOrientation('portrait')">
              📱 Portrait<br><small>Vertical Gameplay</small>
          </button>
          <button class="orientation-btn" onclick="setOrientation('landscape')">
              📺 Landscape<br><small>Horizontal Gameplay</small>
          </button>
          <button class="orientation-btn" onclick="setOrientation('auto')">
              🔄 Auto<br><small>Device Rotation</small>
          </button>
      </div>
  </div>
  
  
          <!-- Control Adjustment Overlay -->
  <div class="control-adjustment-overlay" id="controlAdjustmentOverlay">
      <h2 style="color: #ffd700; margin-bottom: 1rem; font-size: clamp(1.8rem, 6vw, 2.5rem);">Adjust Controls</h2>
      <p style="margin-bottom: 1.5rem; font-size: clamp(1rem, 3vw, 1.2rem);">Drag and drop the controls to your preferred positions.</p>
      <div class="adjustment-area" id="adjustmentArea">
          <!-- Draggable controls will be appended here by JS -->
      </div>
      <div class="adjustment-buttons">
          <button class="menu-btn primary" onclick="saveControlLayout()">✅ SAVE LAYOUT</button>
          <button class="menu-btn" onclick="cancelControlAdjustment()">❌ CANCEL</button>
      </div>
  </div>
  

 <!-- 👇 QUI puoi incollare il GO overlay, PRIMA del gameContainer -->
  <div id="duelGoOverlay" style="
    display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
    font-size:5rem;color:#ffd700;font-family:'Orbitron',sans-serif;
    text-shadow:0 0 40px #00bcd4,0 0 80px #ffd700;z-index:9500;">
    GO!
  </div>



  <div id="gameContainer">
  <!-- Main Menu Screen -->
  <div class="screen active" id="mainMenu">
    <!-- Galaxy background -->
    <div class="galaxy-bg"></div>
    <!-- Animated spaceship -->
    <div class="menu-ship-anim">
      <img src="navicella1.png" alt="Spaceship" />
    </div>
    <div class="menu-content">
      <h1 class="game-title">STELLAR GUARDIAN</h1>
      <p class="game-subtitle">COSMIC DEFENSE FORCE - Protect the Galaxy</p>
      <p style="color:#ffd700; font-size:1.1rem; margin-bottom:1.5rem; text-shadow: 0 0 8px #00bcd4;">
        🔔  For a better experience activate the <strong>fullscreen</strong>. Without it, it could lag!
      </p>
    <div id="nicknameBox" style="margin:1.2rem 0; padding:0.8rem 1rem; background:rgba(0,188,212,0.07); border-radius:12px; box-shadow:0 0 18px #00bcd455;">
  <label for="nicknameInput" style="color:#00bcd4;font-weight:bold;">Nickname:</label>
  <input id="nicknameInput" type="text" maxlength="15" style="padding:0.5rem;border-radius:8px;margin-left:0.5rem;">
  <button class="menu-btn primary" onclick="savePlayerName()">Save</button>
  <!-- ELO Display DENTRO nicknameBox -->
  <div id="eloDisplay" style="
    color:#ffd700;
    font-size:1.15rem;
    font-weight:bold;
    margin-top:10px;
    border:2px solid #ffd700;
    background:rgba(0,0,0,0.41);
    border-radius:11px;
    box-shadow:0 0 12px #ffd70055;
    padding:0.4em 1.1em;
    display:inline-block;
  ">
    <span style="margin-right:6px;">🏅</span>
    ELO: <span id="eloPoints">1000</span>
  </div>
</div>


<!-- COPYRIGHT FOOTER -->
<div style="color:#9c27b0; font-size:0.95rem; margin:12px 0 0 0; text-align:center;">
  © 2024-2025 Luka. All rights reserved.
</div>


<div class="stat-item">
    <div class="stat-value" id="coinCount">0</div>
    <div>Coins</div>
</div>
              
 <!-- Mobile Speed Control -->
                <div id="mobileSpeedControl" style="margin:2rem 0; display:none;">
                    <h3 style="color:#00bcd4; margin-bottom:0.8rem;">Mobile Ship Speed</h3>
                    <input type="range" id="mobileSpeedSlider" min="0.4" max="1.2" step="0.02" value="0.7" style="width: 220px;">
                    <span id="mobileSpeedValue" style="color:#ffd700;font-weight:bold;margin-left:10px;">0.70x</span>
                    <div style="font-size:0.95rem; margin-top:0.7em; color:#bbb;">
                        Adjust for your comfort. Default: 0.7x (slower = easier to control)
                    </div>
                </div>

<!-- PULSANTE GIOCA ORA: mettilo all'inizio di .menu-buttons -->
<button id="playNowBtn" class="menu-btn primary" style="font-size:1.4rem; padding:1.4rem 2.5rem;" onclick="startFirstMission()">
  🚀 GIOCA ORA
</button>


<audio id="musicaGioco" src="musica.mp3" loop></audio>        
                  <div class="menu-buttons">
                  <button class="menu-btn" onclick="showScreen('shop')">🛒 SHOP</button>
                  <button class="menu-btn" onclick="showScreen('levelSelect')">📋 SELECT MISSION</button>
                  <button class="menu-btn" onclick="startChaosMode()">💥 TOTAL CHAOS</button>
                  <button class="menu-btn primary" id="pulsanteMusica">🎵 Music ON</button>                  <button class="menu-btn" onclick="changePlayerName()">👤 Change nickname</button>
                  <button class="menu-btn" onclick="showScreen('inventoryScreen')">🛸 SPACESHIP INVENTORY</button>
                  <button class="menu-btn" onclick="showGlobalLeaderboard()">🌍 GLOBAL LEADERBOARD</button>
                  <button class="menu-btn primary" onclick="showCoopLobby()">🌐 Raid Co-op Online</button>
                  <button class="menu-btn" onclick="window.open('https://stellarguardian72.onrender.com','_blank')">🌐 Sito Ufficiale</button>
                  <button class="menu-btn" onclick="showDailyChallengeMenu()">🌟 DAILY CHALLENGE</button>
                  <button class="menu-btn" onclick="showLocalLeaderboard()">🌟 LOCAL LEADERBOARD</button>
                  <button class="menu-btn" onclick="showScreen('skillTree')">⭐ UPGRADES</button>
                  <button class="menu-btn" onclick="showScreen('achievements')">🏆 ACHIEVEMENTS</button>
                  <button class="menu-btn" onclick="showScreen('stats')">📊 STATISTICS</button>
                  <button class="menu-btn" onclick="showScreen('controls')">🎮 CONTROLS</button>
                  <button class="menu-btn" onclick="showOrientationSelector()">📱 ORIENTATION</button>
                  <button class="menu-btn primary" onclick="startDuelQueue()">⚔️ 1v1 DUELS</button>
                  <!-- Apri il Mobile Customization menu -->
                  <button class="menu-btn" onclick="showScreen('mobileCustomizationMenu')">📱 MOBILE SETTINGS</button>
                  <button class="menu-btn" onclick="showDuelLeaderboard()">🏅 1v1 DUEL LEADERBOARD</button>
                
                   <div style="margin-bottom:1.2em;">
  <label for="duelBotDifficultySelect" style="color:#00bcd4;font-weight:bold;margin-right:7px;">Bot Difficulty:</label>
  <select id="duelBotDifficultySelect" class="menu-btn" style="padding:0.4em 1.3em; font-size:1.1em; width:auto;">
    <option value="easy">Easy 😃</option>
    <option value="normal" selected>Normal 😈</option>
    <option value="hard">Hard 👾</option>
    <option value="insane">Insane 💀</option>
  </select>
</div>
                                      <button class="menu-btn" onclick="startDuelAIBoss()">🤖 1v1 DUEL vs BOT(beta)</button>
</div>
              
              <div class="stats-display">
                  <div class="stat-item">
                      <div class="stat-value" id="totalEnemiesDefeated">0</div>
                      <div>Enemies Defeated</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="highestLevel">1</div>
                      <div>Highest Level</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="totalScore">0</div>
                      <div>Best Score</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="skillPoints">0</div>
                      <div>Upgrade Points</div>
                
                    </div>
              </div>
          </div>
      </div>

      <!-- Skill Tree Screen -->
      <div class="screen" id="skillTree">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Ship Upgrades</h2>
              <p style="margin-bottom: 2rem; color: #00bcd4; font-size: clamp(1.1rem, 3vw, 1.4rem);">Upgrade Points Available: <span id="availableSkillPoints">0</span></p>
              
              <div class="stats-display" id="skillTreeGrid">
              </div>
          </div>
      </div>

      <!-- Achievements Screen -->
      <div class="screen" id="achievements">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Achievements</h2>
              
              <div class="stats-display" id="achievementsList">
              </div>
          </div>
      </div>

 
      <!-- SHOP SCREEN -->
<div class="screen" id="shop">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Galactic Shop</h2>
    <div class="stats-display">
      <div class="stat-item">
        <div class="stat-value">+1 Ship</div>
        <div>Cost: <span style="color:#ffd700;">20</span> Coins</div>
        <button class="menu-btn" onclick="buyShip()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Energy Refill</div>
        <div>Cost: <span style="color:#00bcd4;">10</span> Coins</div>
        <button class="menu-btn" onclick="buyEnergyRefill()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Temporary Shield</div>
        <div>Cost: <span style="color:#2196f3;">15</span> Coins</div>
        <button class="menu-btn" onclick="buyTemporaryShield()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Bullet Upgrade</div>
        <div>Cost: <span style="color:#e91e63;">30</span> Coins</div>
        <button class="menu-btn" onclick="buyBulletUpgrade()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Auto-Fire Module</div>
        <div>Cost: <span style="color:#4caf50;">25</span> Coins</div>
        <button class="menu-btn" onclick="buyAutoFire()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Special Attack Charge</div>
        <div>Cost: <span style="color:#9c27b0;">20</span> Coins</div>
        <button class="menu-btn" onclick="buySpecialAttack()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Random Power-Up</div>
        <div>Cost: <span style="color:#ffd700;">12</span> Coins</div>
        <button class="menu-btn" onclick="buyRandomPowerUp()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Unlock Ship Skin</div>
        <div>Cost: <span style="color:#00bcd4;">50</span> Coins</div>
        <button class="menu-btn" onclick="buyShipSkin()">Buy</button>
      </div>
      <!-- ... puoi aggiungere altri item shop qui ... -->
    </div>
  </div>
</div>
<!-- FINE SHOP -->

<!-- DAILY CHALLENGE SCREEN -->
<div class="screen" id="dailyChallengeScreen">
  <div class="menu-content">
    <h2>🌟 Daily Challenge</h2>
    <div id="dailyChallengeDesc" style="margin-bottom:1.5rem;"></div>
    <button class="menu-btn primary" id="dailyChallengeStartBtn">Start</button>
    <button class="menu-btn" id="dailyChallengeBackBtn">Back</button>
    <div style="margin-top:2rem;">
      <h3>Daily Leaderboard</h3>
      <div id="dailyLeaderboardList">Loading...</div>
    </div>
  </div>
</div>
<!-- FINE DAILY CHALLENGE -->

      
  <!-- Local Leaderboard Screen (spostata!) -->
<div class="screen" id="localLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Local Leaderboard</h2>
    <div id="localLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>


<div class="screen" id="globalLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Global Leaderboard</h2>
    <div id="globalLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showGlobalLeaderboard()">Update global ranking</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>


<!-- Ship Inventory Screen -->
<div class="screen" id="inventoryScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Select Your Spaceship</h2>
    <div class="level-grid" id="shipInventory"></div>
  </div>
</div>
   

<!-- Level Select Screen -->
      <div class="screen" id="levelSelect">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Select Mission</h2>
              
              <div class="level-grid" id="levelGrid">
              </div>
          </div>
      </div>

      <!-- Statistics Screen -->
      <div class="screen" id="stats">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Mission Statistics</h2>
              
              <div class="stats-display">
                  <div class="stat-item">
                      <div class="stat-value" id="statTotalEnemies">0</div>
                      <div>Total Enemies Defeated</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statHighestLevel">1</div>
                      <div>Highest Level Reached</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statBestScore">0</div>
                      <div>Highest Score</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statTotalDeaths">0</div>
                      <div>Ships Lost</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statSurvivalTime">0</div>
                      <div>Longest Survival (sec)</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statAchievements">0</div>
                      <div>Achievements Unlocked</div>
                  </div>
              </div>
              
              <div class="menu-buttons" style="margin-top: 2rem;">
                  <button class="menu-btn" onclick="resetStats()" style="background: linear-gradient(45deg, #f44336, #e91e63);">
                      🗑️ RESET DATA
                  </button>
              </div>
          </div>
      </div>

      <!-- Controls Screen -->
      <div class="screen" id="controls">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Controls</h2>
              
              <div style="text-align: left; max-width: 700px; margin: 0 auto;">
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #00bcd4; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Basic Controls</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>W A S D</strong> or <strong>Arrow Keys</strong> - Move ship</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Mouse</strong> or <strong>Touch</strong> - Aim and fire</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Space</strong> or <strong>Click</strong> - Fire weapons</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Right Click</strong> or <strong>Hold</strong> - Charged shot</p>
                  </div>
                  
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #2196f3; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Special Abilities</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>E</strong> or <strong>🛡️ Button</strong> - Energy shield</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>F</strong> or <strong>⏰ Button</strong> - Slow time</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>C</strong> or <strong>⚡ Button</strong> - Special attack</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Shift</strong> - Precision mode</p>
                  </div>
                  
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #4caf50; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Mobile Controls</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Virtual Joystick</strong> - Move ship</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Tap Screen</strong> - Aim and fire</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Action Buttons</strong> - Special abilities</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Double Tap</strong> - Emergency actions</p>
                  </div>
                  
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #ff9800; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Orientation Modes</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Portrait</strong> - Vertical gameplay, optimized for phones</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Landscape</strong> - Horizontal gameplay, optimized for tablets</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Auto</strong> - Adapts to device rotation</p>
                  </div>
              </div>
              <div class="menu-buttons" style="margin-top: 2rem;">
                  
              </div>
          </div>
      </div>

      <!-- Game Screen -->
      <div class="screen" id="gameScreen">
          <div class="speedrun-timer" id="speedrunTimer" style="display: none;">
              <div>TIME: <span id="speedrunTime">00:00</span></div>
          </div>
          
          <div class="endless-hud" id="endlessHud" style="display: none;">
              <div class="wave-counter">WAVE <span id="currentWave">1</span></div>
              <div class="difficulty-multiplier">x<span id="difficultyMultiplier">1.0</span></div>
          </div>
          
          <div class="hud">
              <div class="hud-section">
                  <div class="stat-box level">
                      <div class="stat-label">LEVEL</div>
                      <div class="stat-value" id="currentLevel">1</div>
                  </div>
                  <div class="stat-box lives">
                      <div class="stat-label">SHIPS</div>
                      <div class="stat-value" id="playerLives">1</div>
                  </div>
                  <div class="stat-box energy">
                      <div class="stat-label">ENERGY</div>
                      <div class="stat-value" id="playerEnergy">100</div>
                  </div>
              </div>
              
              <div class="health-container">
                  <div class="health-bar-wrapper">
                      <div style="font-size: clamp(0.8rem, 2.5vw, 1rem); margin-bottom: 0.3rem; font-weight: 600;">GUARDIAN</div>
                      <div class="health-bar" style="border-color: #00bcd4;">
                          <div id="playerHealthFill" class="health-fill" style="background: linear-gradient(90deg, #4caf50, #8bc34a, #cddc39); width: 100%;"></div>
                      </div>
                      <div id="playerHealthText" class="health-text">500 / 500</div>
                  </div>
                  
                  <div class="health-bar-wrapper">
                      <div style="font-size: clamp(0.8rem, 2.5vw, 1rem); margin-bottom: 0.3rem; font-weight: 600;">ENEMY</div>
                      <div class="health-bar" style="border-color: #f44336;">
                          <div id="enemyHealthFill" class="health-fill" style="background: linear-gradient(90deg, #f44336, #e91e63, #9c27b0); width: 100%;"></div>
                      </div>
                      <div id="enemyHealthText" class="health-text">1000 / 1000</div>
                  </div>
              </div>
              
              <div class="hud-section">
                  <div class="stat-box score">
                      <div class="stat-label">SCORE</div>
                      <div class="stat-value" id="playerScore">0</div>
                  </div>
                  <button class="menu-btn home-btn" onclick="forfeitMission()" style="position: relative; top: 0; left: 0; background: linear-gradient(45deg, #f44336, #e91e63); padding: clamp(0.8rem, 3vw, 1.2rem);">
                      🏠 RETREAT
                  </button>
              </div>
          </div>
          
          <div class="energy-meter" id="energyMeter">
              <div class="energy-fill" id="energyFill"></div>
          </div>
          
          <div class="difficulty-warning" id="difficultyWarning" style="display: none;">
              ⚠️ ADAPTIVE DIFFICULTY ENGAGED ⚠️
          </div>
          
          <div class="transformation-overlay" id="transformationOverlay"></div>
          
         <canvas id="gameCanvas" width="960" height="540" style="width:100vw;height:100vh;"></canvas>      

          
      
  <!-- Inserisci questo sopra il canvas o sopra la HUD, visibile solo in modalità 1v1 -->
<div id="duelScoreBar" style="
  position: absolute;
  top: 18px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9001;
  display: flex;
  gap: 44px;
  background: rgba(20,30,40,0.94);
  border-radius: 18px;
  box-shadow: 0 0 24px #00bcd4a8;
  padding: 0.9em 2.4em;
  font-family: 'Orbitron', monospace;
  font-size: 1.25em;
  font-weight: 700;
  color: #ffd700;
">
  <span id="scorePlayer1">👤 You: <b>0</b></span>
  <span id="scoreRound">Round: <b>1</b>/3</span>
  <span id="scorePlayer2">Opponent: <b>0</b></span>
</div>
         
         
         <!-- Emoji Chat QuickBar 1v1 -->
<div id="duelEmojiBar" style="position:fixed;bottom:40px;left:50%;transform:translateX(-50%);z-index:8000;display:flex;gap:18px;background:rgba(0,0,0,0.5);border-radius:16px;padding:0.5em 1.2em;">
  <button class="menu-btn" onclick="sendDuelEmote('👍')">👍</button>
  <button class="menu-btn" onclick="sendDuelEmote('😂')">😂</button>
  <button class="menu-btn" onclick="sendDuelEmote('💥')">💥</button>
  <button class="menu-btn" onclick="sendDuelEmote('GG')">GG</button>
  <button class="menu-btn" onclick="sendDuelEmote('😱')">😱</button>
  <button class="menu-btn" onclick="sendDuelEmote('😎')">😎</button>
  <button class="menu-btn" onclick="sendDuelEmote('Nice shot!')">Nice shot!</button>
</div>


        </div>

      <!-- Game Over Screen -->
<div class="screen" id="gameOver">
    <div style="text-align: center; padding: clamp(2rem, 6vw, 3rem); background: rgba(0, 0, 0, 0.95); border-radius: 25px; border: 4px solid #f44336; box-shadow: 0 0 60px rgba(244, 67, 54, 0.8); margin: 1rem; max-width: 90vw;">
        <h2 style="font-size: clamp(2.5rem, 10vw, 4.5rem); color: #f44336; margin-bottom: 2rem; text-shadow: 0 0 30px #f44336;">MISSION FAILED</h2>
        <div style="margin: 2rem 0;">
            <div style="font-size: clamp(1.3rem, 5vw, 1.8rem); margin-bottom: 1rem;">Score: <span id="finalScore" style="color: #ffd700;">0</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">Level Reached: <span id="finalLevel" style="color: #00bcd4;">1</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">Survival Time: <span id="finalTime" style="color: #4caf50;">0s</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem);">Upgrade Points Earned: <span id="earnedSkillPoints" style="color: #9c27b0;">0</span></div>
        </div>
        
        <div class="menu-buttons">
            <button class="menu-btn primary" onclick="restartGame()">🔄 RETRY MISSION</button>
            <button class="menu-btn" onclick="showScreen('skillTree')">⭐ UPGRADE SHIP</button>
            <button class="menu-btn" onclick="showScreen('levelSelect')">📋 SELECT MISSION</button>
            <button class="menu-btn" onclick="showScreen('mainMenu')">🏠 MAIN MENU</button>
        </div>

        <!-- Pulsanti Condividi Social -->
        <div id="shareButtonsGameOver" style="margin-top:1.5rem; display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="menu-btn" onclick="shareScore()">🔗 Share your record!</button>
            <button class="menu-btn" onclick="copyScoreLink()">📋 Copy link</button>
        </div>
    </div>
</div>

     <!-- Victory Screen -->
<div class="screen" id="victory">
    <div style="text-align: center; padding: clamp(2rem, 6vw, 3rem); background: rgba(0, 0, 0, 0.95); border-radius: 25px; border: 4px solid #ffd700; box-shadow: 0 0 60px rgba(255, 215, 0, 0.8); margin: 1rem; max-width: 90vw;">
        <h2 style="font-size: clamp(2.5rem, 10vw, 4.5rem); color: #ffd700; margin-bottom: 2rem; text-shadow: 0 0 30px #ffd700;">GALAXY SAVED!</h2>
        <div style="margin: 2rem 0;">
            <div style="font-size: clamp(1.8rem, 6vw, 2.5rem); margin-bottom: 1rem; color: #ffd700;">👑 STELLAR GUARDIAN SUPREME! 👑</div>
            <div style="font-size: clamp(1.3rem, 5vw, 1.8rem); margin-bottom: 1rem;">Final Score: <span id="victoryScore" style="color: #ffd700;">0</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">All 20 Levels Completed!</div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">Total Time: <span id="victoryTime" style="color: #4caf50;">0s</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem);">You are the ultimate space defender!</div>
        </div>
        
               <div class="menu-buttons">
            <button class="menu-btn primary" onclick="showScreen('levelSelect')">🚀 PLAY AGAIN</button>
            <button class="menu-btn" onclick="showScreen('achievements')">🏆 VIEW ACHIEVEMENTS</button>
            <button class="menu-btn" onclick="showScreen('stats')">📊 VIEW STATS</button>
            <button class="menu-btn" onclick="showScreen('mainMenu')">🏠 MAIN MENU</button>
        </div>

        <!-- Pulsanti Condividi Social -->
        <div id="shareButtonsVictory" style="margin-top:1.5rem; display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="menu-btn" onclick="shareScore()">🔗 Share your record!</button>
            <button class="menu-btn" onclick="copyScoreLink()">📋 Copy link</button>
        </div>
    </div>
</div>

<div class="screen" id="coopLobby">
  <div class="menu-content">
    <h2 class="game-subtitle">Raid Co-op - Wait for other players...</h2>
    <div id="coopPlayersList">Loading...</div>
    
    <div class="chat-container" id="chatContainer" style="margin-top:2rem;">
  <div id="chatMessages" style="max-height:180px;overflow-y:auto;background:#111;border-radius:10px;padding:0.7rem 1rem;font-size:1rem;color:#fff;margin-bottom:0.7rem;"></div>
  <input id="chatInput" type="text" maxlength="80" placeholder="Type a message..." style="width:70%;padding:0.3rem;border-radius:8px;">
  <button class="menu-btn" onclick="sendChatMessage()" style="padding:0.5rem 1.2rem;margin-left:0.6rem;">Send</button>
</div>
  
    
    
    <!-- Nuovo contenitore bottoni -->
    <div class="lobby-buttons">
      <button class="menu-btn" onclick="showCoopLeaderboard()">🤝 CO-OP LEADERBOARD</button>
      <button class="menu-btn primary" onclick="startCoopRaid()">Start (test host)</button>
      <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
      <button class="menu-btn" id="dailyBtn" onclick="toggleDaily()">🎤 Voice Chat (Daily.co)</button>    
</div>
  </div>
</div>

 
  
  
  <div class="screen" id="coopLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Co-op Teams Leaderboard</h2>
    <div id="coopLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showCoopLeaderboard()">Update</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>
  
  
<div class="mobile-action-btn special" id="mobileSlowTime" style="display:none;">⏰</div>  
  
  
  <!-- Contenitore iframe Daily.co nascosto di default -->
<div id="dailyContainer" style="display:none; position:fixed; bottom:80px; right:20px; width:360px; height:300px; z-index:10000; box-shadow:0 0 16px #000; border-radius:12px; background:#000;">
  <iframe id="dailyFrame"
    src=""
    allow="camera; microphone; fullscreen; display-capture"
    style="width:100%; height:100%; border:0; border-radius:10px;"></iframe>
  <button onclick="toggleDaily()" style="position:absolute;top:4px;right:4px;z-index:10001;background:#ffd700;border:none;border-radius:8px;padding:2px 8px;cursor:pointer;">❌</button>
</div>
  
  
  <!-- DUEL LOBBY MODAL -->
<div id="duelLobby" class="duel-lobby hidden">
  <div class="duel-header">⚔️ 1v1 DUELS</div>
  <div class="duel-players">
    <div class="duel-player">
      <img id="duelShip1" class="duel-ship" src="navicella1.png"/>
      <div id="duelNick1" class="duel-nick">You</div>
    </div>
    <div class="duel-vs">VS</div>
    <div class="duel-player">
      <img id="duelShip2" class="duel-ship" src="navicella2.png"/>
      <div id="duelNick2" class="duel-nick">Searching...</div>
    </div>
  </div>
  <div id="duelStatus" class="duel-status">Looking for opponent...</div>
  <button class="menu-btn" id="duelCancelBtn">Cancel</button>
</div>


<!-- PATCH: LOADING SCREEN DUEL 1v1 ANIMATA -->
<div id="duelLoadingScreen" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:100000;background:radial-gradient(ellipse at center,#222 50%,#0a0a2e 100%);align-items:center;justify-content:center;flex-direction:column;">
  <div style="display:flex;gap:80px;align-items:center;">
    <div style="text-align:center;animation:slideInLeft 0.8s;">
      <img id="duelLoadShip1" src="navicella1.png" style="width:110px;filter:drop-shadow(0 0 22px #00bcd4);" />
      <div id="duelLoadNick1" style="color:#00bcd4;font-weight:bold;font-size:1.3em;">Player1</div>
      <div id="duelLoadElo1" style="color:#ffd700;font-size:1.1em;">🥇 Gold</div>
    </div>
    <div style="font-size:3.5em;color:#fff;font-weight:bold;text-shadow:0 0 20px #ffd700;animation:pulseVS 1s infinite;">VS</div>
    <div style="text-align:center;animation:slideInRight 0.8s;">
      <img id="duelLoadShip2" src="navicella2.png" style="width:110px;filter:drop-shadow(0 0 22px #ffd700);" />
      <div id="duelLoadNick2" style="color:#ffd700;font-weight:bold;font-size:1.3em;">Player2</div>
      <div id="duelLoadElo2" style="color:#00bcd4;font-size:1.1em;">💠 Platinum</div>
    </div>
  </div>
  <div id="duelLoadingCountdown" style="font-size:2.8em;color:#ffd700;margin-top:2.5rem;">3</div>
  <div id="duelLoadingPhrase" style="color:#fff;margin-top:1.3rem;">Prepare for cosmic battle!</div>
</div>


<!-- ARENA 1v1 OVERLAY -->
<div id="duelCountdown" class="duel-countdown hidden"></div>
<div id="duelEndScreen" class="duel-end hidden">
  <div id="duelEndTitle"></div>
  <div id="duelEndStats"></div>
  <button class="menu-btn" id="duelRematchBtn">Rematch</button>
  <button class="menu-btn" id="duelLobbyBtn">Back to Lobby</button>
</div>
  
  
  <div id="fullscreenAdvicePopup" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(45deg,#00bcd4,#2196f3);color:#fff;padding:2.1rem 2.8rem;border-radius:24px;box-shadow:0 0 40px #00bcd488;z-index:100000;font-size:1.25rem;text-align:center;">
  <div style="font-size:2.1rem;margin-bottom:0.4em;">🖥️</div>
  <b>Click to enable Fullscreen<br>for the best experience!</b>
  <div style="margin-top:1.1em;">
    <button onclick="enableFullscreenFromPopup()" style="margin-top:0.5em;padding:0.7em 1.3em;border-radius:15px;background:#ffd700;color:#222;font-weight:bold;border:none;cursor:pointer;">Go Fullscreen</button>
    <button onclick="document.getElementById('fullscreenAdvicePopup').style.display='none'" style="margin-top:0.5em;padding:0.7em 1.3em;border-radius:15px;background:#444;color:#fff;font-weight:bold;border:none;cursor:pointer;margin-left:0.7em;">Close</button>
  </div>
</div>
  
  
<!-- MOBILE CUSTOMIZATION MENU -->
<div class="screen" id="mobileCustomizationMenu">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">📱 Mobile Controls & Ship Settings</h2>

    <!-- Pulsanti selezionabili -->
    <div>
      <h3 style="color:#00bcd4;">Select Action Buttons</h3>
      <button class="menu-btn" onclick="toggleMobileButton('shoot')">🔫 Shoot</button>
      <button class="menu-btn" onclick="toggleMobileButton('special')">💥 Special</button>
      <button class="menu-btn" onclick="toggleMobileButton('shield')">🛡 Shield</button>
    </div>

    <!-- Velocità navicella -->
    <div style="margin-top:1.5rem;">
      <h3 style="color:#00bcd4;">Ship Speed</h3>
      <input type="range" id="shipSpeedSlider" min="0.4" max="1.2" step="0.02" value="0.7" 
             oninput="updateShipSpeedValue(this.value)">
      <span id="shipSpeedValue" style="color:#ffd700;font-weight:bold;">0.70x</span>
    </div>

    <!-- Dimensione e colore pulsanti -->
    <div style="margin-top:1.5rem;">
      <h3 style="color:#00bcd4;">Button Size</h3>
      <input type="range" id="buttonSizeSlider" min="40" max="120" value="80" oninput="updateButtonSize(this.value)">
      <span id="buttonSizeValue" style="color:#ffd700;font-weight:bold;">80px</span>

      <h3 style="color:#00bcd4; margin-top:1rem;">Button Color</h3>
      <input type="color" id="buttonColorPicker" value="#00bcd4" onchange="updateButtonColor(this.value)">
    </div>

    <!-- Nickname sopra navicella -->
    <div style="margin-top:1.5rem;">
      <h3 style="color:#00bcd4;">Nickname Display</h3>
      <input type="text" id="nicknameAboveShip" placeholder="Your nickname">
      <input type="color" id="nicknameColorPicker" value="#ffffff" onchange="updateNicknameColor(this.value)">
    </div>

    <!-- Pulsanti Salva/Reset -->
    <div style="margin-top:1.5rem; display:flex; gap:12px; justify-content:center;">
      <button class="menu-btn primary" onclick="applyMobileSettings()">💾 APPLICA</button>
      <button class="menu-btn" onclick="resetMobileSettings()">♻️ RESET</button>
    </div>
  </div> <!-- fine .menu-content -->
</div> <!-- fine #mobileCustomizationMenu -->

<!-- CONTROLLI MOBILE (joystick + pulsanti) -->
<div class="mobile-controls" id="mobileControls">
  <div class="mobile-joystick" id="mobileJoystick">
    <div class="mobile-joystick-knob" id="mobileJoystickKnob"></div>
  </div>
  <div class="mobile-action-buttons" id="mobileActionButtons">
    <div class="mobile-action-btn" id="mobileShoot">🔫</div>
    <div class="mobile-action-btn" id="mobileShield">🛡️</div>
    <div class="mobile-action-btn" id="mobileSpecial">💥</div>
  </div>
</div>


  <div class="screen" id="duelLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">🏠 HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">1v1 Duel Leaderboard</h2>
    <div id="duelLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showDuelLeaderboard()">Update</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>
  
  
  <!-- Pulsante per spettatore + room input -->
<div style="text-align:center; margin-top:24px;">
  <input type="text" id="spectatorRoomInput" placeholder="Room ID" style="padding:5px 10px; border-radius:7px; border:1px solid #00bcd4; width:120px;">
  <button id="spectatorBtn" style="background:#00bcd4; color:#222; border:none; font-weight:bold; border-radius:7px; padding:7px 20px; margin-left:8px; font-size:1.1rem; cursor:pointer;">
    👁️ Spettatore 1v1
  </button>
</div>

<!-- Overlay spettatore (info partita live) -->
<div id="spectatorPanel"
     style="display:none; position:fixed; top:20px; right:20px; z-index:9999; background:rgba(20,30,40,0.91); color:#fff; padding:1em 1.3em; border-radius:16px; min-width:220px; box-shadow:0 0 18px #00bcd488; font-family:monospace;">
  <div style="font-weight:bold; color:#ffd700; margin-bottom:6px;">👁️ Modalità Spettatore</div>
  <div id="spectatorPlayers"></div>
  <div id="spectatorCount" style="margin-top:8px;color:#00bcd4;"></div>
  <button onclick="document.getElementById('spectatorPanel').style.display='none';" style="background:#ffd700; color:#222; border:none; border-radius:8px; padding:2px 13px; margin-top:10px; cursor:pointer;">Chiudi</button>
</div>
  
  
  
  <script>
       
      
       let firstGameAdShown = false;
      
     function showAd() {
  if (isDevEnv()) {
    console.log("DEV: showAd saltata (nessuna pubblicità in locale).");
    return;
  }
  
  if (typeof sdk !== 'undefined' && typeof sdk.showAd === 'function') {
    sdk.showAd();
    console.log('Ad GameMonetize chiamata!');
    return;
  }
  if (typeof sdk !== 'undefined' && typeof sdk.showBanner === 'function') {
    sdk.showBanner();
    console.log('Banner GameMonetize chiamato!');
    return;
  }
  console.log('No ad function available, continuing without ad!');
}
       
       
       const BOSS_IMAGES_BY_DIFFICULTY = {
  "Medium": "sabaa1.png",
  "Hard": "sabaa2.png",
  "Very Hard": "sabaa3.png",
  "Extreme": "sabaa4.png",
  "Nightmare": "sabaa5.png",
  "Impossible": "sabaa5.png",
  "LEGENDARY": "sabaa6.png" // Se vuoi riutilizzare o aggiungere un altro
};
       
       
 function getBossImageForDifficulty(difficulty) {
  if (difficulty === "Easy") {
    return "alien-enemy2.png";
  }
  return BOSS_IMAGES_BY_DIFFICULTY[difficulty] || "sabaa1.png";
}   
      


  // Event listener per i bottoni della Daily Challenge
  const dailyStartBtn = document.getElementById('dailyChallengeStartBtn');
  const dailyBackBtn = document.getElementById('dailyChallengeBackBtn');
  if (dailyStartBtn) dailyStartBtn.onclick = startDailyChallenge;
  if (dailyBackBtn) dailyBackBtn.onclick = () => showScreen('mainMenu');
;

  // Puoi chiamare showAd() dove preferisci, ad esempio:
  // function gameOver() { ... showAd(); ... }
     
      const missileSprite = new Image();
missileSprite.src = "missili.png"; // usa il nome del tuo file
      
const POWERUP_IMAGES = {
  heal: 'powerup-heal-removebg-preview.png',
  shield: 'powerup-shield-removebg-preview.png',
  damage: 'powerup-ammo-removebg-preview.png',
  special: 'powerup-energy-removebg-preview.png'
};
const POWERUP_SPRITES = {};
for (let key in POWERUP_IMAGES) {
  POWERUP_SPRITES[key] = new Image();
  POWERUP_SPRITES[key].src = POWERUP_IMAGES[key];
}



// Game State Management


           

      let gameState = {
    
    
    
    currentScreen: 'mainMenu',
    currentLevel: 1,
    gameRunning: false,
    gamePaused: false,
    gameMode: 'campaign',
    endlessWave: 1,
    speedrunStartTime: 0,
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    orientation: 'auto',
    touchControls: {
        joystick: { 
            active: false, 
            startX: 0, 
            startY: 0, 
            currentX: 0, 
            currentY: 0,
            touchId: null
        },
        shooting: false,
        lastTouchTime: 0
    },
    coins: 0, // <--- AGGIUNTO QUI
    player: {
        elo: 1000, // <--- AGGIUNGI QUESTA RIGA QUI!

      x: 0,
        y: 0,
        health: 100,
        maxHealth: 100,
        lives: 1,
        score: 0,
        energy: 100,
        maxEnergy: 100,
        skills: {},
        emergencyShields: 1,
        slowTimeEnergy: 100,
        precisionMode: false,
        invulnerabilityFrames: 0,
        angle: 0,
        // --- AGGIUNGI QUESTE DUE RIGHE QUI ---
        specialCooldown: 0,
        specialReady: false
    },
    enemy: null,
    bullets: [],
    enemyBullets: [],
    particles: [],
    powerUpItems: [],
    currentPhase: 0,
    bulletHellIntensity: 0,
    adaptiveDifficulty: 1.0,
    keys: {},
    mouse: {x: 0, y: 0},
    levelStartTime: 0,
    totalSurvivalTime: 0,
    skillPoints: 0,
    achievements: [],
    slowTimeActive: false,
    timeScale: 1,
    screenShake: 0,
    transformationActive: false,
     controlLayout: {
        joystick: { left: '20px', bottom: '30px' },
        buttons: { right: '20px', bottom: '30px' }
    },
    globalSpeed: 0.50 // <--- QUI, dentro la graffa, senza virgola!
};
window.gameState = gameState;
      
      
      let duelBot = {
  x: 1000,
  y: 90,
  health: 500,
  maxHealth: 500,
  energy: 100,
  maxEnergy: 100,
  cooldownShoot: 0,
  cooldownDodge: 0,
  target: { x: 0, y: 0 }
};
      
let botDirection = 1; // <-- QUI!


// Level Data Configuration
      const LEVEL_DATA = [
          {level: 1, enemy: "Scout Drone", difficulty: "Easy", health: 800, phases: 1, speed: 2, attackPatterns: ['basic'], bulletSpeed: 3, bulletCount: 1},
          {level: 2, enemy: "Fighter Ship", difficulty: "Easy", health: 1200, phases: 2, speed: 2.5, attackPatterns: ['basic', 'spread'], bulletSpeed: 3.5, bulletCount: 1.2},
          {level: 3, enemy: "Assault Cruiser", difficulty: "Medium", health: 1600, phases: 2, speed: 3, attackPatterns: ['basic', 'spread', 'tracking'], bulletSpeed: 4, bulletCount: 1.4},
          {level: 4, enemy: "Battle Frigate", difficulty: "Medium", health: 2200, phases: 3, speed: 3.2, attackPatterns: ['basic', 'spread', 'tracking'], bulletSpeed: 4.2, bulletCount: 1.6},
          {level: 5, enemy: "Heavy Destroyer", difficulty: "Medium", health: 2800, phases: 3, speed: 3.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave'], bulletSpeed: 4.5, bulletCount: 1.8},
          {level: 6, enemy: "Plasma Gunship", difficulty: "Hard", health: 3500, phases: 3, speed: 3.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave'], bulletSpeed: 4.8, bulletCount: 2},
          {level: 7, enemy: "Ion Battleship", difficulty: "Hard", health: 4200, phases: 4, speed: 4, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser'], bulletSpeed: 5, bulletCount: 2.2},
          {level: 8, enemy: "Quantum Dreadnought", difficulty: "Hard", health: 5000, phases: 4, speed: 4.2, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser'], bulletSpeed: 5.2, bulletCount: 2.4},
          {level: 9, enemy: "Void Carrier", difficulty: "Very Hard", health: 6000, phases: 4, speed: 4.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm'], bulletSpeed: 5.5, bulletCount: 2.6},
          {level: 10, enemy: "Dark Matter Titan", difficulty: "Very Hard", health: 7200, phases: 5, speed: 4.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm'], bulletSpeed: 5.8, bulletCount: 2.8},
          {level: 11, enemy: "Cosmic Leviathan", difficulty: "Extreme", health: 8500, phases: 5, speed: 5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral'], bulletSpeed: 6, bulletCount: 3},
          {level: 12, enemy: "Stellar Behemoth", difficulty: "Extreme", health: 10000, phases: 5, speed: 5.2, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral'], bulletSpeed: 6.2, bulletCount: 3.2},
          {level: 13, enemy: "Galactic Overlord", difficulty: "Extreme", health: 12000, phases: 6, speed: 5.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos'], bulletSpeed: 6.5, bulletCount: 3.4},
          {level: 14, enemy: "Dimension Ripper", difficulty: "Nightmare", health: 14000, phases: 6, speed: 5.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos'], bulletSpeed: 6.8, bulletCount: 3.6},
          {level: 15, enemy: "Reality Shredder", difficulty: "Nightmare", health: 16500, phases: 6, speed: 6, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 7, bulletCount: 3.8},
          {level: 16, enemy: "Cosmic Horror", difficulty: "Nightmare", health: 12000, phases: 6, speed: 5.0, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 6.0, bulletCount: 3.1},
          {level: 17, enemy: "Universal Destroyer", difficulty: "Impossible", health: 14500, phases: 6, speed: 5.3, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 6.2, bulletCount: 3.2},
          {level: 18, enemy: "Infinity Engine", difficulty: "Impossible", health: 17000, phases: 7, speed: 5.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 6.5, bulletCount: 3.3},
          {level: 19, enemy: "Omnipotent Core", difficulty: "Impossible", health: 20000, phases: 7, speed: 5.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 7.0, bulletCount: 3.5},
          {level: 20, enemy: "The Final Guardian", difficulty: "LEGENDARY", health: 25000, phases: 8, speed: 6.0, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 7.3, bulletCount: 3.8},
      ];
      
          // Upgrade Skills Configuration
      const UPGRADE_SKILLS = {
          'hull_armor': {name: 'Hull Armor', icon: '🛡️', cost: 10, description: '+50 max health, +25% damage resistance', maxLevel: 3},
          'energy_core': {name: 'Energy Core', icon: '⚡', cost: 8, description: '+25% energy regen, +20 max energy', maxLevel: 4},
          'targeting_system': {name: 'Targeting System', icon: '🎯', cost: 12, description: '+50% damage, improved accuracy', maxLevel: 3},
          'time_dilation': {name: 'Time Dilation', icon: '⏰', cost: 15, description: '50% less slow-time drain', maxLevel: 2},
          'shield_generator': {name: 'Shield Generator', icon: '🔰', cost: 25, description: '+1 emergency shield per phase', maxLevel: 2},
          'quantum_link': {name: 'Quantum Link', icon: '🌌', cost: 30, description: 'Gain energy from enemy destruction', maxLevel: 1},
          'phase_shifter': {name: 'Phase Shifter', icon: '👻', cost: 35, description: 'Immune to some enemy attacks', maxLevel: 1},
          'weapon_overdrive': {name: 'Weapon Overdrive', icon: '⚔️', cost: 40, description: '+100% damage to final phases', maxLevel: 1},
          'temporal_master': {name: 'Temporal Master', icon: '🌀', cost: 50, description: 'Auto slow-time when near death', maxLevel: 1},
          'galaxy_buster': {name: 'Galaxy Buster', icon: '💥', cost: 100, description: 'Instant kill enemies below 10% health', maxLevel: 1},
          'mobile_optimizer': {name: 'Mobile Optimizer', icon: '📱', cost: 30, description: 'Enhanced mobile controls and UI', maxLevel: 1}
      };

      // Achievements Configuration
      const GAME_ACHIEVEMENTS = {
          'first_victory': {name: 'First Victory', description: 'Complete your first mission', icon: '🎯', unlocked: false},
          'energy_master': {name: 'Energy Master', description: 'Maintain full energy for 60 seconds', icon: '⚡', unlocked: false},
          'bullet_dancer': {name: 'Bullet Dancer', description: 'Survive 500 bullets in one level', icon: '💃', unlocked: false},
          'space_ace': {name: 'Space Ace', description: 'Reach Level 10', icon: '🚀', unlocked: false},
          'galaxy_defender': {name: 'Galaxy Defender', description: 'Reach Level 15', icon: '🌌', unlocked: false},
          'cosmic_guardian': {name: 'Cosmic Guardian', description: 'Reach Level 20', icon: '👑', unlocked: false},
          'perfect_mission': {name: 'Perfect Mission', description: 'Complete a level without taking damage', icon: '✨', unlocked: false},
          'speed_runner': {name: 'Speed Runner', description: 'Complete a level in under 30 seconds', icon: '⚡', unlocked: false},
          'ultimate_guardian': {name: 'Ultimate Guardian', description: 'Complete all 20 levels', icon: '🏆', unlocked: false},
          'endless_warrior': {name: 'Endless Warrior', description: 'Survive 50 waves in endless mode', icon: '♾️', unlocked: false},
          'time_trial_master': {name: 'Time Trial Master', description: 'Complete campaign in under 10 minutes', icon: '⏱️', unlocked: false},
          'mobile_pilot': {name: 'Mobile Pilot', description: 'Complete 10 levels on mobile', icon: '📱', unlocked: false},
          'orientation_master': {name: 'Orientation Master', description: 'Play in all orientation modes', icon: '🔄', unlocked: false},
          // 'tutorial_graduate': {name: 'Tutorial Graduate', description: 'Complete the tutorial', icon: '🎓', unlocked: false} // Removed tutorial
      };

      let canvas, ctx;
      let animationId;
      
      // --- ANIMAZIONE ENTRATA NAVICELLE DUEL 1v1 ---
let duelEntryAnimation = {
  active: false,
  progress: 0,
  duration: 50 // ~0.8 sec a 60fps
};

function lerp(a, b, t) {
  return a + (b - a) * t;
}
      
      
      // -- METTI QUESTE DUE RIGHE IN ALTO, subito dopo i let/var principali --
let duelBotDifficulty = localStorage.getItem('duelBotDifficulty') || "normal";
function getDuelBotParams() {
  return {
    easy:    { speed: 2.1, fireRate: 0.017, aimError: 80 },
    normal:  { speed: 2.8, fireRate: 0.024, aimError: 35 },
    hard:    { speed: 4.0, fireRate: 0.036, aimError: 16 },
    insane:  { speed: 5.2, fireRate: 0.045, aimError: 5 }
  }[duelBotDifficulty];
}



const playerImage = new Image(); // <- AGGIUNGI QUESTA RIGA QUI!

      
      const backgroundImage = new Image();
backgroundImage.src = 'space-background.png'; // Senza /

const enemyImage = new Image();
enemyImage.src = 'alien-enemy2.png'; // Senza /

      let backgroundY = 0; // posizione verticale dello sfondo

      let bossImage = new Image();
      
      // Game Initialization
      function initGame() {
          canvas = document.getElementById('gameCanvas');
          ctx = canvas.getContext('2d');
          
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          window.addEventListener('orientationchange', handleOrientationChange);
          
          loadGameData();
          applyControlLayout(); // Apply saved control layout
          updateUI();
          generateLevelGrid();
          generateSkillTree();
          generateAchievements();
          createStellarParticles();
          setupEventListeners();
          setupMobileControls();

          // Orientation selector is no longer shown automatically
          // if (gameState.isMobile) {
          //     showOrientationSelector();
          //     showNotification('Mobile optimized! Choose your orientation.', 'info');
          // }
      }

      // Orientation Management
      function showOrientationSelector() {
          document.getElementById('orientationSelector').classList.add('active');
      }

      function setOrientation(orientation) {
          gameState.orientation = orientation;
          document.getElementById('orientationSelector').classList.remove('active');
          
          document.body.classList.remove('portrait-mode', 'landscape-mode');
          
          if (orientation === 'portrait') {
              document.body.classList.add('portrait-mode');
              screen.orientation?.lock?.('portrait').catch(() => {});
          } else if (orientation === 'landscape') {
              document.body.classList.add('landscape-mode');
              screen.orientation?.lock?.('landscape').catch(() => {});
          } else {
              screen.orientation?.unlock?.().catch(() => {});
          }
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          savedData.orientation = orientation;
          localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
          
          const orientations = savedData.orientationsUsed || [];
          if (!orientations.includes(orientation)) {
              orientations.push(orientation);
              savedData.orientationsUsed = orientations;
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              if (orientations.length >= 3) {
                  unlockAchievement('orientation_master');
              }
          }
          
          resizeCanvas();
          showNotification(`${orientation.charAt(0).toUpperCase() + orientation.slice(1)} mode activated!`, 'info');
      }

      function handleOrientationChange() {
          setTimeout(() => {
              resizeCanvas();
              if (gameState.orientation === 'auto') {
                  const isLandscape = window.innerWidth > window.innerHeight;
                  document.body.classList.remove('portrait-mode', 'landscape-mode');
                  document.body.classList.add(isLandscape ? 'landscape-mode' : 'portrait-mode');
              }
          }, 100);
      }

    function resizeCanvas() {
  const container = document.getElementById('gameContainer');
  let maxWidth, maxHeight;

  if (isMobileDevice && isMobileDevice()) {
    maxWidth = 960;   // o 1280
    maxHeight = 540;  // o 720
  } else {
    maxWidth = 1280;
    maxHeight = 720;
  }

  const aspect = maxWidth / maxHeight;
  let width = Math.min(container.offsetWidth, maxWidth);
  let height = Math.min(container.offsetHeight, maxHeight);

  if (width / height > aspect) {
    width = Math.round(height * aspect);
  } else {
    height = Math.round(width / aspect);
  }

  canvas.width = maxWidth;
  canvas.height = maxHeight;
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  canvas.style.display = "block";
  canvas.style.margin = "auto";
}

      // Enhanced Mobile Controls Setup
      function setupMobileControls() {
          if (!gameState.isMobile) return;

          const joystick = document.getElementById('mobileJoystick');
          const joystickKnob = document.getElementById('mobileJoystickKnob');
          const shootBtn = document.getElementById('mobileShoot');
          const slowTimeBtn = document.getElementById('mobileSlowTime');
          const shieldBtn = document.getElementById('mobileShield');
          const specialBtn = document.getElementById('mobileSpecial');

          // Enhanced joystick with better responsiveness
          joystick.addEventListener('touchstart', (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = joystick.getBoundingClientRect();
              const centerX = rect.left + rect.width / 2;
              const centerY = rect.top + rect.height / 2;
              
              gameState.touchControls.joystick.active = true;
              gameState.touchControls.joystick.startX = centerX;
              gameState.touchControls.joystick.startY = centerY;
              gameState.touchControls.joystick.touchId = touch.identifier;
              
              if (navigator.vibrate) {
                  navigator.vibrate(10);
              }
          }, { passive: false });

          document.addEventListener('touchmove', (e) => {
              if (!gameState.touchControls.joystick.active) return;
              
              let relevantTouch = null;
              for (let touch of e.touches) {
                  if (touch.identifier === gameState.touchControls.joystick.touchId) {
                      relevantTouch = touch;
                      break;
                  }
              }
              
              if (!relevantTouch) return;
              
              e.preventDefault();
              
              const centerX = gameState.touchControls.joystick.startX;
              const centerY = gameState.touchControls.joystick.startY;
              
              const deltaX = relevantTouch.clientX - centerX;
              const deltaY = relevantTouch.clientY - centerY;
              const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
              const maxDistance = 50;
              
              if (distance <= maxDistance) {
                  gameState.touchControls.joystick.currentX = deltaX;
                  gameState.touchControls.joystick.currentY = deltaY;
              } else {
                  const angle = Math.atan2(deltaY, deltaX);
                  gameState.touchControls.joystick.currentX = Math.cos(angle) * maxDistance;
                  gameState.touchControls.joystick.currentY = Math.sin(angle) * maxDistance;
              }

              joystickKnob.style.transform = `translate(${gameState.touchControls.joystick.currentX}px, ${gameState.touchControls.joystick.currentY}px)`;
          }, { passive: false });

          document.addEventListener('touchend', (e) => {
              let touchEnded = true;
              for (let touch of e.touches) {
                  if (touch.identifier === gameState.touchControls.joystick.touchId) {
                      touchEnded = false;
                      break;
                  }
              }
              
              if (touchEnded && gameState.touchControls.joystick.active) {
                  gameState.touchControls.joystick.active = false;
                  gameState.touchControls.joystick.currentX = 0;
                  gameState.touchControls.joystick.currentY = 0;
                  gameState.touchControls.joystick.touchId = null;
                  joystickKnob.style.transform = 'translate(0, 0)';
              }
          }, { passive: false });

          // Enhanced action buttons
          const setupActionButton = (button, action, hapticStrength = 20) => {
              button.addEventListener('touchstart', (e) => {
                  e.preventDefault();
                  action();
                  button.style.transform = 'scale(0.9)';
                  if (navigator.vibrate) {
                      navigator.vibrate(hapticStrength);
                  }
              }, { passive: false });

              button.addEventListener('touchend', (e) => {
                  e.preventDefault();
                  button.style.transform = 'scale(1)';
              }, { passive: false });
          };

          setupActionButton(shootBtn, () => {
              gameState.keys['shoot'] = true;
              setTimeout(() => { gameState.keys['shoot'] = false; }, 100);
          }, 10);

          setupActionButton(shieldBtn, useEmergencyShield, 50);
          setupActionButton(specialBtn, specialAttack, 40);

          // Enhanced canvas touch controls
          canvas.addEventListener('touchstart', (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = canvas.getBoundingClientRect();
              gameState.mouse.x = touch.clientX - rect.left;
              gameState.mouse.y = touch.clientY - rect.top;
              
              gameState.touchControls.shooting = true;
              gameState.keys['shoot'] = true;
              gameState.touchControls.lastTouchTime = Date.now();
              
              if (e.touches.length > 1) {
                  useEmergencyShield();
              }
          }, { passive: false });

          canvas.addEventListener('touchmove', (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = canvas.getBoundingClientRect();
              gameState.mouse.x = touch.clientX - rect.left;
              gameState.mouse.y = touch.clientY - rect.top;
          }, { passive: false });

          canvas.addEventListener('touchend', (e) => {
              e.preventDefault();
              gameState.touchControls.shooting = false;
              gameState.keys['shoot'] = false;
              
              const now = Date.now();
              if (now - gameState.touchControls.lastTouchTime < 300) {
                  toggleSlowTime();
              }
          }, { passive: false });

          // Prevent zoom on mobile
          document.addEventListener('gesturestart', (e) => e.preventDefault());
          document.addEventListener('gesturechange', (e) => e.preventDefault());
          document.addEventListener('gestureend', (e) => e.preventDefault());
      }

      // Event Listeners Setup
      function setupEventListeners() {
          document.addEventListener('keydown', (e) => {
              gameState.keys[e.key.toLowerCase()] = true;
              gameState.keys[e.code] = true;
              
              if (gameState.currentScreen === 'gameScreen' && gameState.gameRunning) {
                  switch(e.key.toLowerCase()) {
                      case 'escape':
                          forfeitMission();
                          break;
                      case 'r':
                          restartCurrentLevel();
                          break;
                      case 'e':
                          useEmergencyShield();
                          break;
                      case 'c':
                          specialAttack();
                          break;
                      case 'shift':
                          gameState.player.precisionMode = true;
                          break;
                  
                  
                  }
              }
          });
          
          document.addEventListener('keyup', (e) => {
              gameState.keys[e.key.toLowerCase()] = false;
              gameState.keys[e.code] = false;
              
              if (e.key.toLowerCase() === 'shift') {
                  gameState.player.precisionMode = false;
              }
          });
          
          if (!gameState.isMobile) {
              canvas.addEventListener('mousemove', (e) => {
                  const rect = canvas.getBoundingClientRect();
                  gameState.mouse.x = e.clientX - rect.left;
                  gameState.mouse.y = e.clientY - rect.top;
              });
              
              canvas.addEventListener('mousedown', (e) => {
                  if (e.button === 0) {
                      gameState.keys['shoot'] = true;
                  } else if (e.button === 2) {
                      gameState.keys['charged_shot'] = true;
                  }
              });
              
              canvas.addEventListener('mouseup', (e) => {
                  if (e.button === 0) {
                      gameState.keys['shoot'] = false;
                  } else if (e.button === 2) {
                      gameState.keys['charged_shot'] = false;
                  }
              });
              
              canvas.addEventListener('contextmenu', (e) => e.preventDefault());
          }
      }

      // Level Grid Generation
      function generateLevelGrid() {
          const levelGrid = document.getElementById('levelGrid');
          levelGrid.innerHTML = '';
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          const highestLevel = savedData.highestLevel || 1;
          
          LEVEL_DATA.forEach((levelData, index) => {
              const levelCard = document.createElement('div');
              levelCard.className = 'level-card';
              
              if (levelData.level <= highestLevel) {
                  if (savedData.completedLevels && savedData.completedLevels.includes(levelData.level)) {
                      levelCard.classList.add('completed');
                  }
                  levelCard.onclick = () => startLevel(levelData.level);
              } else {
                  levelCard.classList.add('locked');
              }
              
              const phaseText = `${levelData.phases} Phase${levelData.phases > 1 ? 's' : ''}`;
              const warningText = levelData.level >= 16 ? 'IMPOSSIBLE' : 
                                 levelData.level >= 11 ? 'EXTREME' : 
                                 levelData.level >= 6 ? 'VERY HARD' : 
                                 levelData.level >= 3 ? 'CHALLENGING' : 'MANAGEABLE';
              
              levelCard.innerHTML = `
                  <div class="level-number">${levelData.level}</div>
                  <div class="level-boss">${levelData.enemy}</div>
                  <div class="level-difficulty" style="color: ${getDifficultyColor(levelData.difficulty)}">${levelData.difficulty}</div>
                  <div class="level-phases">${phaseText}</div>
                  <div class="level-warning">${warningText}</div>
                  ${levelData.level > highestLevel ? '<div style="color: #666;">🔒 LOCKED</div>' : ''}
              `;
              
              levelGrid.appendChild(levelCard);
          });
      }

      function getDifficultyColor(difficulty) {
          const colors = {
              'Easy': '#4caf50',
              'Medium': '#ff9800',
              'Hard': '#f44336',
              'Very Hard': '#e91e63',
              'Extreme': '#9c27b0',
              'Nightmare': '#673ab7',
              'Impossible': '#3f51b5',
              'LEGENDARY': '#ffd700'
          };
          return colors[difficulty] || '#00bcd4';
      }

      // Skill Tree Generation
      function generateSkillTree() {
          const skillTreeGrid = document.getElementById('skillTreeGrid');
          skillTreeGrid.innerHTML = '';
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          const purchasedSkills = savedData.skills || {};
          
          Object.entries(UPGRADE_SKILLS).forEach(([skillId, skillData]) => {
              const skillNode = document.createElement('div');
              skillNode.className = 'stat-item';
              
              const currentLevel = purchasedSkills[skillId] || 0;
              const canPurchase = gameState.skillPoints >= skillData.cost && currentLevel < skillData.maxLevel;
              
              if (canPurchase) {
                  skillNode.style.borderColor = '#00bcd4';
                  skillNode.style.cursor = 'pointer';
                  skillNode.onclick = () => purchaseSkill(skillId);
              }
              
              if (currentLevel > 0) {
                  skillNode.style.borderColor = '#4caf50';
                  skillNode.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(0, 0, 0, 0.8))';
              }
              
              skillNode.innerHTML = `
                  <div style="font-size: clamp(2rem, 5vw, 2.5rem); margin-bottom: 0.8rem;">${skillData.icon}</div>
                  <div style="font-size: clamp(1rem, 3vw, 1.3rem); font-weight: 700; color: ${currentLevel > 0 ? '#4caf50' : '#00bcd4'}; margin-bottom: 0.5rem;">${skillData.name}</div>
                  <div style="font-size: clamp(0.9rem, 2.5vw, 1rem); margin-bottom: 0.8rem; line-height: 1.4;">${skillData.description}</div>
                  <div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: #888; margin-bottom: 0.5rem;">Level: ${currentLevel}/${skillData.maxLevel}</div>
                  <div style="font-size: clamp(0.9rem, 2.5vw, 1rem); color: #ffd700; font-weight: 600;">Cost: ${skillData.cost} UP</div>
              `;
              
              skillTreeGrid.appendChild(skillNode);
          });
      }

      function purchaseSkill(skillId) {
          const skillData = UPGRADE_SKILLS[skillId];
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          
          if (!savedData.skills) savedData.skills = {};
          if (!savedData.skillPoints) savedData.skillPoints = 0;
          
          const currentLevel = savedData.skills[skillId] || 0;
          
          if (savedData.skillPoints >= skillData.cost && currentLevel < skillData.maxLevel) {
              savedData.skillPoints -= skillData.cost;
              savedData.skills[skillId] = currentLevel + 1;
              
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              gameState.skillPoints = savedData.skillPoints;
              gameState.player.skills = savedData.skills;
              
              updateUI();
              generateSkillTree();
              applySkillEffects();
              
              showNotification(`${skillData.name} upgraded!`, 'achievement');
              
              if (navigator.vibrate) {
                  navigator.vibrate([50, 50, 50]);
              }
          }
      }

      function applySkillEffects() {
          const skills = gameState.player.skills;
          
          if (skills.hull_armor) {
              gameState.player.maxHealth = 100 + (skills.hull_armor * 50);
              if (gameState.player.health > gameState.player.maxHealth) {
                  gameState.player.health = gameState.player.maxHealth;
              }
          }
          
          if (skills.energy_core) {
              gameState.player.maxEnergy = 100 + (skills.energy_core * 20);
          }
      }

      // Achievements Generation
      function generateAchievements() {
          const achievementsList = document.getElementById('achievementsList');
          achievementsList.innerHTML = '';
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          const unlockedAchievements = savedData.achievements || [];
          
          Object.entries(GAME_ACHIEVEMENTS).forEach(([achievementId, achievementData]) => {
              const achievementItem = document.createElement('div');
              achievementItem.className = 'stat-item';
              
              const isUnlocked = unlockedAchievements.includes(achievementId);
              
              if (isUnlocked) {
                  achievementItem.style.borderColor = '#4caf50';
                  achievementItem.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(0, 0, 0, 0.8))';
              } else {
                  achievementItem.style.borderColor = '#666';
                  achievementItem.style.opacity = '0.6';
              }
              
              achievementItem.innerHTML = `
                  <div style="font-size: clamp(2rem, 5vw, 2.5rem); margin-bottom: 0.8rem;">${achievementData.icon}</div>
                  <div style="font-size: clamp(1rem, 3vw, 1.3rem); font-weight: 700; color: ${isUnlocked ? '#4caf50' : '#666'}; margin-bottom: 0.5rem;">${achievementData.name}</div>
                  <div style="font-size: clamp(0.9rem, 2.5vw, 1rem); color: ${isUnlocked ? '#ffffff' : '#888'}; line-height: 1.4; margin-bottom: 0.8rem;">${achievementData.description}</div>
                  ${isUnlocked ? '<div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: #ffd700; font-weight: 600;">✓ UNLOCKED</div>' : '<div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: #666;">🔒 LOCKED</div>'}
              `;
              
              achievementsList.appendChild(achievementItem);
          });
      }

      function unlockAchievement(achievementId) {
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          if (!savedData.achievements) savedData.achievements = [];
          
          if (!savedData.achievements.includes(achievementId)) {
              savedData.achievements.push(achievementId);
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              gameState.skillPoints += 15;
              savedData.skillPoints = (savedData.skillPoints || 0) + 15;
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              updateUI();
              generateAchievements();
              
              const achievement = GAME_ACHIEVEMENTS[achievementId];
              showNotification(`🏆 ${achievement.name} Unlocked! +15 Upgrade Points`, 'achievement');
              
              if (navigator.vibrate) {
                  navigator.vibrate([100, 50, 100, 50, 200]);
              }
          }
      }

     let pendingLevelToStart = null;

     
   function startLevel(levelNumber) {
     console.log("🔴 STARTLEVEL chiamato con livello:", levelNumber);
    console.trace(); // Mostra da dove viene chiamata
    
    
    pendingLevelToStart = levelNumber;
    gameState.gameMode = 'campaign';
    gameState.gameRunning = false;
    showAdAndStartGame();
}

     function startEndlessMode() {
    gameState.gameMode = 'endless';
    showScreen('gameScreen');

   let selectedShip = localStorage.getItem('selectedShip') || 'navicella1.png';
assets.player = new Image();
assets.player.src = selectedShip;

console.log("Navicella selezionata:", selectedShip);
console.log("Sprite caricato:", assets.player.src);


// 🔄 Avvia il gioco
initGame();

     }

      function startSpeedrun() {
          gameState.gameMode = 'speedrun';
          gameState.speedrunStartTime = Date.now();
          gameState.currentLevel = 1;
          showScreen('gameScreen');
      }

  function setBackgroundForLevel(level) {
    const levelData = LEVEL_DATA[level - 1] || LEVEL_DATA[0];
    if (levelData.difficulty === "LEGENDARY") {
        backgroundImage.src = "space-background-legendary.png";
    } else if (levelData.difficulty === "Impossible") {
        backgroundImage.src = "space-background-impossible.png"; // PATCH Impossible
    } else if (levelData.difficulty === "Nightmare") {
        backgroundImage.src = "space-background-nightmare.png";
    } else if (levelData.difficulty === "Extreme") {
        backgroundImage.src = "space-background-extreme.png";
    } else if (levelData.difficulty === "Very Hard") {
        backgroundImage.src = "space-background-veryhard.png";
    } else if (levelData.difficulty === "Hard") {
        backgroundImage.src = "space-background-hard.png";
    } else if (levelData.difficulty === "Medium") {
        backgroundImage.src = "space-background-medium.png";
    } else {
        backgroundImage.src = "space-background.png";
    }
}
      
   function startGame(skipAd) {
  resetBossVisualState();

  if (pendingLevelToStart !== null) {
          console.log("🔵 CAMBIO LIVELLO da", gameState.currentLevel, "a", pendingLevelToStart);

      gameState.currentLevel = pendingLevelToStart;
      pendingLevelToStart = null;
  }
  if (!skipAd) {
      showAdAndStartGame();
      return;
  }

    // PATCH: Segnala che stai avviando la partita (evita doppio showAd)
    gameState.pendingStart = true;
      gameState.gameRunning = true; // <--- AGGIUNGI QUESTO PRIMA

    showScreen('gameScreen');
    gameState.pendingStart = false;

    gameState.obstacles = [];
    gameState.gameRunning = true;
    gameState.gamePaused = false;
    setBackgroundForLevel(gameState.currentLevel);
    gameState.levelStartTime = Date.now();
    gameState.slowTimeActive = false;
    gameState.timeScale = 0.3;
    gameState.currentPhase = 0;
    gameState.bulletHellIntensity = 0;
    gameState.adaptiveDifficulty = 1.0;
    gameState.screenShake = 0;
    gameState.transformationActive = false;

    // --- NAVICELLA SELEZIONATA: sprite e statistiche ---
    const selectedShip = localStorage.getItem("selectedShip") || "ship1";
    let playerStats = {};

    if (selectedShip === "ship1") {
    playerImage.src = "navicella1.png";
    playerStats = { speed: 5, maxHealth: 100, maxEnergy: 100 };
} else if (selectedShip === "ship2") {
    playerImage.src = "navicella2.png";
    playerStats = { speed: 3, maxHealth: 180, maxEnergy: 120 };
} else if (selectedShip === "ship3") {
    playerImage.src = "navicella3.png";
    playerStats = { speed: 7, maxHealth: 80, maxEnergy: 140 };
} else if (selectedShip === "ship4") {
    playerImage.src = "navicella4.png";
    playerStats = { speed: 6, maxHealth: 110, maxEnergy: 120 };
} else if (selectedShip === "summer") {
    playerImage.src = "navicella-summer.png";
    playerStats = { speed: 6.5, maxHealth: 105, maxEnergy: 125 }; // scegli i bonus che vuoi!
} else {
    playerImage.src = "navicella1.png";
    playerStats = { speed: 5, maxHealth: 100, maxEnergy: 100 };
}

    // Applica le statistiche al player
    gameState.player.speed = playerStats.speed;
    gameState.player.maxHealth = playerStats.maxHealth;
    gameState.player.health = playerStats.maxHealth;
    gameState.player.maxEnergy = playerStats.maxEnergy;
    gameState.player.energy = playerStats.maxEnergy;

    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    const skills = savedData.skills || {};

    // Aggiungi bonus delle skill eventualmente già sbloccate
    if (skills.hull_armor) {
        gameState.player.maxHealth += skills.hull_armor * 50;
        gameState.player.health = gameState.player.maxHealth;
    }
    if (skills.energy_core) {
        gameState.player.maxEnergy += skills.energy_core * 20;
        gameState.player.energy = gameState.player.maxEnergy;
    }
    gameState.player.emergencyShields = 1 + (skills.shield_generator || 0);
    gameState.player.slowTimeEnergy = 100;
    gameState.player.skills = skills;
    gameState.player.invulnerabilityFrames = 0;
    gameState.player.angle = 0;
    gameState.player.x = canvas.width / 2;
    gameState.player.y = canvas.height - 120;

    if (gameState.gameMode === 'endless') {
        generateEndlessEnemy();
    } else {
        initializeCampaignEnemy();
    }

    gameState.bullets = [];
    gameState.enemyBullets = [];
    gameState.particles = [];
    gameState.powerUpItems = [];

    updateUI();
    gameLoop();
}
     function initializeCampaignEnemy() {
      if (gameState.gameMode === "duel1v1") return;


      const levelData = LEVEL_DATA[gameState.currentLevel - 1];

    // Carica l'immagine del boss in base alla difficoltà (devi avere let bossImage = new Image(); globale)
    bossImage = new Image();
    bossImage.src = getBossImageForDifficulty(levelData.difficulty);

    gameState.enemy = {
        x: canvas.width / 2,
        y: 100,
        health: levelData.health * gameState.adaptiveDifficulty,
        maxHealth: levelData.health * gameState.adaptiveDifficulty,
        speed: levelData.speed,
        attackPatterns: levelData.attackPatterns,
        phases: levelData.phases,
        currentPhase: 1,
        attackCooldown: 0,
        moveDirection: 1,
        specialCooldown: 0,
        phaseTransition: false,
        enraged: false,
        bulletCount: levelData.bulletCount || 1,
        bulletSpeed: levelData.bulletSpeed || 4,
        attackSpeed: 1,
        angle: 0
    };
}
      function generateEndlessEnemy() {
            if (gameState.gameMode === "duel1v1") return;

        const randomLevel = Math.floor(Math.random() * LEVEL_DATA.length);
          const baseEnemy = LEVEL_DATA[randomLevel];
          
          gameState.enemy = {
              x: canvas.width / 2,
              y: 100,
              health: baseEnemy.health * gameState.adaptiveDifficulty,
              maxHealth: baseEnemy.health * gameState.adaptiveDifficulty,
              speed: baseEnemy.speed * (1 + gameState.adaptiveDifficulty * 0.1),
              attackPatterns: [...baseEnemy.attackPatterns],
              phases: Math.min(baseEnemy.phases + Math.floor(gameState.endlessWave / 10), 10),
              currentPhase: 1,
              attackCooldown: 0,
              moveDirection: 1,
              specialCooldown: 0,
              phaseTransition: false,
              enraged: false,
              bulletCount: (baseEnemy.bulletCount || 1) * (1 + gameState.endlessWave * 0.1),
              bulletSpeed: (baseEnemy.bulletSpeed || 4) * (1 + gameState.endlessWave * 0.05),
              attackSpeed: 1 + (gameState.endlessWave * 0.05),
              angle: 0
          };
      }

     // Sostituisci TUTTA la funzione gameLoop con questa:
let lastUpdateTime = performance.now();

function gameLoop() {
  if (!gameState.gameRunning || gameState.gamePaused) return;
  let now = performance.now();
  let rawDelta = (now - lastUpdateTime) / 16.67; // 16.67ms = 60fps
  lastUpdateTime = now;
  // Limita deltaTime per evitare scatti (tab inattiva, lag, ecc.)
  let deltaTime = (rawDelta > 2.5 || rawDelta < 0.2) ? 1 : rawDelta;
  deltaTime = Math.max(0.7, Math.min(deltaTime, 1.5));

  update(deltaTime); // <-- Passa deltaTime!
  
  // ---- QUI METTI LA TUA RIGA! ----
  if (gameState.gameMode === "duel1v1") {
    checkPowerupPickup();
  }
  
  
  render();

  // --- Gestione fine partita e challenge giornaliera ---
  let partitaFinita = false;
  if (gameState.player.health <= 0 && gameState.player.invulnerabilityFrames <= 0) partitaFinita = true;
  if (gameState.enemy && gameState.enemy.health <= 0) partitaFinita = true;

  if (gameState.isDailyChallenge && partitaFinita) {
    endDailyChallenge(gameState.player.score);
    gameState.isDailyChallenge = false;
    showScreen('mainMenu');
    return;
  }

  animationId = requestAnimationFrame(gameLoop);
}
     // Sostituisci la funzione update con questa:
function update(deltaTime) {
  deltaTime *= gameState.timeScale;
  deltaTime *= gameState.globalSpeed;

  updatePlayer(deltaTime);

  // SOLO in duelAI aggiorna il bot, i proiettili e la UI
  if (gameState.gameMode === "duelAI") {
    updateDuelBot();
    updatePlayerTrail();
    updateBullets(deltaTime);
    updateEnemyBullets(deltaTime);
    updateParticles(deltaTime);
    
      checkDuelAICollisions(); // <--- AGGIUNGI QUESTA RIGA QUI

    
    
    if (gameState.player.specialCooldown > 0) gameState.player.specialCooldown--;
    updateUI();
    // Eventualmente aggiungi qui gestione fine partita vs bot
    if (gameState.player.health <= 0) gameOver();
    if (duelBot.health <= 0) levelComplete();
    return; // NON aggiornare nulla della campagna!
  }

  // --- Tutto il resto SOLO se NON sei in duelAI ---
  updatePlayerTrail();
  updateObstacles(deltaTime);
  updateEnemy(deltaTime);
  updateBullets(deltaTime);
  updateEnemyBullets(deltaTime);
  updateParticles(deltaTime);
  updateSlowTime();
  updateAdaptiveDifficulty();
  updateScreenShake();
  checkCollisions();

  if (gameState.player.specialCooldown > 0) gameState.player.specialCooldown--;

  if (gameState.gameMode === 'chaos') updateChaosMode(deltaTime);
  else if (gameState.gameMode === 'endless') updateEndlessMode();
  else if (gameState.gameMode === 'speedrun') updateSpeedrunTimer();

  checkEnemyPhaseTransition();

  if (gameState.enemy && gameState.enemy.health <= 0) {
    esplodiBoss(gameState.enemy);
    levelComplete();
  } else if (gameState.player.health <= 0 && gameState.player.invulnerabilityFrames <= 0) {
    gameOver();
  }
}

  function updatePlayer(deltaTime) {
    const player = gameState.player;
    const skills = gameState.player.skills;
    let speed = player.precisionMode ? 2 : 4; // valori più bassi!

    if (gameState.gameMode === "duelAI") {
  speed = 16; // o un valore ancora più alto
}
    
    
    // <<< INCOLLA QUI >>>
    document.getElementById('coinCount').textContent = "Speed " + (window.gameState.mobileShipSpeed || localStorage.getItem('mobileShipSpeed'));

    if (skills.targeting_system && player.precisionMode) speed *= 0.7;

    speed *= 3;

    // PATCH: velocità globale super bassa per tutti
    speed *= 2.5; // Cambia 0.18 con quanto lento vuoi (0.1 = lentissimo, 1 = normale)

    // Il resto come prima
    speed *= deltaTime;
    speed *= gameState.globalSpeed; // puoi anche forzarlo a 1 se vuoi

if (isMobileDevice && isMobileDevice()) {
  // Applica runtime la velocità aggiornata senza reload
  let custom = (window.gameState && window.gameState.mobileShipSpeed !== undefined)
    ? window.gameState.mobileShipSpeed
    : Number(localStorage.getItem('mobileShipSpeed')) || 0.7;
       console.log("Valore custom di velocità (mobileShipSpeed) in updatePlayer:", custom);

    speed *= custom;
}

speed *= deltaTime;
speed *= gameState.globalSpeed;

    // Mobile joystick movement
    if (gameState.isMobile && gameState.touchControls.joystick.active) {
        const joystickStrength = 0.18;
        const moveX = gameState.touchControls.joystick.currentX * joystickStrength;
        const moveY = gameState.touchControls.joystick.currentY * joystickStrength;

        player.x += moveX;
        player.y += moveY;

        if (moveX !== 0 || moveY !== 0) {
            player.angle = Math.atan2(moveY, moveX) + Math.PI / 2;
        }
    }

    // Keyboard movement (CAOS PATCH)
    let invert = gameState.chaosInverted ? -1 : 1;
    if (gameState.keys['w'] || gameState.keys['ArrowUp']) {
        player.y -= speed * invert;
        player.angle = 0;
    }
    if (gameState.keys['s'] || gameState.keys['ArrowDown']) {
        player.y += speed * invert;
        player.angle = Math.PI;
    }
    if (gameState.keys['a'] || gameState.keys['ArrowLeft']) {
        player.x -= speed * invert;
        player.angle = -Math.PI / 2;
    }
    if (gameState.keys['d'] || gameState.keys['ArrowRight']) {
        player.x += speed * invert;
        player.angle = Math.PI / 2;
    }

    // CAOS PATCH: Gravità pazza!
    if (gameState.chaosGravity) player.y += 6;

    // Diagonal movement adjustment
    if ((gameState.keys['w'] || gameState.keys['ArrowUp']) && (gameState.keys['a'] || gameState.keys['ArrowLeft'])) {
        player.angle = -Math.PI / 4;
    } else if ((gameState.keys['w'] || gameState.keys['ArrowUp']) && (gameState.keys['d'] || gameState.keys['ArrowRight'])) {
        player.angle = Math.PI / 4;
    } else if ((gameState.keys['s'] || gameState.keys['ArrowDown']) && (gameState.keys['a'] || gameState.keys['ArrowLeft'])) {
        player.angle = -3 * Math.PI / 4;
    } else if ((gameState.keys['s'] || gameState.keys['ArrowDown']) && (gameState.keys['d'] || gameState.keys['ArrowRight'])) {
        player.angle = 3 * Math.PI / 4;
    }

    // Keep player in bounds
    player.x = Math.max(50, Math.min(canvas.width - 50, player.x));
    player.y = Math.max(50, Math.min(canvas.height - 50, player.y));

    // Shooting
    if ((gameState.keys['shoot'] || gameState.keys[' '] || gameState.keys['Space'] || gameState.touchControls.shooting) && player.energy > 0) {
        if (Math.random() < 0.25) {
            shoot();
            player.energy = Math.max(0, player.energy - 1);
        }
    }

    if (gameState.keys['charged_shot'] && player.energy >= 10) {
        chargedShot();
        player.energy -= 10;
        gameState.keys['charged_shot'] = false;
    }

    // Energy regeneration
    if (player.energy < player.maxEnergy) {
        const regenRate = skills.energy_core ? 1.2 : 0.8;
        player.energy = Math.min(player.maxEnergy, player.energy + regenRate);
    }

    if (player.invulnerabilityFrames > 0) {
        player.invulnerabilityFrames--;
    }

    updateUI();
}
      function updateEnemy(deltaTime) {
              if (gameState.gameMode === "duel1v1") return; // Non aggiornare boss in 1v1!

            if (gameState.gameMode === "coop") return; // In co-op, posizione boss solo da server!

const enemy = gameState.enemy;
          if (!enemy) return;
          
          const levelData = LEVEL_DATA[gameState.currentLevel - 1] || LEVEL_DATA[0];
          
          // Enemy movement
          if (enemy.currentPhase >= 3) {
              enemy.x += enemy.moveDirection * enemy.speed * deltaTime * (1 + Math.sin(Date.now() * 0.01) * 0.5);
              enemy.angle += 0.02;
              if (Math.random() < 0.02) {
                  enemy.moveDirection *= -1;
              }
          } else {
              enemy.x += enemy.moveDirection * enemy.speed * deltaTime;
              enemy.angle += 0.01;
          }
          
          if (enemy.x <= 100 || enemy.x >= canvas.width - 100) {
              enemy.moveDirection *= -1;
          }
          
          // Enemy attacks
          if (enemy.attackCooldown <= 0) {
              const pattern = enemy.attackPatterns[Math.floor(Math.random() * enemy.attackPatterns.length)];
              executeAttackPattern(pattern);
              
              let baseSpeed = 60;
              if (gameState.currentLevel <= 5) {
                  baseSpeed = 90;
              } else if (gameState.currentLevel <= 10) {
                  baseSpeed = 70;
              } else if (gameState.currentLevel <= 15) {
                  baseSpeed = 50;
              } else {
                  baseSpeed = 35;
              }
              
              enemy.attackCooldown = baseSpeed / (enemy.attackSpeed * gameState.adaptiveDifficulty);
          } else {
              enemy.attackCooldown -= deltaTime;
          }
      }
      
      // --- PATCH: funzione mancante per parametri proiettili mobile ---
function getMobileBulletParams(count, speed) {
  // Se sei su mobile, riduci il numero di proiettili e la loro velocità per evitare lag
  if (isMobileDevice && typeof isMobileDevice === "function" && isMobileDevice()) {
    return {
      count: Math.max(1, Math.round(count * 0.6)),
      speed: speed * 1.2
    };
  }
  // Su desktop, torna tutto normale
  return { count, speed };
}
      
      function executeAttackPattern(pattern) {
  const enemy = gameState.enemy;
  const levelData = LEVEL_DATA[gameState.currentLevel - 1] || LEVEL_DATA[0];
  const mobileParams = getMobileBulletParams(enemy.bulletCount, levelData.bulletSpeed || 4);

  // Limita drasticamente i proiettili nei pattern pesanti!
  const bulletCount = Math.min(mobileParams.count, 8); // MAX 8
  const bulletSpeed = mobileParams.speed;

  switch (pattern) {
    case 'basic':
      for (let i = 0; i < Math.min(3 * bulletCount, 16); i++) {
        gameState.enemyBullets.push({
          x: enemy.x + (i - 1) * 30,
          y: enemy.y + 50,
          vx: (i - 1) * 0.5,
          vy: bulletSpeed,
          color: '#f44336',
          size: 8,
          damage: 15
        });
      }
      break;

    case 'spread':
      const spreadCount = Math.min(Math.floor(5 * bulletCount), 18);
      for (let i = 0; i < spreadCount; i++) {
        const angle = (i / spreadCount) * Math.PI - Math.PI / 2;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * bulletSpeed,
          vy: Math.sin(angle) * bulletSpeed + 2,
          color: '#e91e63',
          size: 6,
          damage: 12
        });
      }
      break;

    case 'tracking': {
  const dx = gameState.player.x - enemy.x;
  const dy = gameState.player.y - enemy.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  for (let i = 0; i < 1; i++) { // SOLO 1 proiettile!
    gameState.enemyBullets.push({
      x: enemy.x,
      y: enemy.y + 50,
      vx: (dx / dist) * bulletSpeed,
      vy: (dy / dist) * bulletSpeed,
      color: '#ff9800',
      size: 10,
      damage: 18,
      tracking: true,
      trackingStrength: 0.004 // lentissimo!
    });
  }
  break;
}

    case 'laser':
      for (let i = 0; i < Math.min(15, 12); i++) {
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50 + i * 12,
          vx: 0,
          vy: bulletSpeed * 1.5,
          color: '#ff9800',
          size: 12,
          damage: 20
        });
      }
      break;

    case 'wave':
      for (let i = 0; i < Math.min(8 * bulletCount, 16); i++) {
        const angle = (i / 8) * Math.PI * 2;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * 2,
          vy: Math.sin(angle) * 2 + bulletSpeed,
          color: '#673ab7',
          size: 8,
          damage: 15,
          wave: true,
          waveOffset: i * 0.5
        });
      }
      break;

    case 'swarm':
      for (let i = 0; i < Math.min(12 * bulletCount, 24); i++) {
        gameState.enemyBullets.push({
          x: enemy.x + (Math.random() - 0.5) * 100,
          y: enemy.y + 30,
          vx: (Math.random() - 0.5) * 4,
          vy: bulletSpeed * 0.8,
          color: '#3f51b5',
          size: 6,
          damage: 10
        });
      }
      break;

    case 'spiral':
      const spiralCount = Math.min(Math.floor(10 * bulletCount), 18);
      for (let i = 0; i < spiralCount; i++) {
        const angle = (i / spiralCount) * Math.PI * 4 + (Date.now() * 0.01);
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * 3,
          vy: Math.sin(angle) * 3 + bulletSpeed,
          color: '#2196f3',
          size: 7,
          damage: 14
        });
      }
      break;

    case 'chaos':
      for (let i = 0; i < Math.min(15 * bulletCount, 20); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed + 1,
          color: '#00bcd4',
          size: Math.random() * 8 + 4,
          damage: 16
        });
      }
      break;

    case 'ultimate':
      for (let i = 0; i < Math.min(20 * bulletCount, 20); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 3;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: '#ffd700',
          size: 15,
          damage: 25,
          ultimate: true
        });
      }
      break;
  }

  gameState.bulletHellIntensity = Math.min(100, gameState.bulletHellIntensity + 2);
}


      function shoot() {
  // COOP: invia evento al server, non aggiungere subito il proiettile locale!
  if (gameState.gameMode === "coop" && socket) {
    let player = gameState.player;
    let skills = player.skills || {};
    let damage = 25;
    if (skills.targeting_system && player.precisionMode) damage *= 1.5;

    let targetX = gameState.mouse.x;
    let targetY = gameState.mouse.y;
    if (gameState.isMobile && gameState.enemy) {
      targetX = gameState.enemy.x;
      targetY = gameState.enemy.y;
    }
    const dx = targetX - player.x;
    const dy = targetY - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 15;
    const vx = dist > 0 ? (dx / dist) * speed : 0;
    const vy = dist > 0 ? (dy / dist) * speed : -speed;

    socket.emit('shoot', {
      x: player.x,
      y: player.y - 20,
      vx, vy,
      color: '#00bcd4',
      size: gameState.chaosBullets === "big" ? 28 : 6,
      damage,
      owner: mySocketId // identifica chi ha sparato
    });

    createMuzzleFlash(player.x, player.y - 20);
    return; // NON aggiungere il proiettile localmente!
  }

  // SINGLE PLAYER: come prima
  let player = gameState.player;
  let skills = player.skills || {};
  let damage = 25;
  if (skills.targeting_system && player.precisionMode) damage *= 1.5;

  let targetX = gameState.mouse.x;
  let targetY = gameState.mouse.y;
  if (gameState.isMobile && gameState.enemy) {
    targetX = gameState.enemy.x;
    targetY = gameState.enemy.y;
  }
  const dx = targetX - player.x;
  const dy = targetY - player.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const speed = 15;
  const vx = dist > 0 ? (dx / dist) * speed : 0;
  const vy = dist > 0 ? (dy / dist) * speed : -speed;

  gameState.bullets.push({
    x: player.x,
    y: player.y - 20,
    vx, vy,
    color: '#00bcd4',
    size: gameState.chaosBullets === "big" ? 28 : 6,
    damage,
    owner: mySocketId
  });

  createMuzzleFlash(player.x, player.y - 20);
}
      function chargedShot() {
    const player = gameState.player;
    const skills = gameState.player.skills;
    let damage = 80;

    if (skills.targeting_system) {
        damage *= 2;
    }

    // PATCH: CO-OP multiplayer: invia al server come un normale proiettile!
    if (gameState.gameMode === "coop" && socket) {
        socket.emit('shoot', {
            x: player.x,
            y: player.y - 20,
            vx: 0,
            vy: -18,
            color: '#ffd700',
            size: 15,
            damage: damage,
            charged: true,
            owner: mySocketId
        });
        createMuzzleFlash(player.x, player.y - 20, true);
        return; // NON aggiungere localmente!
    }

    // SINGLEPLAYER / OFFLINE: aggiungi localmente
    gameState.bullets.push({
        x: player.x,
        y: player.y - 20,
        vx: 0,
        vy: -18,
        color: '#ffd700',
        size: 15,
        damage: damage,
        charged: true
    });

    createMuzzleFlash(player.x, player.y - 20, true);
}
      function createMuzzleFlash(x, y, charged = false) {
          const particleCount = charged ? 15 : 8;
          const color = charged ? '#ffd700' : '#00bcd4';
          
          for (let i = 0; i < particleCount; i++) {
              gameState.particles.push({
                  x: x,
                  y: y,
                  vx: (Math.random() - 0.5) * 8,
                  vy: (Math.random() - 0.5) * 8 - 5,
                  color: color,
                  size: Math.random() * 4 + 2,
                  life: 20,
                  maxLife: 20,
                  alpha: 1
              });
          }
      }

      function toggleSlowTime() {
    // Slow time DISABLED
}
document.getElementById('mobileSlowTime').style.display = "none";

      function updateSlowTime() {
          const player = gameState.player;
          const skills = gameState.player.skills;
          
          if (gameState.slowTimeActive) {
              const drainRate = skills.time_dilation ? 1 : 1.5;
              player.slowTimeEnergy -= drainRate;
              
              if (player.slowTimeEnergy <= 0) {
                  gameState.slowTimeActive = false;
                  gameState.timeScale = 1;
                  player.slowTimeEnergy = 0;
              }
          } else if (player.slowTimeEnergy < 100) {
              player.slowTimeEnergy += 0.5;
          }
          
          if (skills.temporal_master && player.health < player.maxHealth * 0.2 && !gameState.slowTimeActive) {
              gameState.timeScale = 0.5;
          } else if (!gameState.slowTimeActive) {
              gameState.timeScale = 1;
          }
      }

      function updateAdaptiveDifficulty() {
          const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
          
          if (survivalTime > 120) {
              gameState.adaptiveDifficulty = Math.min(2.0, gameState.adaptiveDifficulty + 0.003);
              
              if (gameState.adaptiveDifficulty > 1.5) {
                  showDifficultyWarning();
              }
          }
          
          if (gameState.enemy) {
              gameState.enemy.bulletCount = 1 + (gameState.adaptiveDifficulty - 1) * 0.2;
              gameState.enemy.attackSpeed = gameState.adaptiveDifficulty;
          }
      }

      function showDifficultyWarning() {
          const warning = document.getElementById('difficultyWarning');
          warning.style.display = 'block';
          
          setTimeout(() => {
              warning.style.display = 'none';
          }, 2000);
      }

      function updateScreenShake() {
          if (gameState.screenShake > 0) {
              gameState.screenShake *= 0.9;
              if (gameState.screenShake < 0.1) {
                  gameState.screenShake = 0;
              }
          }
      }

      function checkEnemyPhaseTransition() {
          const enemy = gameState.enemy;
          if (!enemy) return;
          
          const healthPercent = enemy.health / enemy.maxHealth;
          const phaseThreshold = (enemy.phases - enemy.currentPhase) / enemy.phases;
          
          if (healthPercent <= phaseThreshold && enemy.currentPhase < enemy.phases) {
              triggerPhaseTransition(enemy.currentPhase + 1);
          }
      }

      function triggerPhaseTransition(newPhase) {
          gameState.enemy.currentPhase = newPhase;
          gameState.enemy.phaseTransition = true;
          gameState.transformationActive = true;
          
          document.getElementById('transformationOverlay').classList.add('active');
          gameState.screenShake = 6;
          
          gameState.enemy.speed *= 1.1;
          gameState.enemy.bulletCount *= 1.15;
          
          createTransformationEffect();
          
          setTimeout(() => {
              gameState.enemy.phaseTransition = false;
              gameState.transformationActive = false;
              document.getElementById('transformationOverlay').classList.remove('active');
          }, 2000);
      }

      function createTransformationEffect() {
          for (let i = 0; i < 40; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = Math.random() * 12 + 5;
              gameState.particles.push({
                  x: gameState.enemy.x,
                  y: gameState.enemy.y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  color: '#00bcd4',
                  size: Math.random() * 10 + 6,
                  life: 80,
                  maxLife: 80,
                  alpha: 1
              });
          }
      }

      function useEmergencyShield() {
          if (gameState.player.emergencyShields > 0) {
              gameState.player.emergencyShields--;
              gameState.player.invulnerabilityFrames = 180;
              
              gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                  const dist = Math.sqrt(
                      Math.pow(bullet.x - gameState.player.x, 2) + 
                      Math.pow(bullet.y - gameState.player.y, 2)
                  );
                  return dist > 150;
              });
              
              createShieldEffect();
              updateUI();
          }
      }

      function createShieldEffect() {
          for (let i = 0; i < 40; i++) {
              const angle = (i / 40) * Math.PI * 2;
              gameState.particles.push({
                  x: gameState.player.x,
                  y: gameState.player.y,
                  vx: Math.cos(angle) * 10,
                  vy: Math.sin(angle) * 10,
                  color: '#00bcd4',
                  size: 8,
                  life: 80,
                  maxLife: 80,
                  alpha: 1
              });
          }
      }

      function specialAttack() {
    // Se hai una carica speciale dallo shop, usala subito!
    if (gameState.player.specialReady) {
        gameState.player.specialReady = false;
        eseguiSpecial();
        return;
    }

    // Cooldown attivo? Blocca e mostra notifica
    if (gameState.player.specialCooldown > 0) {
        showNotification("⚡ Special not ready!", "info");
        return;
    }

    // Solo se vita < 40%
    if (gameState.player.health < gameState.player.maxHealth * 0.4) {
        eseguiSpecial();
        gameState.player.specialCooldown = 600; // 10 secondi a 60fps
    } else {
        showNotification("⚡ Special available only when low HP!", "info");
    }
}

// Funzione helper: esegue davvero l'attacco speciale
function eseguiSpecial() {
    const damage = 120;
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        gameState.bullets.push({
            x: gameState.player.x,
            y: gameState.player.y - 20,
            vx: Math.cos(angle) * 8,
            vy: Math.sin(angle) * 8 - 4,
            color: '#ffd700',
            size: 12,
            damage: damage,
            special: true
        });
    }
    gameState.player.health = Math.max(1, gameState.player.health - 15);
    showNotification("⚡ Special attack launched!", "info");
    updateUI();
}
      function updateEndlessMode() {
          if (gameState.gameMode !== 'endless') return;
          
          document.getElementById('endlessHud').style.display = 'block';
          document.getElementById('currentWave').textContent = gameState.endlessWave;
          document.getElementById('difficultyMultiplier').textContent = gameState.adaptiveDifficulty.toFixed(1);
          
          if (gameState.enemy && gameState.enemy.health <= 0) {
              gameState.endlessWave++;
              gameState.adaptiveDifficulty += 0.1;
              
              generateEndlessEnemy();
              
              if (gameState.endlessWave >= 50) {
                  unlockAchievement('endless_warrior');
              }
          }
      }

      function updateSpeedrunTimer() {
          if (gameState.gameMode !== 'speedrun') return;
          
          document.getElementById('speedrunTimer').style.display = 'block';
          const elapsed = (Date.now() - gameState.speedrunStartTime) / 1000;
          const minutes = Math.floor(elapsed / 60);
          const seconds = Math.floor(elapsed % 60);
          document.getElementById('speedrunTime').textContent = 
              `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          
          if (gameState.currentLevel >= 20 && elapsed < 600) {
              unlockAchievement('time_trial_master');
          }
      }

      function updateBullets(deltaTime) {
          gameState.bullets = gameState.bullets.filter(bullet => {
              bullet.x += bullet.vx * deltaTime;
              bullet.y += bullet.vy * deltaTime;
              
              return bullet.y > -50 && bullet.y < canvas.height + 50 &&
                     bullet.x > -50 && bullet.x < canvas.width + 50;
          });
      }

      function updateEnemyBullets(deltaTime) {
    const MAX_ENEMY_BULLETS = 45;
    gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
        bullet.x += bullet.vx * deltaTime;
        bullet.y += bullet.vy * deltaTime;

        // PATCH: tracking lentissimo e rarissimo!
        if (bullet.tracking && Math.random() < 0.01) {
            const dx = gameState.player.x - bullet.x;
            const dy = gameState.player.y - bullet.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const ts = bullet.trackingStrength || 0.004;
            bullet.vx += (dx / dist) * ts;
            bullet.vy += (dy / dist) * ts;
            // Clamp velocità massima
            const maxSpeed = 4;
            const vNorm = Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
            if (vNorm > maxSpeed) {
                bullet.vx = (bullet.vx / vNorm) * maxSpeed;
                bullet.vy = (bullet.vy / vNorm) * maxSpeed;
            }
        }

        if (bullet.wave) {
            bullet.x += Math.sin(Date.now() * 0.01 + bullet.waveOffset) * 1.5;
        }

        return bullet.y > -50 && bullet.y < canvas.height + 50 &&
               bullet.x > -50 && bullet.x < canvas.width + 50;
    });

    if (gameState.enemyBullets.length > MAX_ENEMY_BULLETS) {
        gameState.enemyBullets = gameState.enemyBullets.slice(-MAX_ENEMY_BULLETS);
    }
}

      function updateParticles(deltaTime) {
          gameState.particles = gameState.particles.filter(particle => {
              particle.x += particle.vx * deltaTime;
              particle.y += particle.vy * deltaTime;
              particle.life -= deltaTime;
              particle.alpha = particle.life / particle.maxLife;
              
              return particle.life > 0;
          });
      }

      function checkCollisions() {
    // Player bullets hitting enemy
    gameState.bullets.forEach((bullet, bulletIndex) => {
        const enemy = gameState.enemy;
        if (!enemy) return;
        
        const dist = Math.sqrt(
            Math.pow(bullet.x - enemy.x, 2) + 
            Math.pow(bullet.y - enemy.y, 2)
        );
        
        if (dist < 60) {
            let damage = bullet.damage;
            
            if (gameState.player.skills.galaxy_buster && enemy.health < enemy.maxHealth * 0.1) {
                damage = enemy.health;
            }
            
            if (gameState.player.skills.weapon_overdrive && enemy.currentPhase >= enemy.phases - 1) {
                damage *= 2;
            }
            
            gameState.player.score += Math.floor(damage);
            enemy.health -= damage;
            gameState.bullets.splice(bulletIndex, 1);
            
            createHitParticles(bullet.x, bullet.y, bullet.color);
            updateUI();
        }
    });

    // Player bullets hitting mines (distruggibili)
    gameState.bullets.forEach((bullet, bulletIndex) => {
        gameState.obstacles.forEach((ob, obIndex) => {
            if (ob.hit) return;
            if (ob.type !== "mine") return; // Solo mine sono distruttibili
            const dx = ob.x - bullet.x;
            const dy = ob.y - bullet.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const hitbox = ob.size / 2 + bullet.size;
            if (dist < hitbox) {
                ob.hit = true; // elimina la mina
                spawnSuperExplosion(ob.x, ob.y, {colors:["#ffe700","#ff9800","#fff"],count:18});
                startShake(10, 6);
                gameState.bullets.splice(bulletIndex, 1); // elimina proiettile
            }
        });
    });

    // Enemy bullets hitting player
    gameState.enemyBullets.forEach((bullet, bulletIndex) => {
        const player = gameState.player;
        
        if (player.invulnerabilityFrames > 0) return;
        
        let hitboxSize = player.precisionMode ? 15 : 25;
        if (player.skills.targeting_system && player.precisionMode) {
            hitboxSize = 10;
        }
        
        if (player.skills.mobile_optimizer && gameState.isMobile) {
            hitboxSize *= 0.9;
        }
        
        const dist = Math.sqrt(
            Math.pow(bullet.x - player.x, 2) + 
            Math.pow(bullet.y - player.y, 2)
        );
        
        if (dist < hitboxSize) {
            let damage = bullet.damage || 15;
            
            if (gameState.currentLevel <= 5) {
                damage *= 0.8;
            } else if (gameState.currentLevel <= 10) {
                damage *= 0.9;
            }
            
            if (gameState.player.skills.hull_armor) {
                damage *= (1 - gameState.player.skills.hull_armor * 0.2);
            }
            
            player.health -= damage;
            gameState.enemyBullets.splice(bulletIndex, 1);
            player.invulnerabilityFrames = 60;
            
            gameState.screenShake = 4;
            
            createHitParticles(bullet.x, bullet.y, '#f44336');
            updateUI();
            
            if (navigator.vibrate && gameState.isMobile) {
                navigator.vibrate(100);
            }
        }
    });

    if (gameState.enemyBullets.length >= 500) {
        unlockAchievement('bullet_dancer');
    }
    checkObstacleCollisions();
}
      
      function createHitParticles(x, y, color) {
          for (let i = 0; i < 12; i++) {
              gameState.particles.push({
                  x: x,
                  y: y,
                  vx: (Math.random() - 0.5) * 12,
                  vy: (Math.random() - 0.5) * 12,
                  color: color,
                  size: Math.random() * 6 + 3,
                  life: 50,
                  maxLife: 50,
                  alpha: 1
              });
          }
      }

   function levelComplete() {
    // PATCH: Previeni avanzamenti multipli
    if (window.levelAdvancing) return;
    window.levelAdvancing = true;

    showAd(); // Mostra pubblicità alla vittoria

    // Se hai completato la campagna (livello 20)
    if (gameState.gameMode === 'campaign' && gameState.currentLevel >= 20) {
        unlockAchievement('ultimate_guardian');
        document.getElementById('victoryScore').textContent = gameState.player.score.toLocaleString();
        document.getElementById('victoryTime').textContent = Math.floor(gameState.totalSurvivalTime);
        showScreen('victory');
        updateUI();
        window.levelAdvancing = false; // Sblocca flag
        return;
    }

    gameState.gameRunning = false;

    // Calcola tempo di sopravvivenza
    const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
    gameState.totalSurvivalTime += survivalTime;

    // Calcola upgrade points
    let upgradePointsEarned = Math.floor(gameState.currentLevel * 1.2) + 5;
    if (gameState.gameMode === 'endless') {
        upgradePointsEarned = Math.floor(gameState.endlessWave * 0.5);
    } else if (gameState.gameMode === 'speedrun') {
        upgradePointsEarned = Math.floor(survivalTime < 30 ? 50 : 25);
    }
    gameState.skillPoints += upgradePointsEarned;

    // Calcola coins
    let coinsEarned = Math.floor(Math.random() * 8) + 3;
    gameState.coins += coinsEarned;

    // Aggiorna salvataggio
    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    savedData.totalEnemiesDefeated = (savedData.totalEnemiesDefeated || 0) + 1;

    // Aggiorna dati specifici modalità
    if (gameState.gameMode === 'campaign') {
        savedData.highestLevel = Math.max(savedData.highestLevel || 1, gameState.currentLevel + 1);
    } else if (gameState.gameMode === 'endless') {
        savedData.endlessBestWave = Math.max(savedData.endlessBestWave || 0, gameState.endlessWave);
        savedData.endlessBestScore = Math.max(savedData.endlessBestScore || 0, gameState.player.score);
    } else if (gameState.gameMode === 'speedrun') {
        const currentTime = gameState.totalSurvivalTime;
        if (!savedData.speedrunBestTime || currentTime < savedData.speedrunBestTime) {
            savedData.speedrunBestTime = currentTime;
        }
    }

    // Aggiorna bestScore sempre!
    savedData.bestScore = Math.max(savedData.bestScore || 0, gameState.player.score);

    // Aggiorna altri dati
    savedData.skillPoints = (savedData.skillPoints || 0) + upgradePointsEarned;
    savedData.longestSurvival = Math.max(savedData.longestSurvival || 0, survivalTime);
    savedData.coins = gameState.coins;

    // Segna livello completato
    if (!savedData.completedLevels) {
        savedData.completedLevels = [];
    }
    if (gameState.gameMode === 'campaign' && !savedData.completedLevels.includes(gameState.currentLevel)) {
        savedData.completedLevels.push(gameState.currentLevel);
    }

    localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));

    // Notifica, leaderboard LOCAL + GLOBALE
    showNotification(`+${coinsEarned} Coins!`, 'info');
    let username = getPlayerName();
    submitLocalScore(username, gameState.player.score, gameState.currentLevel);
    submitGlobalScore(username, gameState.player.score);

    // Gestione avanzamento livello/modalità
    if (gameState.gameMode === 'campaign') {
        if (window.levelTimeout) clearTimeout(window.levelTimeout);
        window.levelTimeout = setTimeout(() => {
            pendingLevelToStart = gameState.currentLevel + 1;
            gameState.gameRunning = false;
            startGame(true); // skipAd:true per evitare loop pubblicità
            window.levelAdvancing = false; // Sblocca flag dopo avanzamento!
        }, 2000);
    } else if (gameState.gameMode === 'endless') {
        if (window.levelTimeout) clearTimeout(window.levelTimeout);
        window.levelTimeout = setTimeout(() => {
            startGame();
            window.levelAdvancing = false;
        }, 1500);
    } else {
        showScreen('mainMenu');
        window.levelAdvancing = false;
    }

    updateUI();
}

     function submitGlobalScore(username, score) {
  const url = `https://dreamlo.com/lb/5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw/add/${encodeURIComponent(username)}/${score}`;
  fetch(url)
    .then(() => console.log("Score inviato a Dreamlo!"))
    .catch(err => console.error("Dreamlo errore:", err));
}
      
  function gameOver() {
     showAd();
    
    gameState.gameRunning = false;
    const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
    let upgradePointsEarned = Math.floor(gameState.currentLevel * 0.6) + Math.floor(survivalTime / 20);

    if (gameState.gameMode === 'endless') {
        upgradePointsEarned = Math.floor(gameState.endlessWave * 0.4);
    }

    gameState.skillPoints += upgradePointsEarned;

    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    savedData.totalDeaths = (savedData.totalDeaths || 0) + 1;
    savedData.skillPoints = (savedData.skillPoints || 0) + upgradePointsEarned;
    savedData.longestSurvival = Math.max(savedData.longestSurvival || 0, survivalTime);

    // PATCH: aggiorna bestScore sempre!
    savedData.bestScore = Math.max(savedData.bestScore || 0, gameState.player.score);

    if (gameState.gameMode === 'endless') {
        savedData.endlessBestWave = Math.max(savedData.endlessBestWave || 0, gameState.endlessWave);
        savedData.endlessBestScore = Math.max(savedData.endlessBestScore || 0, gameState.player.score);
    }

    localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));

    document.getElementById('finalScore').textContent = gameState.player.score.toLocaleString();
    document.getElementById('finalLevel').textContent = gameState.gameMode === 'endless' ? 
        `Wave ${gameState.endlessWave}` : gameState.currentLevel;
    document.getElementById('finalTime').textContent = Math.floor(survivalTime);
    document.getElementById('earnedSkillPoints').textContent = upgradePointsEarned;

    let username = getPlayerName();
    submitLocalScore(username, gameState.player.score, gameState.currentLevel);
    submitGlobalScore(username, gameState.player.score);

    // --- PUBBLICITÀ GameMonetize ---
    if (typeof sdk !== 'undefined' && typeof sdk.showBanner === 'function') {
        sdk.showBanner();
    }

    showScreen('gameOver');
    updateUI();
}

  function fetchGlobalLeaderboard(callback) {
  const url = "https://dreamlo.com/lb/5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw/pipe";
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [name, score] = row.split('|');
          if (!name || isNaN(parseInt(score))) return null;
          return { name, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score);
      callback(leaderboard);
    });
}
     
   // --- Quando forfeit, ferma tutto ---
function forfeitMission() {
  gameState.gameRunning = false;
  if (animationId) {
    stopCoopGameLoop();
    cancelAnimationFrame(animationId);
  }
  showScreen('mainMenu');
}

     function restartGame() {
        resetBossVisualState(); // <--- AGGIUNGI QUI!!!

        gameState.gameRunning = false;
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
    showScreen('gameScreen');
}

      function restartCurrentLevel() {
          restartGame();
      }

      function pauseGame() {
          gameState.gamePaused = true;
      }

      function resumeGame() {
          gameState.gamePaused = false;
          gameLoop();
      }

    function render() {
  backgroundY += 1;
  if (backgroundY >= canvas.height) backgroundY = 0;

  ctx.fillStyle = '#0a0a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (gameState.screenShake > 0) {
    ctx.save();
    ctx.translate(
      (Math.random() - 0.5) * gameState.screenShake,
      (Math.random() - 0.5) * gameState.screenShake
    );
  }

  renderSpaceBackground();

  // SOLO in duelAI: player, bot, bullets, particles
  if (gameState.gameMode === "duelAI") {
    renderPlayer();
    renderDuelBot(ctx);
    renderBullets();
    renderEnemyBullets();
    renderParticles();
    if (gameState.slowTimeActive) renderSlowTimeOverlay();
    if (gameState.screenShake > 0) ctx.restore();
    return; // NON disegnare altro!
  }

  // --- Tutto il resto SOLO se NON sei in duelAI ---
  renderPlayer();
  if (gameState.gameMode === "duel1v1") renderOpponent(ctx);
  else if (gameState.gameMode === "coop") renderOtherPlayers(ctx), renderEnemy();
  else renderEnemy();

  renderObstacles();
  renderBullets();
  renderEnemyBullets();
  renderParticles();

  if (gameState.slowTimeActive) renderSlowTimeOverlay();

  if (gameState.screenShake > 0) ctx.restore();
}
      function renderSpaceBackground() {
          if (backgroundImage.complete) {
              ctx.drawImage(backgroundImage, 0, backgroundY, canvas.width, canvas.height);
              ctx.drawImage(backgroundImage, 0, backgroundY - canvas.height, canvas.width, canvas.height);

              backgroundY += 1;
              if (backgroundY >= canvas.height) backgroundY = 0;
          } else {
              // Fallback: animated stars if image not loaded
              ctx.fillStyle = '#FFF';
              for (let i = 0; i < 100; i++) {
                  const x = (i * 10 + backgroundY * 0.5) % canvas.width;
                  const y = (i * 15 + backgroundY * 0.8) % canvas.height;
                  ctx.fillRect(x, y, 2, 2);
              }
          }
      }

      function renderPlayer() {
  const player = gameState.player;
  let x = player.x, y = player.y;
  if (duelEntryAnimation.active) {
    x = lerp(-100, player.x, duelEntryAnimation.progress);
  }
  renderPlayerTrail(ctx);
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(player.angle);
  if (playerImage.complete) {
    ctx.drawImage(playerImage, -32, -32, 64, 64); 
  } else {
    ctx.fillStyle = '#00bcd4';
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(-15, 15);
    ctx.lineTo(15, 15);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

     
 // --- RENDER ALTRI PLAYER ---
function renderOtherPlayers(ctx) {
  console.log("Rendering otherPlayers:", otherPlayers);
    
  for (let id in otherPlayers) {
    if (id === mySocketId) continue;
    const p = otherPlayers[id];
    // Interpolazione verso la posizione target
    if (typeof p.targetX === "number" && typeof p.targetY === "number") {
      p.x += (p.targetX - p.x) * 0.33;
      p.y += (p.targetY - p.y) * 0.33;
    }
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.drawImage(playerImage, p.x - 32, p.y - 32, 64, 64);
    ctx.font = "bold 18px Orbitron";
    ctx.fillStyle = "#ffd700";
    ctx.textAlign = "center";
    ctx.fillText(p.nickname, p.x, p.y - 40);
    ctx.restore();
  }
}

     
     
  
      function renderBullets() {
    gameState.bullets.forEach(bullet => {
        ctx.save();
        ctx.translate(bullet.x, bullet.y);
        ctx.rotate(Math.atan2(bullet.vy, bullet.vx));

        // Scegli quale missile mostrare in base al tipo
        let sx = 0; // default: primo missile
        let sy = 0;
        let sw = 192; // larghezza missile (adatta se necessario)
        let sh = 384; // altezza missile (adatta se necessario)
        // Se vuoi cambiare missile in base al tipo, esempio:
        // if (bullet.type === "blu") sx = 192;
        // if (bullet.type === "doppio") sx = 384;
        // if (bullet.type === "verde") sx = 576;

        // Disegna il missile (scalato più piccolo se vuoi)
        ctx.drawImage(missileSprite, sx, sy, sw, sh, -16, -32, 32, 64);

        ctx.restore();
    });
}
      function renderEnemyBullets() {
          gameState.enemyBullets.forEach(bullet => {
              ctx.save();
              
              ctx.fillStyle = bullet.color;
              ctx.beginPath();
              ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
              ctx.fill();
              
              if (bullet.size > 10) {
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                  ctx.stroke();
                  
                  ctx.globalAlpha = 0.4;
                  ctx.fillStyle = bullet.color;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size + Math.sin(Date.now() * 0.03) * 4, 0, Math.PI * 2);
                  ctx.fill();
              }
              
              if (bullet.tracking) {
                  ctx.strokeStyle = '#f44336';
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size + 6, 0, Math.PI * 2);
                  ctx.stroke();
              }
              
              if (bullet.ultimate) {
                  ctx.shadowColor = bullet.color;
                  ctx.shadowBlur = 20;
                  
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 4;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size + 5, 0, Math.PI * 2);
                  ctx.stroke();
              }
              
              ctx.restore();
          });
      }

      function renderParticles() {
          gameState.particles.forEach(particle => {
              ctx.save();
              ctx.globalAlpha = particle.alpha;
              ctx.fillStyle = particle.color;
              ctx.shadowColor = particle.color;
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
          });
      }

      function renderSlowTimeOverlay() {
          ctx.save();
          ctx.globalAlpha = 0.15;
          ctx.fillStyle = '#00bcd4';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#00bcd4';
          ctx.font = `bold ${Math.min(28, canvas.width * 0.035)}px Orbitron`;
          ctx.textAlign = 'center';
          ctx.fillText('TIME DILATION ACTIVE', canvas.width / 2, 60);
          
          ctx.restore();
      }

         
function updateUI() {
    document.getElementById('currentLevel').textContent = gameState.gameMode === 'endless'
        ? `W${gameState.endlessWave}`
        : gameState.currentLevel;
    document.getElementById('playerLives').textContent = gameState.player.lives;
    document.getElementById('playerEnergy').textContent = Math.floor(gameState.player.energy);
    document.getElementById('playerScore').textContent = gameState.player.score.toLocaleString();
    document.getElementById('coinCount').textContent = gameState.coins;
    
     // PATCH: aggiorna ELO
    document.getElementById('eloPoints').textContent = gameState.elo || 1000;
    
    // Dentro updateUI
const league = getEloLeague(gameState.elo || 1000);
const eloDisplay = document.getElementById('eloDisplay');
eloDisplay.style.borderColor = league.color;
eloDisplay.style.boxShadow = `0 0 12px ${league.color}55`;
eloDisplay.innerHTML =
  `<span style="margin-right:6px;">${league.icon}</span>
   ELO: <span id="eloPoints">${gameState.elo || 1000}</span>
   <span style="font-size:1.05em; font-weight:bold; color:${league.color}; margin-left:10px;">${league.name}</span>`;
    
    
    const playerHealthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
    document.getElementById('playerHealthFill').style.width = Math.max(0, playerHealthPercent) + '%';
    document.getElementById('playerHealthText').textContent =
        `${Math.max(0, Math.floor(gameState.player.health))} / ${gameState.player.maxHealth}`;

    // PATCH: Nascondi SOLO la barra ENEMY in duel1v1, mostra altrove
    const healthBarWrappers = document.querySelectorAll('.health-bar-wrapper');
    healthBarWrappers.forEach(wrapper => {
        // Cerca il div che contiene "ENEMY" come label
        const isEnemyBar = Array.from(wrapper.children).some(child =>
            child.textContent && child.textContent.trim().toUpperCase() === "ENEMY"
        );
        if (isEnemyBar) {
            if (gameState.gameMode === "duel1v1") {
                wrapper.style.display = "none";
            } else {
                wrapper.style.display = "";
            }
        }
    });

    // Gestione barra ENEMY: aggiorna valori solo se visibile
    const enemyHealthFill = document.getElementById('enemyHealthFill');
    const enemyHealthText = document.getElementById('enemyHealthText');
    if (gameState.gameMode === "duel1v1") {
        if (enemyHealthFill) enemyHealthFill.style.width = '0%';
        if (enemyHealthText) enemyHealthText.textContent = '-';
    } else if (
        gameState.enemy &&
        typeof gameState.enemy.health === "number" &&
        typeof gameState.enemy.maxHealth === "number" &&
        !isNaN(gameState.enemy.health) && !isNaN(gameState.enemy.maxHealth)
    ) {
        const enemyHealthPercent = (gameState.enemy.health / gameState.enemy.maxHealth) * 100;
        if (enemyHealthFill) enemyHealthFill.style.width = Math.max(0, enemyHealthPercent) + '%';
        if (enemyHealthText) enemyHealthText.textContent =
            `${Math.max(0, Math.floor(gameState.enemy.health))} / ${gameState.enemy.maxHealth}`;
    } else {
        if (enemyHealthFill) enemyHealthFill.style.width = '0%';
        if (enemyHealthText) enemyHealthText.textContent = '-';
    }

    document.getElementById('energyFill').style.width = gameState.bulletHellIntensity + '%';

    // Mostra bestScore correttamente
    document.getElementById('totalScore').textContent = (gameState.bestScore || 0).toLocaleString();

    // Mostra anche altri dati delle statistiche se vuoi
    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    document.getElementById('totalEnemiesDefeated').textContent = savedData.totalEnemiesDefeated || 0;
    document.getElementById('highestLevel').textContent = savedData.highestLevel || 1;
    document.getElementById('skillPoints').textContent = savedData.skillPoints || 0;
    document.getElementById('availableSkillPoints').textContent = savedData.skillPoints || 0;
    document.getElementById('statTotalEnemies').textContent = savedData.totalEnemiesDefeated || 0;
    document.getElementById('statHighestLevel').textContent = savedData.highestLevel || 1;
    document.getElementById('statBestScore').textContent = (savedData.bestScore || 0).toLocaleString();
    document.getElementById('statTotalDeaths').textContent = savedData.totalDeaths || 0;
    document.getElementById('statSurvivalTime').textContent = Math.floor(savedData.longestSurvival || 0);
    document.getElementById('statAchievements').textContent = (savedData.achievements || []).length;

    gameState.skillPoints = savedData.skillPoints || 0;
}

 // Data Management
      function saveGameData() {
  const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
  savedData.controlLayout = gameState.controlLayout; // Save control layout
  savedData.elo = gameState.elo; // <-- AGGIUNGI QUESTA RIGA!
  localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
}

    function loadGameData() {
  const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
  gameState.skillPoints = savedData.skillPoints || 0;
  gameState.player.skills = savedData.skills || {};
  gameState.orientation = savedData.orientation || 'auto';
  gameState.coins = Number(savedData.coins) || 0;
  gameState.bestScore = Number(savedData.bestScore) || 0;
  gameState.elo = savedData.elo || 1000; // <-- AGGIUNGI QUI!
}

   function spawnObstacle() {
    if (!gameState.obstacles) gameState.obstacles = [];
    const types = ["asteroid"];
    const type = types[Math.floor(Math.random() * types.length)];
    const x = Math.random() * canvas.width;
    const size = 32 + Math.random() * 32;

    // PATCH: velocità più bassa su mobile
    let vy = 2 + Math.random() * 2;
    if (isMobileDevice()) vy *= 0.55; // circa metà velocità su mobile

    gameState.obstacles.push({
        x: x,
        y: -size,
        vx: (Math.random() - 0.5) * 1.5,
        vy: vy, // usa la velocità modificata!
        size: size,
        type: type,
        angle: 0,
        spin: (Math.random() - 0.5) * 0.07,
        hit: false
    });
}
    
    function updateObstacles(deltaTime) {
      if (!gameState.obstacles) gameState.obstacles = [];

  if (gameState.gameMode === "coop") return; // <-- AGGIUNGI QUESTA RIGA!

if (isMobileDevice && isMobileDevice()) {
  // Su mobile: asteroidi molto meno frequenti!
  if (Math.random() < 0.014) spawnObstacle();
} else {
  // Desktop: come prima
  if (Math.random() < 0.035) spawnObstacle();
}
  
gameState.obstacles = gameState.obstacles.filter(o => {
    o.x += o.vx * (deltaTime || 1);
    o.y += o.vy * (deltaTime || 1);
    o.angle += o.spin;
    return o.y < canvas.height + 60 && o.x > -80 && o.x < canvas.width + 80 && !o.hit;
  });
}
      
      function resetStats() {
    // RESET DIRETTO senza conferma
    localStorage.removeItem('stellarGuardianSave');
    gameState.currentLevel = 1;
    gameState.skillPoints = 0;
    gameState.player.skills = {};
    gameState.orientation = 'auto';
    gameState.controlLayout = { // Reset control layout to default
        joystick: { left: '20px', bottom: '30px' },
        buttons: { right: '20px', bottom: '30px' }
    };
    applyControlLayout();
    updateUI();
    generateLevelGrid();
    generateSkillTree();
    generateAchievements();
    showNotification('All data reset! Starting fresh.', 'achievement');
}

      // Notification System
      function showNotification(message, type = 'info') {
          const notification = document.createElement('div');
          notification.className = 'notification';
          notification.textContent = message;
          
          if (type === 'achievement') {
              notification.style.background = 'linear-gradient(45deg, #ffd700, #ffeb3b)';
              notification.style.color = '#000';
              notification.style.fontWeight = '700';
          }
          
          document.getElementById('notificationContainer').appendChild(notification);
          
          setTimeout(() => {
              notification.remove();
          }, 5000);
      }

      // Particle System
      function createStellarParticles() {
          const particlesContainer = document.getElementById('particles');
          
          for (let i = 0; i < 30; i++) {
              const particle = document.createElement('div');
              particle.className = 'particle';
              particle.style.left = Math.random() * 100 + '%';
              particle.style.animationDelay = Math.random() * 4 + 's';
              particle.style.animationDuration = (Math.random() * 3 + 4) + 's';
              
              const colors = ['#00bcd4', '#2196f3', '#3f51b5', '#9c27b0', '#ffffff'];
              particle.style.background = colors[Math.floor(Math.random() * colors.length)];
              
              particlesContainer.appendChild(particle);
          }
      }

      // Control Adjustment Feature
      let draggedElement = null;
      let offsetX, offsetY;

      function showControlAdjustment() {
          showScreen('controlAdjustmentOverlay');
          const adjustmentArea = document.getElementById('adjustmentArea');
          adjustmentArea.innerHTML = ''; // Clear previous elements

          const joystick = document.getElementById('mobileJoystick').cloneNode(true);
          joystick.id = 'draggableJoystick';
          joystick.classList.add('draggable-control');
          joystick.style.position = 'absolute'; // Ensure absolute positioning for dragging
          joystick.style.left = gameState.controlLayout.joystick.left;
          joystick.style.bottom = gameState.controlLayout.joystick.bottom;
          joystick.style.top = 'auto'; // Clear top if set
          joystick.style.right = 'auto'; // Clear right if set
          joystick.style.pointerEvents = 'auto'; // Enable pointer events for dragging
          joystick.querySelector('#mobileJoystickKnob').style.transform = 'translate(0,0)'; // Reset knob position

          const actionButtons = document.getElementById('mobileActionButtons').cloneNode(true);
          actionButtons.id = 'draggableActionButtons';
          actionButtons.classList.add('draggable-control');
          actionButtons.style.position = 'absolute'; // Ensure absolute positioning for dragging
          actionButtons.style.right = gameState.controlLayout.buttons.right;
          actionButtons.style.bottom = gameState.controlLayout.buttons.bottom;
          actionButtons.style.top = 'auto'; // Clear top if set
          actionButtons.style.left = 'auto'; // Clear left if set
          actionButtons.style.pointerEvents = 'auto'; // Enable pointer events for dragging

          adjustmentArea.appendChild(joystick);
          adjustmentArea.appendChild(actionButtons);

          setupDrag(joystick);
          setupDrag(actionButtons);
      }

     function setupDrag(element) {
    element.addEventListener('pointerdown', (e) => {
        draggedElement = element;
        draggedElement.classList.add('dragging');
        const rect = draggedElement.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        draggedElement.setPointerCapture(e.pointerId);
        // Attiva pointer events solo durante il drag
        draggedElement.style.pointerEvents = "auto";
    });

    element.addEventListener('pointermove', (e) => {
        if (draggedElement === element) {
            e.preventDefault();
            const adjustmentArea = document.getElementById('adjustmentArea');
            const areaRect = adjustmentArea.getBoundingClientRect();

            let newLeft = e.clientX - offsetX - areaRect.left;
            let newTop = e.clientY - offsetY - areaRect.top;

            newLeft = Math.max(0, Math.min(newLeft, areaRect.width - draggedElement.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, areaRect.height - draggedElement.offsetHeight));

            draggedElement.style.left = `${newLeft}px`;
            draggedElement.style.top = `${newTop}px`;
            draggedElement.style.right = 'auto';
            draggedElement.style.bottom = 'auto';
        }
    });

    element.addEventListener('pointerup', (e) => {
        endDrag(e);
    });
}

// Listener globale: chiudi il drag anche se lasci fuori dal controllo (mobile fix)
window.addEventListener('pointerup', function(e) {
    if (draggedElement) {
        endDrag(e);
    }
});

    function endDrag(e) {
    if (draggedElement) {
        draggedElement.classList.remove('dragging');
        try {
            if (e && e.pointerId !== undefined) draggedElement.releasePointerCapture(e.pointerId);
        } catch (err) {}
        // Dopo il drag, pointer-events none così i bottoni sotto sono cliccabili!
        draggedElement.style.pointerEvents = "none";
        draggedElement = null;
    }
}  
      
      function saveControlLayout() {
          const joystick = document.getElementById('draggableJoystick');
          const buttons = document.getElementById('draggableActionButtons');
          const adjustmentArea = document.getElementById('adjustmentArea');
          const areaRect = adjustmentArea.getBoundingClientRect();

          // Calculate positions relative to the bottom/left/right of the adjustment area
          const joystickRect = joystick.getBoundingClientRect();
          const buttonsRect = buttons.getBoundingClientRect();

          gameState.controlLayout.joystick.left = `${(joystickRect.left - areaRect.left)}px`;
          gameState.controlLayout.joystick.bottom = `${(areaRect.height - (joystickRect.top - areaRect.top) - joystickRect.height)}px`;

          gameState.controlLayout.buttons.right = `${(areaRect.width - (buttonsRect.left - areaRect.left) - buttonsRect.width)}px`;
          gameState.controlLayout.buttons.bottom = `${(areaRect.height - (buttonsRect.top - areaRect.top) - buttonsRect.height)}px`;

          saveGameData();
          applyControlLayout(); // Apply the new layout to the actual game controls
          showScreen('controls'); // Go back to controls screen
          showNotification('Control layout saved!', 'info');
      }

      function cancelControlAdjustment() {
          showScreen('controls'); // Just go back to controls screen without saving
      }

      function applyControlLayout() {
          const joystick = document.getElementById('mobileJoystick');
          const buttons = document.getElementById('mobileActionButtons');

          if (joystick && gameState.controlLayout.joystick) {
              joystick.style.left = gameState.controlLayout.joystick.left;
              joystick.style.bottom = gameState.controlLayout.joystick.bottom;
              joystick.style.top = 'auto';
              joystick.style.right = 'auto';
          }
          if (buttons && gameState.controlLayout.buttons) {
              buttons.style.right = gameState.controlLayout.buttons.right;
              buttons.style.bottom = gameState.controlLayout.buttons.bottom;
              buttons.style.top = 'auto';
              buttons.style.left = 'auto';
          }
      }
      function buyShip() {
    const price = 20;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.lives += 1;
        const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
        savedData.coins = gameState.coins;
        localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
        updateUI();
        showNotification('Purchased +1 Ship!', 'info');
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

      
      const musicaGioco = document.getElementById("musicaGioco");
const pulsanteMusica = document.getElementById("pulsanteMusica");

let musicaAttiva = false;

// Funzione per attivare o disattivare la musica
function toggleMusica() {
    if (musicaAttiva) {
        musicaGioco.pause();
        pulsanteMusica.textContent = "🎵 Musica OFF";
    } else {
        musicaGioco.volume = 0.5; // Modifica volume se vuoi
        musicaGioco.play();
        pulsanteMusica.textContent = "🎵 Musica ON";
    }
    musicaAttiva = !musicaAttiva;
}

// Collega la funzione al click del pulsante
pulsanteMusica.addEventListener("click", toggleMusica);
    
      // Initialize Game
      window.addEventListener('load', initGame);
      
 // --- PARTICLE SUPER EXPLOSION + EFFETTI WOW ---

let explosionParticles = [];
let screenShakeTime = 0, screenShakeIntensity = 0;
let flashAlpha = 0;
let ripples = [];

// ESPLOSIONE SUPER COLORATA
function spawnSuperExplosion(x, y, opts = {}) {
  const colors = opts.colors || ["#fff", "#ff0044", "#14fc56", "#00cfff", "#ffd700", "#ff7f00", "#e91e63"];
  const count = Math.min(opts.count || 70, 18); // Max 18 particelle!
  for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 8;
        const color = colors[Math.floor(Math.random() * colors.length)];
        explosionParticles.push({
            x, y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            gravity: 0.05 + Math.random() * 0.08,
            size: 7 + Math.random() * 8,
            alpha: 1,
            life: 50 + Math.random() * 25,
            maxLife: 50 + Math.random() * 25,
            color,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.4,
            sparkle: opts.sparkle && Math.random() < 0.3,
            trail: Math.random() < 0.4
        });
    }
}

// ONDA (RIPPLE) effetto shockwave
function spawnRipple(x, y, color = "#fff") {
    ripples.push({ x, y, radius: 0, alpha: 0.45, color });
}

// SHAKE DELLO SCHERMO
function startShake(intensity = 20, duration = 18) {
    screenShakeTime = duration;
    screenShakeIntensity = intensity;
}

// FLASH DELLO SCHERMO
function startFlash(strength = 1) {
    flashAlpha = strength;
}

// UPDATE + DRAW PARTICELLE
function updateAndDrawExplosions(ctx) {
    for (let i = explosionParticles.length - 1; i >= 0; i--) {
        let p = explosionParticles[i];
        if (p.trail) {
            ctx.save();
            ctx.globalAlpha = p.alpha * 0.2;
            ctx.strokeStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        p.x += p.dx;
        p.y += p.dy;
        p.dy += p.gravity;
        p.dx *= 0.96;
        p.dy *= 0.96;
        p.life--;
        p.alpha = Math.max(p.life / p.maxLife, 0);

        ctx.save();
        ctx.globalAlpha = p.alpha;

        let grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.25, p.color);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;

        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.beginPath();
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.fill();

        if (p.sparkle) {
            ctx.globalAlpha = p.alpha * 0.7;
            ctx.strokeStyle = "#fff";
            for (let k = 0; k < 6; k++) {
                ctx.save();
                ctx.rotate((Math.PI / 3) * k + (p.life / 10));
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, p.size * 1.8);
                ctx.stroke();
                ctx.restore();
            }
        }

        ctx.restore();
        p.rotation += p.rotationSpeed;

        if (p.life <= 0) explosionParticles.splice(i, 1);
    }
}

// UPDATE + DRAW RIPPLE
function updateAndDrawRipples(ctx) {
    for (let i = ripples.length - 1; i >= 0; i--) {
        let r = ripples[i];
        ctx.save();
        ctx.globalAlpha = r.alpha;
        ctx.strokeStyle = r.color;
        ctx.lineWidth = 4 + r.radius * 0.07;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        r.radius += 12;
        r.alpha -= 0.018;
        if (r.alpha <= 0) ripples.splice(i, 1);
    }
}

// SHAKE LOGIC
function applyShake(ctx) {
    if (screenShakeTime > 0) {
        ctx.save();
        ctx.translate(
            (Math.random() - 0.5) * screenShakeIntensity,
            (Math.random() - 0.5) * screenShakeIntensity
        );
        screenShakeTime--;
        if (screenShakeTime <= 0) screenShakeIntensity = 0;
    }
}
function endShake(ctx) {
    if (screenShakeTime > 0) ctx.restore();
}

// FLASH LOGIC
function drawFlash(ctx, canvas) {
    if (flashAlpha > 0.01) {
        ctx.save();
        ctx.globalAlpha = flashAlpha;
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        flashAlpha *= 0.84;
    }
}

// FUNZIONI PRONTE DA USARE
function esplodiGiocatore(player) {
    spawnSuperExplosion(player.x, player.y, {
        colors: ["#00bcd4", "#fff", "#2196f3", "#14fc56"],
        count: 80,
        sparkle: true
    });
    spawnRipple(player.x, player.y, "#00e6ff");
    startShake(18, 22);
    startFlash(0.30);
}

function esplodiBoss(boss) {
    // Super esplosione centrale
    spawnSuperExplosion(boss.x, boss.y, {
        colors: ["#f00", "#fff", "#ffd700", "#9c27b0", "#ff7f00"],
        count: 140,
        sparkle: true
    });

    // Ripple shockwave
    spawnRipple(boss.x, boss.y, "#ffd700");

    // Mini esplosioni di fuoco attorno al boss (anello di fuochi)
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const fx = boss.x + Math.cos(angle) * 60;
        const fy = boss.y + Math.sin(angle) * 60;
        spawnSuperExplosion(fx, fy, {
            colors: ["#ff9800", "#ffd700", "#fff"],
            count: 18,
            sparkle: false
        });
    }

    // Fiamme che salgono dal boss
    for (let i = 0; i < 24; i++) {
        gameState.particles.push({
            x: boss.x + (Math.random() - 0.5) * 48,
            y: boss.y + 20 + Math.random() * 12,
            vx: (Math.random() - 0.5) * 2,
            vy: -4 - Math.random() * 3,
            color: ["#ff9800", "#ffd700", "#fff", "#f44336"][Math.floor(Math.random() * 4)],
            size: 8 + Math.random() * 8,
            life: 44 + Math.random() * 28,
            maxLife: 60,
            alpha: 1
        });
    }

    // Shake & flash finale
    startShake(28, 32);
    startFlash(0.5);
}
  
  let playerTrail = [];

function updatePlayerTrail() {
    playerTrail.push({
        x: gameState.player.x,
        y: gameState.player.y,
        alpha: 0.45
    });
    if (playerTrail.length > 7) playerTrail.shift();
    for (let t of playerTrail) t.alpha *= 0.8;
}

function renderPlayerTrail(ctx) {
    for (let t of playerTrail) {
        ctx.save();
        ctx.globalAlpha = t.alpha;
        ctx.fillStyle = "#ffe700";
        ctx.fillRect(t.x - 4, t.y - 2, 8, 4); // piccoli rettangoli gialli
        ctx.restore();
    }
}
   
  function checkObstacleCollisions() {
    const player = gameState.player;
    gameState.obstacles.forEach(ob => {
        if (ob.hit) return;
        const dx = ob.x - player.x;
        const dy = ob.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const hitbox = 24 + ob.size / 2;
        if (dist < hitbox) {
            // PATCH: in co-op segnala al server quale ostacolo hai colpito!
            if (gameState.gameMode === "coop" && socket && ob.id) {
                socket.emit('obstacleHit', ob.id);
            }
            ob.hit = true;
            player.health -= (ob.type === "mine" ? 35 : 20);
            spawnSuperExplosion(ob.x, ob.y, {colors:["#ffe700","#ff9800","#fff"],count:18});
            startShake(14, 10);
        
        
        }
    });
}
 
  
  
  
  function renderObstacles() {
    gameState.obstacles.forEach(ob => {
        ctx.save();
        ctx.translate(ob.x, ob.y);
        ctx.rotate(ob.angle);
        if (ob.type === "asteroid") {
            ctx.fillStyle = "#bdbdbd";
            ctx.beginPath();
            ctx.arc(0, 0, ob.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#888";
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(
                    Math.cos(i * 2 + ob.angle) * ob.size * 0.23,
                    Math.sin(i * 2 + ob.angle) * ob.size * 0.23,
                    ob.size / 8, 0, Math.PI * 2
                );
                ctx.fill();
            }
        } else if (ob.type === "mine") {
            ctx.fillStyle = "#e91e63";
            ctx.beginPath();
            ctx.arc(0, 0, ob.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#fff";
            for (let i = 0; i < 8; i++) {
                ctx.save();
                ctx.rotate(Math.PI / 4 * i);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(ob.size / 2, 0);
                ctx.stroke();
                ctx.restore();
            }
        }
        ctx.restore();
    });
}
  
function selectShip(shipId) {
    localStorage.setItem('selectedShip', shipId);
    highlightSelectedShip();
}

  function getSelectedShip() {
    return localStorage.getItem('selectedShip') || 'ship1';
  }

  function highlightSelectedShip() {
    const selectedShip = getSelectedShip();
    document.querySelectorAll('#shipInventory .level-card').forEach(card => {
      card.classList.remove('selected-ship');
      if (card.dataset.shipId === selectedShip) {
        card.classList.add('selected-ship');
      }
    });
  }

  const style = document.createElement('style');
  style.textContent = `.selected-ship {
    border: 4px solid #ffd700;
    box-shadow: 0 0 20px #ffd700;
    transform: scale(1.03);
  }`;
  document.head.appendChild(style);

  document.addEventListener('DOMContentLoaded', highlightSelectedShip);
  
  // Loading phrases & navicelle random
const loadingScreen = document.getElementById('loadingScreen');
const loadingBarFill = document.getElementById('loadingBarFill');
const loadingText = document.getElementById('loadingText');
const loadingPhrases = [
  "Calibrating Hyperdrive...",
  "Loading Cosmic Donuts...",
  "Brushing star dust...",
  "Preparing spaceship for launch...",
  "Loading mischievous enemies...",
  "Compiling galactic memes...",
  "Verifying ship's AI sarcasm level...",
  "Tuning space radio..."
];
const ships = ["navicella1.png", "navicella2.png", "navicella3.png"];
setInterval(() => {
  document.getElementById('loaderShip').src = ships[Math.floor(Math.random() * ships.length)];
}, 900);

function showLoadingScreen(duration = 2200) {
  loadingScreen.style.display = 'flex';
  loadingScreen.classList.remove('hide');
  document.body.classList.add('loading');
  loadingBarFill.style.width = '0%';
  let progress = 0;
  let interval = setInterval(() => {
    progress += Math.random() * 13 + 7;
    if (progress > 100) progress = 100;
    loadingBarFill.style.width = progress + '%';
    if (Math.random() < 0.24)
      loadingText.textContent = loadingPhrases[Math.floor(Math.random() * loadingPhrases.length)];
    if (progress >= 100) {
      clearInterval(interval);
      setTimeout(hideLoadingScreen, 700);
    }
  }, 350);
}

function hideLoadingScreen() {
  loadingScreen.classList.add('hide');
  document.body.classList.remove('loading');
  setTimeout(() => {
    loadingScreen.style.display = 'none';
  }, 700); // deve essere >= della transition
}

// All'avvio mostra loading
window.addEventListener('load', () => {
  showLoadingScreen();
  setTimeout(hideLoadingScreen, 2400);
});
  
  function buyEnergyRefill() {
    const price = 10;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.energy = gameState.player.maxEnergy;
        showNotification('Energy fully restored!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyTemporaryShield() {
    const price = 15;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.emergencyShields += 1;
        showNotification('Temporary shield acquired!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyBulletUpgrade() {
    const price = 30;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.bulletUpgradeTimer = 1200; // 20 sec @ 60fps
        showNotification('Bullets powered up for 20 seconds!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyAutoFire() {
    const price = 25;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.autoFireTimer = 1200; // 20 sec @ 60fps
        showNotification('Auto-fire enabled for 20 seconds!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buySpecialAttack() {
    const price = 20;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.specialReady = true;
        showNotification('Special attack ready!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyRandomPowerUp() {
    const price = 12;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        const powerUps = [
            () => { gameState.player.energy = gameState.player.maxEnergy; showNotification('Energy fully restored!', 'info'); },
            () => { gameState.player.health = gameState.player.maxHealth; showNotification('HP fully restored!', 'info'); },
            () => { gameState.player.emergencyShields += 1; showNotification('Temporary shield acquired!', 'info'); },
            () => { gameState.player.lives += 1; showNotification('Extra ship acquired!', 'info'); }
        ];
        powerUps[Math.floor(Math.random() * powerUps.length)]();
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyShipSkin() {
    const price = 50;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        // Sblocca una skin (implementa la logica di skin come preferisci)
        showNotification('New ship skin unlocked!', 'achievement');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}
  
  // --- MODALITÀ CAOS TOTALE ---
let chaosTimer = 0;
let currentChaos = null;
const CHAOS_EFFECTS = [
  {
    name: "Controlli Invertiti",
    apply: () => { gameState.chaosInverted = true; showNotification("🌀 Controlli Invertiti!"); },
    clear: () => { gameState.chaosInverted = false; }
  },
  {
    name: "Proiettili Giganti",
    apply: () => { gameState.chaosBullets = "big"; showNotification("💣 Proiettili Giganti!"); },
    clear: () => { gameState.chaosBullets = null; }
  },
  {
    name: "Gravità Pazza",
    apply: () => { gameState.chaosGravity = true; showNotification("🌌 Gravità Pazza!"); },
    clear: () => { gameState.chaosGravity = false; }
  },
  {
    name: "Colori Psichedelici",
    apply: () => { document.body.style.filter = "hue-rotate(90deg)"; showNotification("🎨 Colori Psichedelici!"); },
    clear: () => { document.body.style.filter = ""; }
  },
  {
    name: "Boss Meme",
    apply: () => { gameState.chaosBossMeme = true; showNotification("😂 Boss Meme!"); },
    clear: () => { gameState.chaosBossMeme = false; }
  },
  {
    name: "Energia Infinita",
    apply: () => { gameState.player.energy = 999; showNotification("⚡ Energia Infinita!"); },
    clear: () => { /* torna normale */ }
  }
];

function startChaosMode() {
  gameState.gameMode = 'chaos';
  showScreen('gameScreen');
  chaosTimer = 0;
  currentChaos = null;
  nextChaosEffect();
}

// Cambia effetto ogni 10 secondi
function updateChaosMode(deltaTime) {
  chaosTimer += deltaTime * 60; // deltaTime è ~1, quindi 60 frame = 1 secondo
  if (chaosTimer >= 600) { // ogni 10 secondi
    nextChaosEffect();
    chaosTimer = 0;
  }
}

function nextChaosEffect() {
  if (currentChaos !== null) CHAOS_EFFECTS[currentChaos].clear();
  currentChaos = Math.floor(Math.random() * CHAOS_EFFECTS.length);
  CHAOS_EFFECTS[currentChaos].apply();
}
  
 function getPlayerName() {
  let username = localStorage.getItem('playerName');
  if (!username || username.length < 2) username = "NoName";
  return username;
}

function submitLocalScore(username, score, level) {
  const leaderboard = JSON.parse(localStorage.getItem('localLeaderboard') || "[]");
  leaderboard.push({ username, score, level, timestamp: Date.now() });
  leaderboard.sort((a, b) => b.score - a.score); // Ordina per punteggio
  localStorage.setItem('localLeaderboard', JSON.stringify(leaderboard.slice(0, 10))); // Solo top 10
}


function showLocalLeaderboard() {
  showScreen('localLeaderboardScreen');
  const leaderboard = JSON.parse(localStorage.getItem('localLeaderboard') || "[]");
  let html = `<ol style="font-size:1.2rem;">`;
  leaderboard.forEach(item => {
    html += `<li><b>${item.username}</b> — <span style="color:#ffd700;">${item.score}</span> (Lvl ${item.level})</li>`;
  });
  if (leaderboard.length === 0) html += "<li>Nessun punteggio ancora!</li>";
  html += `</ol>`;
  document.getElementById('localLeaderboardList').innerHTML = html;
}
  
  function showGlobalLeaderboard() {
  showScreen('globalLeaderboardScreen');
  document.getElementById('globalLeaderboardList').innerHTML = 'Loading...';
  fetchGlobalLeaderboard(leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.name}</b> — <span style="color:#ffd700;">${entry.score}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>Nessun punteggio ancora!</li>";
    html += '</ol>';
    document.getElementById('globalLeaderboardList').innerHTML = html;
  });
}
  
  // ==== DAILY CHALLENGE: CONFIGURAZIONE ====

const DAILY_CHALLENGES = [
  { name: "1 Life!", desc: "Survive as long as possible with only 1 life", config: { lives: 1, endless: true } },
  { name: "Fastest Ship Only", desc: "Use only the fastest spaceship", config: { ship: "ship3" } },
  { name: "Boss Rush", desc: "Face only bosses from level 5 and up", config: { bossOnly: true } },
  { name: "Blitz", desc: "Score as many points as possible in 60 seconds", config: { timeLimit: 60 } },
  // ...add more challenges!
];

// Calcola challenge del giorno
function getDailyChallengeIndex() {
  const now = new Date();
  const daySeed = now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();
  return daySeed % DAILY_CHALLENGES.length;
}
function getDailyChallenge() {
  return DAILY_CHALLENGES[getDailyChallengeIndex()];
}

function showDailyChallengeMenu() {
  // Nascondi tutte le schermate
  document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
  document.getElementById('dailyChallengeScreen').classList.add('active');
  gameState.currentScreen = 'dailyChallengeScreen';

  // Mostra challenge del giorno
  const challenge = getDailyChallenge();
  document.getElementById('dailyChallengeDesc').innerHTML = `<b>${challenge.name}</b><br><span>${challenge.desc}</span>`;
  fetchDailyChallengeLeaderboard();
}

function startDailyChallenge() {
  const challenge = getDailyChallenge();

  // Applica regole della challenge
  if (challenge.config.lives) gameState.player.lives = challenge.config.lives;
  if (challenge.config.ship) localStorage.setItem('selectedShip', challenge.config.ship);
  if (challenge.config.endless) gameState.gameMode = 'endless';
  if (challenge.config.bossOnly) gameState.currentLevel = 5;
  if (challenge.config.timeLimit) gameState.dailyTimeLimit = challenge.config.timeLimit;

  gameState.isDailyChallenge = true; // Flag

  showScreen('gameScreen'); // Usa la funzione "vera"!
}

// ==== FINE PARTITA: Salva punteggio ====
function endDailyChallenge(score) {
  const username = getPlayerName();
  saveDailyChallengeScoreLocal(username, score);
  submitDailyChallengeScoreGlobal(username, score);
  // Mostra leaderboard aggiornata!
  fetchDailyChallengeLeaderboard();
}

// ==== LEADERBOARD LOCALE ====
function saveDailyChallengeScoreLocal(username, score) {
  const today = (new Date()).toISOString().slice(0, 10);
  let scores = JSON.parse(localStorage.getItem('dailyChallengeScores') || '{}');
  if (!scores[today]) scores[today] = [];
  scores[today].push({ username, score });
  scores[today].sort((a, b) => b.score - a.score);
  scores[today] = scores[today].slice(0, 10); // top 10
  localStorage.setItem('dailyChallengeScores', JSON.stringify(scores));
}

// ==== LEADERBOARD GLOBALE DREAMLO ====
function getDailyLeaderboardTag() {
  const today = (new Date()).toISOString().slice(0, 10);
  return "daily" + today.replace(/-/g, "");
}

// INVIO PUNTEGGIO GLOBALE
function submitDailyChallengeScoreGlobal(username, score) {
  const tag = getDailyLeaderboardTag();
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw"; // <-- la tua KEY Dreamlo
  const url = `https://dreamlo.com/lb/${dreamloKey}/add/${encodeURIComponent(username)}/${score}/${tag}`;
  fetch(url)
    .then(() => console.log("Score inviato a Dreamlo (daily)!"))
    .catch(err => console.error("Dreamlo errore:", err));
}

// SCARICA LEADERBOARD GLOBALE
function fetchDailyChallengeLeaderboard() {
  const tag = getDailyLeaderboardTag();
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw";
  const url = `https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`;
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [name, score] = row.split('|');
          if (!name || isNaN(parseInt(score))) return null;
          return { name, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score)
        .slice(0, 10);
      let html = "<ol style='font-size:1.1rem;'>";
      leaderboard.forEach(entry => {
        html += `<li><b>${entry.name}</b> — <span style="color:#ffd700;">${entry.score}</span></li>`;
      });
      if (leaderboard.length === 0) html += "<li>Nessun punteggio ancora!</li>";
      html += "</ol>";
      let el = document.getElementById('dailyLeaderboardList');
      if (el) el.innerHTML = html;
    });
}

// ==== UTILITY ====
// getPlayerName già esistente nel tuo gioco!

// ==== INTEGRAZIONE MENU ====
// Aggiungi nel menu principale:
// <button class="menu-btn" onclick="showDailyChallengeMenu()">🌟 Challenge Giornaliera</button>

// ==== NEL GAME LOOP, ALLA FINE DELLA PARTITA ====
// if (gameState.isDailyChallenge) endDailyChallenge(gameState.player.score);
// Ricordati di resettare gameState.isDailyChallenge = false; quando esci dalla modalità!

  
function changePlayerName() {
  if (document.getElementById('nicknameInput')) {
    document.getElementById('nicknameInput').focus();
  }
  showNotification('Change your nickname above and press Save.', 'info');
}
  
  function shareScore() {
  let score =
    document.getElementById('finalScore')?.textContent ||
    document.getElementById('victoryScore')?.textContent ||
    0;
  let level =
    document.getElementById('finalLevel')?.textContent ||
    "1";
let shareText = `I scored ${score} points in Stellar Guardian! Can you beat me?`;                                                                                                                                                                                                                                           
let shareUrl = window.location.href;

  if (navigator.share) {
    navigator.share({
      title: "Stellar Guardian",
      text: shareText,
      url: shareUrl
    }).catch(() => {});
  } else {
    // Desktop: popup social
    let tweet = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}&hashtags=StellarGuardian,arcadegame`;
    let fb = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}&quote=${encodeURIComponent(shareText)}`;
    let wa = `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
    let html = `
      <div id="sharePopup" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;padding:2rem;border-radius:18px;z-index:9999;text-align:center;">
        <b style="color:#ffd700;font-size:1.3rem;">Condividi il tuo record!</b><br><br>
        <a href="${tweet}" target="_blank" style="margin:8px;">🐦 Twitter</a>
        <a href="${fb}" target="_blank" style="margin:8px;">📘 Facebook</a>
        <a href="${wa}" target="_blank" style="margin:8px;">🟢 WhatsApp</a><br><br>
        <button onclick="document.getElementById('sharePopup').remove();" class="menu-btn">Chiudi</button>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', html);
  }
}

function copyScoreLink() {
  let score =
    document.getElementById('finalScore')?.textContent ||
    document.getElementById('victoryScore')?.textContent ||
    0;
  let shareText = `Ho fatto ${score} punti a Stellar Guardian! Gioca anche tu: ${window.location.href}`;
  navigator.clipboard.writeText(shareText).then(() => {
    showNotification('Link copiato negli appunti!', 'info');
  });
}
  
// --- CO-OP MULTIPLAYER REALTIME ---

// Variabili globali
let socket = null;
let mySocketId = null;
let otherPlayers = {}; // id: { x, y, nickname, angle, targetX, targetY, lastUpdate }
let coopPlayers = [];
let coopPositionInterval = null;
let voiceChatActive = false;
let playerVoiceStatus = {}; // socketId: true/false

function showCoopLobby() {
  showScreen('coopLobby');
  if (!socket) {
    socket = io();
  }
  setupBossListener();

  // --- PATCH: Chat multiplayer, sempre aggiungi il listener qui! ---
  if (socket) {
    if (typeof socket.off === "function") socket.off('chatMessage');
    socket.on('chatMessage', addChatMessage);
  }

  // Eventi multiplayer co-op
  if (socket) {
    if (typeof socket.off === "function") socket.off('spawnBullet');
    socket.on('spawnBullet', data => {
      gameState.bullets.push(data);
    });
  }

  if (socket) {
    socket.on('obstaclesUpdate', obstacles => {
      if (gameState.gameMode === "coop") {
        gameState.obstacles = obstacles;
      }
    });
  }

  if (socket) {
    if (typeof socket.off === "function") socket.off('bossAttack');
    socket.on('bossAttack', data => {
      if (gameState.gameMode === "coop") {
        executeBossAttackFromServer(data);
      }
    });
  }

  // Pulizia listener precedenti
  if (typeof socket.off === "function") {
    socket.off('connect');
    socket.off('lobbyUpdate');
    socket.off('gameStart');
    socket.off('bossDefeated');
    socket.off('otherPlayers');
    socket.off('webrtc-offer');
  }

  // Connessione
  socket.on('connect', () => {
    mySocketId = socket.id;
    console.log("Connected, socket id:", mySocketId);
  });

  // Aggiornamento lobby
  socket.on('lobbyUpdate', data => {
    console.log("Lobby update:", data);
    renderCoopPlayers(data);
  });

  // Avvio partita co-op
  socket.on('gameStart', data => startCoopRaidGame(data));

  // Boss sconfitto
  socket.on('bossDefeated', coopVictory);

  // PATCH universale: aggiorna e pulisci la lista otherPlayers in modo atomico e sempre corretto
  socket.on('otherPlayers', data => {
    // Rimuovi giocatori non più presenti
    Object.keys(otherPlayers).forEach(id => {
      if (!data.players.find(p => p.id === id)) delete otherPlayers[id];
    });
    // Aggiorna o aggiungi ogni player ricevuto
    data.players.forEach(p => {
      if (p.id === mySocketId) return;
      if (!otherPlayers[p.id]) {
        otherPlayers[p.id] = { x: p.x, y: p.y, nickname: p.nickname, angle: p.angle || 0 };
      }
      otherPlayers[p.id].targetX = p.x;
      otherPlayers[p.id].targetY = p.y;
      otherPlayers[p.id].nickname = p.nickname;
      otherPlayers[p.id].angle = p.angle || 0;
      otherPlayers[p.id].lastUpdate = Date.now();
    });
  });

  if (socket) {
    socket.on('voiceActive', data => {
      playerVoiceStatus[data.id] = data.active;
      renderCoopPlayers({players: coopPlayers}); // aggiorna la lista
    });
  }

  // --- WebRTC OFFER LISTENER QUI ---
  socket.on('webrtc-offer', data => {
    let pc = peerConnections[data.fromId] || new RTCPeerConnection({
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject"
        }
      ]
    });
    peerConnections[data.fromId] = pc;

    // --- LOG STATO ICE E CONNECTION ---
    pc.oniceconnectionstatechange = () => {
      console.log(`[WebRTC ${data.fromId}] ICE state:`, pc.iceConnectionState);
    };
    pc.onicecandidateerror = e => {
      console.error(`[WebRTC ${data.fromId}] ICE candidate error:`, e);
    };
    pc.onconnectionstatechange = () => {
      console.log(`[WebRTC ${data.fromId}] Connection state:`, pc.connectionState);
    };

    pc.onicecandidate = e => {
      if (e.candidate) socket.emit('webrtc-ice', { targetId: data.fromId, candidate: e.candidate });
    };
    pc.ontrack = e => {
      let audio = document.createElement('audio');
      audio.srcObject = e.streams[0];
      audio.autoplay = true;
      audio.controls = false;
      audio.muted = false;
      audio.volume = 1.0;
      audio.style.display = 'none';
      document.body.appendChild(audio);
      // Log
      console.log(`[WebRTC ${data.fromId}] Audio track received`);
      audio.play().catch(err => console.log("Audio play error", err));
    };

    pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
    if (localStream) localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.createAnswer().then(answer => {
      pc.setLocalDescription(answer);
      socket.emit('webrtc-answer', { targetId: data.fromId, sdp: answer });
    });
  });

  // Entro nella lobby (join)
  socket.emit('joinLobby', { nickname: getPlayerName() });
}

function renderCoopPlayers(data) {
  coopPlayers = data.players;
  document.getElementById('coopPlayersList').innerHTML =
    '<b>Giocatori connessi:</b><ul>' +
    data.players.map(p => {
      const voiceIcon = playerVoiceStatus[p.id] ? " <span title='Voce attiva' style='color:#ffd700;'>🎤</span>" : "";
      return `<li>${p.nickname}${voiceIcon}</li>`;
    }).join('') +
    '</ul>' +
    "<div style='margin-top:6px;font-size:0.97em;color:#00bcd4;'>Tip: clicca <b>🎤 Voice Chat</b> per parlare con la squadra!</div>";
}

function startCoopRaid() {
  if (socket) socket.emit('startCoopRaid');
}

function startCoopRaidGame(data) {
  resetBossVisualState(); // <--- AGGIUNGI QUESTA RIGA!!!
  gameState.currentLevel = 20;
  initializeCampaignEnemy();
  gameState.enemy.health = data.boss.health;
  gameState.enemy.maxHealth = data.boss.maxHealth;
  gameState.enemy.x = data.boss.x || gameState.enemy.x;
  gameState.enemy.y = data.boss.y || gameState.enemy.y;
  gameState.enemy.angle = data.boss.angle || 0;
  coopPlayers = data.players;
  gameState.gameMode = 'coop';
  gameState.currentScreen = 'gameScreen';
  showScreen('gameScreen');
  startCoopGameLoop();
}

function coopVictory() {
  showNotification("BOSS SCONFITTO! RAID CO-OP COMPLETATO!", "achievement");
  showScreen('victory');
}

function coopShootBoss(damage) {
  if (socket) socket.emit('bossDamage', { damage });
}

// --- GAMELOOP CO-OP ---
function startCoopGameLoop() {
  if (coopPositionInterval) clearInterval(coopPositionInterval);
  coopPositionInterval = setInterval(sendMyPosition, 40); // invia posizione ogni 40ms

  function coopLoop() {
    updatePlayer(1);
    updatePlayerTrail();
    updateObstacles();
    // Non aggiornare la posizione del boss localmente! (solo render e attacchi, la posizione arriva da server)
    updateBullets(1);
    updateEnemyBullets(1);
    updateParticles(1);
    updateSlowTime();
    updateAdaptiveDifficulty();
    updateScreenShake();
    checkCollisionsCoop();
    render();
    renderBossBar(); // <---- AGGIUNGI QUI!

    if (gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'coop')
      requestAnimationFrame(coopLoop);
  }
  coopLoop();
}

function stopCoopGameLoop() {
  if (coopPositionInterval) clearInterval(coopPositionInterval);
  coopPositionInterval = null;
}

function sendMyPosition() {
  if (socket && gameState.gameMode === "coop") {
    socket.emit('playerMove', {
      x: gameState.player.x,
      y: gameState.player.y,
      angle: gameState.player.angle,
      nickname: getPlayerName(),
      // PATCH: sincronizza stato vitale
      health: gameState.player.health,
      maxHealth: gameState.player.maxHealth,
      energy: gameState.player.energy,
      maxEnergy: gameState.player.maxEnergy,
      lives: gameState.player.lives
    });
  }
}

function checkCollisionsCoop() {
  for (let i = gameState.bullets.length - 1; i >= 0; i--) {
    const bullet = gameState.bullets[i];
    const boss = gameState.enemy;
    if (!boss) continue;
    const dist = Math.sqrt(Math.pow(bullet.x - boss.x, 2) + Math.pow(bullet.y - boss.y, 2));
    if (dist < 60) {
      // Solo il proprietario manda il danno!
      if (bullet.owner === mySocketId) {
        coopShootBoss(bullet.damage);
      }
      createHitParticles(bullet.x, bullet.y, bullet.color);
      gameState.bullets.splice(i, 1);
      updateUI();
    }
  }
}
 
// === PATCH: Boss co-op, barra vita fluida e funzionante ===

// 1. Variabili globali
let bossTarget = { x: null, y: null, angle: null };
let bossServerHealth = null;     // <-- LA VERA health ricevuta dal server!
let bossMaxHealth = null;        // <-- La maxHealth del boss dal server!
let bossVisualHealth = null;     // <-- Per l'interpolazione fluida della barra
let lastFrameTime = performance.now();

function resetBossVisualState() {
  bossVisualHealth = null;
  bossServerHealth = null;
  bossMaxHealth = null;
  bossTarget = { x: null, y: null, angle: null };
}


function setupBossListener() {
  if (!socket) return;
  socket.off?.('bossUpdate');
  socket.on('bossUpdate', data => {
    bossServerHealth = data.health;
    bossMaxHealth = data.maxHealth;
    if (bossVisualHealth === null) bossVisualHealth = bossServerHealth;
    // PATCH: salva bersaglio di posizione boss
    bossTarget.x = data.x;
    bossTarget.y = data.y;
    bossTarget.angle = data.angle;
  });
}

function interpolateBoss() {
  if (
    gameState.gameMode === "coop" &&
    gameState.enemy &&
    bossTarget.x !== null &&
    bossTarget.y !== null
  ) {
    // Interpolazione fluida
    gameState.enemy.x += (bossTarget.x - gameState.enemy.x) * 0.13;
    gameState.enemy.y += (bossTarget.y - gameState.enemy.y) * 0.13;
    if (bossTarget.angle !== null) {
      gameState.enemy.angle += (bossTarget.angle - gameState.enemy.angle) * 0.18;
    }
  }
}

function interpolateBossHealth() {
  if (
    gameState.gameMode === "coop" &&
    gameState.enemy &&
    typeof gameState.enemy.targetHealth === "number"
  ) {
    if (bossVisualHealth === null) bossVisualHealth = gameState.enemy.targetHealth;
    bossVisualHealth += (gameState.enemy.targetHealth - bossVisualHealth) * 0.18;
    if (Math.abs(bossVisualHealth - gameState.enemy.targetHealth) < 1) {
      bossVisualHealth = gameState.enemy.targetHealth;
    }
    console.log("interpolateBossHealth:", bossVisualHealth, "/", gameState.enemy.maxHealth); // <--- LOG
    const percent = Math.max(0, bossVisualHealth) / gameState.enemy.maxHealth * 100;
    document.getElementById('enemyHealthFill').style.width = percent + '%';
    document.getElementById('enemyHealthText').textContent = `${Math.max(0, Math.floor(bossVisualHealth))} / ${gameState.enemy.maxHealth}`;
  }
}

// 5. CoopLoop con deltaTime e patch smooth
function startCoopGameLoop() {
  if (coopPositionInterval) clearInterval(coopPositionInterval);
  coopPositionInterval = setInterval(sendMyPosition, 40);
  lastFrameTime = performance.now();

  function coopLoop() {
    let now = performance.now();
    let rawDelta = (now - lastFrameTime) / 16.67;
    lastFrameTime = now;

    // Ignora deltaTime enorme (tab inattiva o lag browser)
    let deltaTime = (rawDelta > 2.5 || rawDelta < 0.2) ? 1 : rawDelta;
    // Limita deltaTime tra 0.7 e 1.5 (evita scatti e rallentamenti)
    deltaTime = Math.max(0.7, Math.min(deltaTime, 1.5));

    updatePlayer(deltaTime);
    updatePlayerTrail();
    updateObstacles(deltaTime);
    updateBullets(deltaTime);
    updateEnemyBullets(deltaTime);
    updateParticles(deltaTime);
    updateSlowTime();
    updateAdaptiveDifficulty();
    updateScreenShake();
    checkCollisionsCoop();
    interpolateBoss();
    interpolateBossHealth();
    render();
    if (gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'coop')
      requestAnimationFrame(coopLoop);
  }
  coopLoop();
}

// 6. Assicurati che checkCollisionsCoop chiami coopShootBoss(damage) e socket sia inizializzato

// --- FINE PATCH ---
  
 let localStream = null;
let peerConnections = {};

function startVoiceChat() {
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
      localStream = stream;
      coopPlayers.forEach(p => {
        if (p.id === mySocketId) return;
        setupPeerVoice(p.id);
      });
      showNotification('Chat vocale attivata! Microfono collegato.', 'info');
    })
    .catch(() => showNotification('Impossibile accedere al microfono.', 'info'));
}

function setupPeerVoice(peerId) {
  const pc = new RTCPeerConnection({ 
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      {
        urls: "turn:openrelay.metered.ca:80",
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ]
  });  
  peerConnections[peerId] = pc;
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  // --- LOG STATO ICE E CONNECTION ---
  pc.oniceconnectionstatechange = () => {
    console.log(`[WebRTC ${peerId}] ICE state:`, pc.iceConnectionState);
  };
  pc.onicecandidateerror = e => {
    console.error(`[WebRTC ${peerId}] ICE candidate error:`, e);
  };
  pc.onconnectionstatechange = () => {
    console.log(`[WebRTC ${peerId}] Connection state:`, pc.connectionState);
  };

  pc.onicecandidate = e => {
    if (e.candidate) socket.emit('webrtc-ice', { targetId: peerId, candidate: e.candidate });
  };
  pc.ontrack = e => {
    let audio = document.createElement('audio');
    audio.srcObject = e.streams[0];
    audio.autoplay = true;
    audio.controls = false;
    audio.style.display = 'none';
    audio.muted = false;
    audio.volume = 1.0;
    document.body.appendChild(audio);
    // Log
    console.log(`[WebRTC ${peerId}] Audio track received`);
    // Forza play (debug autoplay block)
    audio.play().catch(err => console.log("Audio play error", err));
  };
  pc.createOffer().then(offer => {
    pc.setLocalDescription(offer);
    socket.emit('webrtc-offer', { targetId: peerId, sdp: offer });
  });
}
  
  
 function savePlayerName() {
  const val = document.getElementById('nicknameInput').value.trim();
  if (val.length >= 2) {
    localStorage.setItem('playerName', val);
    showNotification('Nickname updated!', 'info');
  } else {
    showNotification('Nickname too short!', 'info');
  }
}
  
  window.addEventListener('DOMContentLoaded', () => {
  if (document.getElementById('nicknameInput'))
    document.getElementById('nicknameInput').value = localStorage.getItem('playerName') || '';
});
  
  
  function isDevEnv() {
  // File://, localhost, 127.0.0.1, o qualsiasi dominio di test che vuoi
  return (
    location.protocol === "file:" ||
    location.hostname === "localhost" ||
    location.hostname === "127.0.0.1"
    // || location.hostname.endsWith(".ngrok-free.app") // aggiungi altri domini di test se vuoi
  );
}

function showAdAndStartGame() {
  // Salta tutto se sei in sviluppo/locale!
  if (isDevEnv()) {
    console.log("DEV: saltata pubblicità, avvio diretto.");
    startGame(true);
    return;
  }

  // GameMonetize fallback
  if (typeof sdk !== 'undefined' && typeof sdk.showAd === 'function') {
    sdk.showAd();
    window.levelTimeout = setTimeout(() => startGame(true), 2000);
    return;
  }
  // Nessuna ad, avvia subito
  startGame(true);
}
  
  
function showScreen(screenId) {
    console.log("showScreen chiamata con:", screenId);
    
    if (screenId === 'mobileCustomizationMenu') {
  loadMobileSettings();
}
    
    
    // Cancella eventuali timeout attivi per evitare salti di livello
    if (window.levelTimeout) {
        clearTimeout(window.levelTimeout);
        window.levelTimeout = null;
    }

    // Disattiva tutte le schermate
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
    });

    // Attiva la schermata scelta, se esiste
    const screenElem = document.getElementById(screenId);
    if (screenElem) {
        screenElem.classList.add('active');
        gameState.currentScreen = screenId;
    } else {
        console.warn("Schermata non trovata:", screenId);
        return;
    }

    // Mobile controls
    const mobileControls = document.getElementById('mobileControls');
    if (mobileControls) {
        if (screenId === 'gameScreen' && gameState.isMobile) {
            mobileControls.classList.add('active');
        } else {
            mobileControls.classList.remove('active');
        }
    }

    // Gestione logica specifica per schermate
    if (screenId === 'gameScreen') {
        // PATCH: se pendingStart è true, NON fare showAdAndStartGame()
        if (!gameState.gameRunning && !gameState.pendingStart) {
            showAdAndStartGame(); // Mostra adv, poi avvia partita
        } else if (gameState.gameRunning) {
            resumeGame();
        }
    } else {
        if (gameState.gameRunning) {
            pauseGame();
        }
    }

    // RICHIAMA INVENTARIO NAVICELLE OGNI VOLTA CHE ENTRI NELLA SCHERMATA
    if (screenId === 'inventoryScreen') {
        if (typeof generaInventarioNavicelle === 'function') {
            generaInventarioNavicelle();
        }
    }
}


function renderBossBar() {
  if (bossServerHealth === null || bossMaxHealth === null) return;
  if (bossVisualHealth === null) bossVisualHealth = bossServerHealth;
  // Interpolazione fluida (più reattiva = 0.4)
  bossVisualHealth += (bossServerHealth - bossVisualHealth) * 0.4;
  if (Math.abs(bossVisualHealth - bossServerHealth) < 0.7) bossVisualHealth = bossServerHealth;
  // Aggiorna barra
  const percent = Math.max(0, bossVisualHealth) / bossMaxHealth * 100;
  document.getElementById('enemyHealthFill').style.width = percent + '%';
  document.getElementById('enemyHealthText').textContent =
    `${Math.max(0, Math.floor(bossVisualHealth))} / ${bossMaxHealth}`;
}
 
  // Esegui il pattern proiettili boss in co-op, chiamata dal server
function executeBossAttackFromServer({ pattern, x, y }) {
  // Usa i dati del livello 20 come riferimento per il raid co-op
  const levelData = LEVEL_DATA[19] || LEVEL_DATA[0];
  const bulletSpeed = levelData.bulletSpeed || 4;
  const bulletCount = 3.5; // Puoi regolare per più difficoltà

  switch (pattern) {
    case 'basic':
      for (let i = 0; i < Math.floor(3 * bulletCount); i++) {
        gameState.enemyBullets.push({
          x: x + (i - 1) * 30,
          y: y + 50,
         vx: (i - 1) * 0.5 * 0.65, // rallentato
vy: bulletSpeed * 0.65,    // rallentato
          color: '#f44336',
          size: 5,
          damage: 15
        });
      }
      break;
    case 'spread':
      const spreadCount = Math.floor(5 * bulletCount);
      for (let i = 0; i < spreadCount; i++) {
        const angle = (i / spreadCount) * Math.PI - Math.PI / 2;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * bulletSpeed,
          vy: Math.sin(angle) * bulletSpeed + 2,
          color: '#e91e63',
          size: 6,
          damage: 12
        });
      }
      break;
    case 'tracking':
      const dx = gameState.player.x - x;
      const dy = gameState.player.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      for (let i = 0; i < Math.floor(2 * bulletCount); i++) {
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: (dx / dist) * bulletSpeed + (Math.random() - 0.5) * 1,
          vy: (dy / dist) * bulletSpeed + (Math.random() - 0.5) * 1,
          color: '#9c27b0',
          size: 10,
          damage: 18,
          tracking: true,
          trackingStrength: 0.03
        });
      }
      break;
    case 'laser':
      for (let i = 0; i < 15; i++) {
        gameState.enemyBullets.push({
          x: x,
          y: y + 50 + i * 12,
          vx: 0,
          vy: bulletSpeed * 1.5,
          color: '#ff9800',
          size: 12,
          damage: 20
        });
      }
      break;
    case 'wave':
      for (let i = 0; i < Math.floor(8 * bulletCount); i++) {
        const angle = (i / 8) * Math.PI * 2;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * 2,
          vy: Math.sin(angle) * 2 + bulletSpeed,
          color: '#673ab7',
          size: 8,
          damage: 15,
          wave: true,
          waveOffset: i * 0.5
        });
      }
      break;
    case 'swarm':
      for (let i = 0; i < Math.floor(12 * bulletCount); i++) {
        gameState.enemyBullets.push({
          x: x + (Math.random() - 0.5) * 100,
          y: y + 30,
          vx: (Math.random() - 0.5) * 4,
          vy: bulletSpeed * 0.8,
          color: '#3f51b5',
          size: 6,
          damage: 10
        });
      }
      break;
    case 'spiral':
      const spiralCount = Math.floor(10 * bulletCount);
      for (let i = 0; i < spiralCount; i++) {
        const angle = (i / spiralCount) * Math.PI * 4 + (Date.now() * 0.01);
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * 3,
          vy: Math.sin(angle) * 3 + bulletSpeed,
          color: '#2196f3',
          size: 7,
          damage: 14
        });
      }
      break;
    case 'chaos':
      for (let i = 0; i < Math.floor(15 * bulletCount); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed + 1,
          color: '#00bcd4',
          size: Math.random() * 8 + 4,
          damage: 16
        });
      }
      break;
    case 'ultimate':
      for (let i = 0; i < Math.floor(20 * bulletCount); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 3;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: '#ffd700',
          size: 15,
          damage: 25,
          ultimate: true
        });
      }
      break;
  }
  gameState.bulletHellIntensity = Math.min(100, gameState.bulletHellIntensity + 2);
}
  
  
  function fetchCoopLeaderboard(callback) {
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw"; // tua public key Dreamlo
  const tag = "coopraid"; // scegli un tag chiaro!
  const url = `https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`;
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [team, score] = row.split('|');
          if (!team || isNaN(parseInt(score))) return null;
          return { team, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score);
      callback(leaderboard);
    });
}
  
  function showCoopLeaderboard() {
  showScreen('coopLeaderboardScreen');
  document.getElementById('coopLeaderboardList').innerHTML = 'Loading...';
  fetchCoopLeaderboard(leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.team.replace(/_/g, " / ")}</b> — <span style="color:#ffd700;">${entry.score}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>No team scores yet!</li>";
    html += '</ol>';
    document.getElementById('coopLeaderboardList').innerHTML = html;
  });
}
  
 
 // 1. Funzione per controllare se è estate
function isSummerEventActive() {
  const now = new Date();
  const month = now.getMonth() + 1;
  return month >= 6 && month <= 8; // giugno, luglio, agosto
}
 
 
 function generaInventarioNavicelle() {
  const ships = [
    { id: "ship1", src: "navicella1.png", boss: "Falcon X", difficulty: "Agile & Fast" },
    { id: "ship2", src: "navicella2.png", boss: "Titan Omega", difficulty: "Heavy Armor" },
    { id: "ship3", src: "navicella3.png", boss: "Blue Star", difficulty: "Ultra Fast" },
    { id: "ship4", src: "navicella4.png", boss: "Pixel Blue", difficulty: "Retro Pixel" }
  ];
  // Skin estiva evento
  if (isSummerEventActive()) {
    ships.push({ id: "summer", src: "navicella-summer.png", boss: "Sunrider", difficulty: "🌞 Summer 2025 (Evento!)" });
  }
  const inventoryDiv = document.getElementById('shipInventory');
  inventoryDiv.innerHTML = '';
  ships.forEach(ship => {
    const card = document.createElement('div');
    card.className = 'level-card';
    card.dataset.shipId = ship.id;
    card.onclick = () => selectShip(ship.id);
    card.innerHTML = `
      <img src="${ship.src}" class="ship-image" />
      <div class="level-boss">${ship.boss}</div>
      <div class="level-difficulty">${ship.difficulty}</div>
    `;
    inventoryDiv.appendChild(card);
  });
  highlightSelectedShip();
}
 
 
// === PATCH MOBILE: AIM ASSIST SOLO, SENZA AUTO-FIRE ===

// 1. Forza landscape su mobile all'avvio
window.addEventListener('DOMContentLoaded', function() {
  if (/Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    if (typeof setOrientation === "function") setOrientation('landscape');
    const selector = document.getElementById('orientationSelector');
    if (selector) selector.style.display = 'none';
  }
});


function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Opera Mobi|Mobile|Silk|Kindle|Windows Phone|PlayBook|BB10|webOS|Mobile Safari|Fennec/i
    .test(navigator.userAgent)
    || ("ontouchstart" in window && screen.width < 900);
}
 
 // === PATCH: Popup suggerimento landscape su mobile ===

// 1. Crea l'elemento popup in HTML (lo inserisce via JS all'avvio)
function createOrientationAdvicePopup() {
  if (document.getElementById('orientationAdvicePopup')) return; // già presente

  const popup = document.createElement('div');
  popup.id = 'orientationAdvicePopup';
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = 'linear-gradient(45deg, #00bcd4, #2196f3)';
  popup.style.color = '#fff';
  popup.style.padding = '2rem 2.5rem';
  popup.style.borderRadius = '22px';
  popup.style.boxShadow = '0 0 40px #00bcd488';
  popup.style.zIndex = 99999;
  popup.style.fontSize = '1.3rem';
  popup.style.textAlign = 'center';
  popup.style.display = 'none';
  popup.innerHTML = `
    <div style="font-size:2.3rem;margin-bottom:0.5em;">🔄</div>
    <b>Rotate your phone horizontally<br>for the best experience!</b>
    <div style="margin-top:1em;"><button onclick="document.getElementById('orientationAdvicePopup').style.display='none'" style="margin-top:0.5em;padding:0.6em 1.3em;border-radius:15px;background:#ffd700;color:#222;font-weight:bold;border:none;cursor:pointer;">OK</button></div>
  `;
  document.body.appendChild(popup);
}

// 2. Mostra il popup se in portrait su mobile
function checkAndShowOrientationAdvice() {
  if (!isMobileDevice()) return;
  // Controlla se siamo in portrait (più alti che larghi)
  const portrait = window.innerHeight > window.innerWidth;
  if (portrait && typeof setOrientation === "function" && gameState.orientation === "auto") {
    createOrientationAdvicePopup();
    const popup = document.getElementById('orientationAdvicePopup');
    if (popup) {
      popup.style.display = 'block';
    }
  } else {
    // Nascondi se in landscape
    const popup = document.getElementById('orientationAdvicePopup');
    if (popup) popup.style.display = 'none';
  }
}

// 3. Rileva il cambio orientamento e mostra/nasconde il popup
window.addEventListener('orientationchange', checkAndShowOrientationAdvice);
window.addEventListener('resize', checkAndShowOrientationAdvice);

// 4. All'avvio della partita, mostra il popup se serve
window.addEventListener('DOMContentLoaded', function() {
  setTimeout(checkAndShowOrientationAdvice, 300); // Delay per layout
});



 
 // PATCH: Boss co-op visibile su mobile

function getSafeBossPosition(x, y) {
  // Calcola margine minimo per boss su mobile (landscape/portrait)
  let marginX = 80, marginY = 80;
  if (isMobileDevice()) {
    // Aumenta margini su mobile per evitare taglio
    marginX = Math.max(window.innerWidth * 0.08, 60);
    marginY = Math.max(window.innerHeight * 0.08, 60);
    // Se landscape molto stretto, aumenta ancora
    if (window.innerWidth > window.innerHeight) {
      marginY = Math.max(window.innerHeight * 0.12, 80);
    }
  }
  // Limita la posizione
  const safeX = Math.max(marginX, Math.min(x, window.innerWidth - marginX));
  const safeY = Math.max(marginY, Math.min(y, window.innerHeight - marginY));
  return { x: safeX, y: safeY };
}

// PATCH: Interpolazione boss co-op (aggiungi limitazione posizione)
function interpolateBoss() {
  if (
    gameState.gameMode === "coop" &&
    gameState.enemy &&
    bossTarget.x !== null &&
    bossTarget.y !== null
  ) {
    // Interpolazione fluida
    let newX = gameState.enemy.x + (bossTarget.x - gameState.enemy.x) * 0.13;
    let newY = gameState.enemy.y + (bossTarget.y - gameState.enemy.y) * 0.13;
    // Limita posizione
    const safe = getSafeBossPosition(newX, newY);
    gameState.enemy.x = safe.x;
    gameState.enemy.y = safe.y;
    if (bossTarget.angle !== null) {
      gameState.enemy.angle += (bossTarget.angle - gameState.enemy.angle) * 0.18;
    }
  }
}

// PATCH: Riduci dimensione boss su mobile landscape
function renderEnemy() {
    if (gameState.gameMode === "duel1v1") return; // Non disegnare boss in 1v1!

  const enemy = gameState.enemy;
  if (!enemy || enemy.health <= 0) return;
  ctx.save();
  ctx.translate(enemy.x, enemy.y);
  ctx.rotate(enemy.angle || 0);

  // Modifica grandezza su mobile
  let bossSize = 80;
  if (isMobileDevice()) {
    bossSize = Math.min(window.innerWidth, window.innerHeight) < 500 ? 54 : 64;
    // Landscape molto stretto (altezza bassa): riduci ancora
    if (window.innerWidth > window.innerHeight && window.innerHeight < 360) bossSize = 44;
  }

  if (gameState.chaosBossMeme) {
    ctx.font = bossSize + "px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("😂", 0, 0);
  } else if (bossImage.complete && bossImage.naturalWidth !== 0) {
    ctx.drawImage(bossImage, -bossSize/2, -bossSize/2, bossSize, bossSize);
  } else {
    ctx.fillStyle = '#f44336';
    ctx.beginPath();
    ctx.arc(0, 0, bossSize/2, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}
 
 window.addEventListener('DOMContentLoaded', () => {
  const nickInput = document.getElementById('nicknameInput');
  if (nickInput) {
    nickInput.value = localStorage.getItem('playerName') || '';
  }
});
 
 
 function updatePlayButtonVisibility() {
  const playBtn = document.getElementById('playBtn');
  const nicknameInput = document.getElementById('nicknameInput');
  if (!playBtn || !nicknameInput) return;
  const nickname = nicknameInput.value.trim();
  playBtn.style.display = nickname.length >= 2 ? 'inline-block' : 'none';
}

window.addEventListener('DOMContentLoaded', () => {
  const nicknameInput = document.getElementById('nicknameInput');
  if (nicknameInput) {
    nicknameInput.addEventListener('input', updatePlayButtonVisibility);
    updatePlayButtonVisibility();
  }
});
 
 function onPlayClicked() {
  // Vai in fullscreen PRIMA di avviare la partita
  launchGameFullscreen();

  // Poi avvia la partita come prima
  if (isDevEnv()) {
    startGame(true);
    return;
  }
  if (typeof sdk !== 'undefined' && typeof sdk.showAd === 'function') {
    sdk.showAd();
    window._pendingStartGame = true;
    return;
  }
  startGame(true);
}
 
 
 // Funzione per inviare messaggi
function sendChatMessage() {
  const input = document.getElementById('chatInput');
  let msg = input.value.trim();
  if (!msg) return;
  if (socket) {
    socket.emit('chatMessage', {nickname: getPlayerName(), text: msg});
    input.value = '';
  }
}

// Funzione per mostrare messaggi in chat
function addChatMessage(data) {
  const chatDiv = document.getElementById('chatMessages');
  if (!chatDiv) return;
  let safeText = (''+data.text).replace(/</g,"&lt;").replace(/>/g,"&gt;");
  chatDiv.innerHTML += `<div><b style="color:#ffd700;">${data.nickname}</b>: ${safeText}</div>`;
  chatDiv.scrollTop = chatDiv.scrollHeight;
}

// Listener ricezione messaggi
if (typeof socket !== 'undefined' && socket) {
  socket.on('chatMessage', addChatMessage);
}

// (opzionale) Invio con Enter
document.getElementById('chatInput')?.addEventListener('keydown', function(e){
  if (e.key === "Enter") sendChatMessage();
});
 
 function launchGameFullscreen() {
  const elem = document.getElementById('gameContainer');
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { // Safari
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { // IE11
    elem.msRequestFullscreen();
  }
}
 
 
 function toggleDaily() {
  const cont = document.getElementById('dailyContainer');
  const frame = document.getElementById('dailyFrame');
  const roomName = "StellarGuardianCoopRoom"; // oppure dinamico se vuoi
  const dailyURL = "https://stellarguardian.daily.co/" + roomName;
  
  if (cont.style.display === 'none') {
    frame.src = dailyURL;
    cont.style.display = 'block';
  } else {
    frame.src = "";
    cont.style.display = 'none';
  }
}
 
 
 // ========== SOCKET.IO CONNECTION ==========

// ========== UI ELEMENTS ==========
const duelLobby = document.getElementById('duelLobby');
const duelShip1 = document.getElementById('duelShip1');
const duelShip2 = document.getElementById('duelShip2');
const duelNick1 = document.getElementById('duelNick1');
const duelNick2 = document.getElementById('duelNick2');
const duelStatus = document.getElementById('duelStatus');
const duelCancelBtn = document.getElementById('duelCancelBtn');
const duelCountdown = document.getElementById('duelCountdown');
const duelEndScreen = document.getElementById('duelEndScreen');
const duelEndTitle = document.getElementById('duelEndTitle');
const duelEndStats = document.getElementById('duelEndStats');
const duelRematchBtn = document.getElementById('duelRematchBtn');
const duelLobbyBtn = document.getElementById('duelLobbyBtn');

duelCancelBtn.onclick = () => {
  if (window.socket) {
    window.socket.emit("duel_cancel", {});
  }
  duelLobby.classList.add('hidden');
};



// ========== STATE ==========
let duelRoomId = null;
let duelOpponent = null;
let duelGameActive = false;

// ========== LOBBY FLOW ==========
function openDuelLobby() {
  duelLobby.classList.remove('hidden');
  duelStatus.textContent = "Looking for opponent...";
  duelNick1.textContent = getPlayerName();
  duelShip1.src = getSelectedShipImage();
  duelNick2.textContent = "Searching...";
  duelShip2.src = "navicella2.png";
  
}

function startDuelQueue() {
  if (!window.socket) {
    window.socket = io();
    setupDuelListeners();
  }
  // Assicurati di avere SEMPRE la reference giusta:
  window.openDuelLobby();
  window.socket.emit("duel_queue", {
    nickname: getPlayerName(),
    skin: getSelectedShipImage()
  });
}



function startDuelCountdown() {
  duelLobby.classList.add('hidden'); // Nascondi la lobby

  // Mostra la schermata animata!
  showDuelLoadingScreen(
    getPlayerName(),                        // tuo nickname
    getSelectedShipImage(),                 // tua skin nave
    getEloLeague(gameState.elo).icon + " " + getEloLeague(gameState.elo).name, // tuo ELO/lega
    duelOpponent?.nickname || "Opponent",   // nickname avversario
    duelOpponent?.skin || "navicella2.png", // skin avversario
    getEloLeague(duelOpponent?.elo || 1000).icon + " " + getEloLeague(duelOpponent?.elo || 1000).name, // ELO avversario
    "Ready for the cosmic duel?"            // frase motivazionale (puoi mettere random)
  );
}

function startDuelGame() {
  duelGameActive = true;
  showScreen('gameScreen');
  window.gameState.gameMode = 'duel1v1';
  window.gameState.duelRoomId = duelRoomId;
  window.gameState.opponent = duelOpponent;
  gameState.enemy = null;

  // ... setup arena ...
  initDuelArena();

  // Avvia loop di sincronizzazione
  duelSyncLoop();

  // AVVIA IL GAMELOOP DEDICATO AL 1v1!
  startDuelLoop();
}

function duelSyncLoop() {
  if (!duelGameActive) return;
  if (!window.socket) {
    console.warn("socket non inizializzato in duelSyncLoop");
    return;
  }
  const payload = {
    room: duelRoomId,
    player: {
      x: window.gameState.player.x,
      y: window.gameState.player.y,
      health: window.gameState.player.health,
      energy: window.gameState.player.energy,
      angle: window.gameState.player.angle
    },
    action: window.gameState.lastAction
  };
  window.socket.emit("duel_update", payload);
  setTimeout(duelSyncLoop, 50);
}

function showDuelEnd(winner, stats) {
  duelEndScreen.classList.remove('hidden');
    document.getElementById('duelOpponentHealthBar').style.display = 'none'; // nascondi la barra round

  if (winner === (window.socket && window.socket.id)) {
    duelEndTitle.textContent = "🏆 VICTORY!";
  } else if (winner === "draw") {
    duelEndTitle.textContent = "🤝 DRAW";
  } else {
    duelEndTitle.textContent = "😵 DEFEAT";
  }

  // Safe extract id
  const myId = (window.socket && window.socket.id) ? window.socket.id : "me";
  const oppId = (duelOpponent && duelOpponent.id) ? duelOpponent.id : "opponent";

  // PATCH ELO: calcolo e visualizzazione
  let myElo = gameState.elo || 1000;
  let oppElo = duelOpponent?.elo || 1000;
  let result = 0.5;
  if (winner === (window.socket && window.socket.id)) result = 1;
  else if (winner === (duelOpponent?.id || "opponent")) result = 0;

  function calculateElo(myElo, oppElo, result, k = 32) {
    const expected = 1 / (1 + Math.pow(10, (oppElo - myElo) / 400));
    const newElo = myElo + k * (result - expected);
    return Math.round(newElo);
  }

  const newElo = calculateElo(myElo, oppElo, result);
const delta = newElo - myElo;
gameState.elo = newElo;
saveGameData(); // <--- assicurati che sia qui!
updateUI();

  duelEndStats.innerHTML = `
    <b>You:</b> ${stats?.[myId]?.kills ?? 0} kills, ${stats?.[myId]?.damage ?? 0} damage<br>
    <b>${duelOpponent?.nickname || "Opponent"}:</b> ${stats?.[oppId]?.kills ?? 0} kills, ${stats?.[oppId]?.damage ?? 0} damage
    <br><span style="color:#ffd700;">ELO change: ${delta > 0 ? "+" : ""}${delta} (ELO: ${newElo})</span>
  `;

  setupDuelEndButtons?.(); // se c'è la funzione per i bottoni
}

// ========== GAMEPLAY: POWERUP & OSTACOLI (Esempio) ==========
function processDuelEvents(events) {
  if (!events) return;
  for (const evt of events) {
    if (evt.type === "powerup_spawn") spawnPowerup(evt.data);
    if (evt.type === "powerup_pick") applyPowerup(evt.data);
    if (evt.type === "obstacle_move") moveObstacle(evt.data);
    // ... (puoi estendere)
  }
}
function spawnPowerup(data) { /* disegna/aggiorna powerup */ }
function applyPowerup(data) { /* applica powerup al player */ }
function moveObstacle(data) { /* muovi ostacolo in arena */ }

// ========== UTILS ==========
function getPlayerName() {
  return localStorage.getItem('playerName') || "NoName";
}
function getSelectedShipImage() {
  return localStorage.getItem('selectedShip') || "navicella1.png";
}

function initDuelArena() {
  // Player 1: alto a sinistra
  gameState.player.x = 100;
  gameState.player.y = 90;
  gameState.player.health = 500;
  gameState.player.energy = 100;

  // Player 2: alto a destra
  gameState.opponentState = {
    x: canvas.width - 100, // <-- cambia qui!
    y: 90,
    health: 500,
    energy: 100,
    maxHealth: 500
  };

  gameState.powerups = [];
  gameState.obstacles = [];
}
 
 
// PATCH 2: Colore barra vita avversario sempre corretto
function renderOpponent(ctx) {
  const opp = gameState.opponentState;
  if (!opp) return;
  let x = opp.x, y = opp.y;
  if (duelEntryAnimation.active) {
    x = lerp(canvas.width + 100, opp.x, duelEntryAnimation.progress);
  }
  ctx.save();
  ctx.globalAlpha = 0.8;
  const img = new Image();
  img.src = getShipImageFromId(duelOpponent?.skin) || "navicella2.png";
  ctx.drawImage(img, x - 32, y - 32, 64, 64);

  // Barra vita
  const barWidth = 56, barHeight = 10;
  const healthPercent = Math.max(0, opp.health) / (opp.maxHealth || 100);
  // LOG: console.log("HP%", healthPercent, opp.health, opp.maxHealth);

  ctx.fillStyle = healthPercent > 0.6 ? "#4caf50" : healthPercent > 0.3 ? "#ffd700" : "#f44336";
  ctx.fillRect(opp.x - barWidth / 2, opp.y - 50, barWidth * healthPercent, barHeight);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 2;
  ctx.strokeRect(opp.x - barWidth / 2, opp.y - 50, barWidth, barHeight);
  ctx.font = "bold 18px Orbitron";
  ctx.fillStyle = "#ffd700";
  ctx.textAlign = "center";
  ctx.fillText(duelOpponent?.nickname || "Opponent", opp.x, opp.y - 60);
  ctx.restore();
}
 
function setupDuelListeners() {
  if (!window.socket) return; // AGGIUNGI QUESTA RIGA!
  window.socket.off('duel_opponent_found');
  window.socket.off('duel_state');
  window.socket.off('duel_end');
  window.socket.on('duel_opponent_found', ({ room, opponent }) => {
    duelRoomId = room;
    duelOpponent = opponent;
    duelNick2.textContent = opponent.nickname;
    duelShip2.src = opponent.skin;
  duelStatus.textContent = `Opponent found! RoomID: ${room}`; // <-- Mostra l'ID qui!
    setTimeout(() => startDuelCountdown(), 1200);
  });
  window.socket.on('duel_state', ({ opponent, self, powerups, obstacles, events }) => {
  window.gameState.opponentState = opponent;
  window.gameState.powerups = powerups;
  window.gameState.obstacles = obstacles;
  processDuelEvents(events);

  // PATCH: aggiorna la tua health locale!
  if (self && typeof self.health === "number") {
    window.gameState.player.health = self.health;
    window.gameState.player.energy = self.energy;
    // Altri parametri se vuoi!
  }

// (resto del tuo codice)
if (duelRounds === 0 || window.gameState.opponentState.health > 500) {
  window.gameState.opponentState.health = 500;
  window.gameState.opponentState.maxHealth = 500;
}

});
  // Listener powerup spawn
window.socket.on('powerup_spawn', function(powerup) {
  window.gameState.powerups.push(powerup);
});
// Listener powerup raccolto
window.socket.on('powerup_picked', function({ player, powerup }) {
  window.gameState.powerups = window.gameState.powerups.filter(p => p.id !== powerup.id);
  if (player === window.socket.id) applyPowerupEffect(powerup.type);
});
  
  
  window.socket.on('duel_obstacle_spawn', function(obstacle) {
  window.gameState.obstacles.push(obstacle);
});
window.socket.on('duel_obstacle_hit', function({ obstacle }) {
  window.gameState.obstacles = window.gameState.obstacles.filter(o => o.id !== obstacle.id);
});
  
  
  window.socket.on('duel_emote', function({ player, emote }) {
  showDuelEmoteOnScreen(emote, player === window.socket.id);
  showNotification(`Opponent: ${emote}`);
});

function sendDuelEmote(emote) {
  window.socket.emit('duel_update', { room: duelRoomId, player: {...window.gameState.player}, action: 'emote', emote });
  showDuelEmoteOnScreen(emote, true);
}
  
  window.socket.on('duel_end', ({ winner, stats }) => {
  duelGameActive = false;
  gameState.gameMode = 'duel1v1'; // forza la modalità
  gameState.currentScreen = 'gameScreen';
  updateDuelOpponentHealthBar();
  showScreen('gameScreen'); // forza la schermata, se serve
  duelEndScreen.classList.remove('hidden'); // mostra la schermata finale
  showDuelEnd(winner, stats);
});

}


// Funzione per controllare se sei effettivamente in fullscreen
function isFullscreen() {
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}

// Mostra il popup se NON sei in fullscreen e SEI nel gameScreen (solo su PC!)
function showFullscreenAdvice() {
  // Solo su PC (no mobile/tablet)
  if (/Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) return;
  // Solo se sei nella schermata di gioco
  if (gameState.currentScreen !== "gameScreen") {
    document.getElementById("fullscreenAdvicePopup").style.display = "none";
    return;
  }
  // Se sei già in fullscreen, nascondi il popup
  if (isFullscreen()) {
    document.getElementById("fullscreenAdvicePopup").style.display = "none";
    return;
  }
  // Mostra il popup
  document.getElementById("fullscreenAdvicePopup").style.display = "block";
}

// Azione per entrare in fullscreen dal popup
function enableFullscreenFromPopup() {
  const elem = document.getElementById('gameContainer');
  if (elem.requestFullscreen) elem.requestFullscreen();
  else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
  else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
  setTimeout(showFullscreenAdvice, 600); // Aggiorna popup dopo il tentativo
}



window.addEventListener('DOMContentLoaded', () => {
  duelRematchBtn.onclick = () => {
    duelEndScreen.classList.add('hidden');
    safeCloseSocket(() => {
      duelGameActive = false;
      duelRoomId = null;
      duelOpponent = null;
      window.socket = io();
      setupDuelListeners();
      window.socket.on('connect', () => {
        startDuelQueue();
      });
    });
  };

  duelLobbyBtn.onclick = () => {
    duelEndScreen.classList.add('hidden');
    duelGameActive = false;
    duelRoomId = null;
    duelOpponent = null;
    showScreen('mainMenu');
    safeCloseSocket();
  };
});

// Funzione helper per chiudere socket in sicurezza
function safeCloseSocket(cb) {
  if (window.socket) {
    try {
      window.socket.on('disconnect', () => {
        window.socket = null;
        if (cb) setTimeout(cb, 50);
      });
      window.socket.disconnect();
      setTimeout(() => {
        if (cb) cb();
      }, 500);
    } catch (e) { if (cb) cb(); }
  } else {
    if (cb) cb();
  }
}


function getShipImageFromId(id) {
  switch (id) {
    case "ship1": return "navicella1.png";
    case "ship2": return "navicella2.png";
    case "ship3": return "navicella3.png";
    case "ship4": return "navicella4.png";
    case "summer": return "navicella-summer.png";
    default: return "navicella2.png";
  }
}


function setupDuelEndButtons() {
  // Rimuovi i vecchi listener se già presenti
  duelRematchBtn.onclick = null;
  duelLobbyBtn.onclick = null;

  duelRematchBtn.onclick = function() {
    duelEndScreen.classList.add('hidden');
    safeCloseSocket(() => {
      duelGameActive = false;
      duelRoomId = null;
      duelOpponent = null;
      window.socket = io();
      setupDuelListeners();
      window.socket.on('connect', () => {
        startDuelQueue();
      });
    });
  };

  duelLobbyBtn.onclick = function() {
    duelEndScreen.classList.add('hidden');
    duelGameActive = false;
    duelRoomId = null;
    duelOpponent = null;
    showScreen('mainMenu');
    safeCloseSocket();
  };
}






// PATCH FINALE: showScreen UNICA, con tutte le azioni extra
(function() {
  // Salva la versione originale una volta sola!
  const realShowScreen = window.showScreen;
  window.showScreen = function(screenId) {
    if (typeof realShowScreen === "function") realShowScreen(screenId);

    // Tutte le azioni aggiuntive qui dentro!
    if (screenId === 'gameScreen') {
      setTimeout(checkAndShowOrientationAdvice, 350);
      setTimeout(showFullscreenAdvice, 250);
    }
    // (aggiungi qui altre azioni future se vuoi)
  };

  document.addEventListener('fullscreenchange', showFullscreenAdvice);
  window.addEventListener('focus', showFullscreenAdvice);
})();
function toggleMobileButton(buttonId) {
  // Logica per attivare/disattivare un pulsante nel layout mobile
  console.log("Toggled:", buttonId);
}

function updateShipSpeedValue(value) {
  document.getElementById('shipSpeedValue').textContent = parseFloat(value).toFixed(2) + "x";
  // Qui imposti la variabile di velocità della navicella nel gioco
}

function updateButtonSize(value) {
  document.getElementById('buttonSizeValue').textContent = value + "px";
  document.querySelectorAll('.mobile-action-btn').forEach(btn => {
    btn.style.width = value + "px";
    btn.style.height = value + "px";
  });
}

function updateButtonColor(color) {
  document.querySelectorAll('.mobile-action-btn').forEach(btn => {
    btn.style.backgroundColor = color;
  });
}

function updateNicknameColor(color) {
  const nickElement = document.getElementById('nicknameAboveShipDisplay');
  if (nickElement) nickElement.style.color = color;
}

function applyMobileSettings() {
  // Leggi i valori dagli input
  const speed = parseFloat(document.getElementById('shipSpeedSlider').value);
  const size = parseInt(document.getElementById('buttonSizeSlider').value, 10);
  const color = document.getElementById('buttonColorPicker').value;
  const nick = document.getElementById('nicknameAboveShip')?.value || '';
  const nickColor = document.getElementById('nicknameColorPicker')?.value || '#fff';

  // Costruisci oggetto impostazioni
  window.gameSettings = {
    shipSpeed: speed,
    buttonSize: size,
    buttonColor: color,
    nicknameAboveShip: nick,
    nicknameColor: nickColor
  };

  // Salva su localStorage (tutto)
  localStorage.setItem('sg_mobileSettings', JSON.stringify(window.gameSettings));
  // Salva velocità anche su chiave singola se usata nel gameplay
  localStorage.setItem('mobileShipSpeed', speed);

  // PATCH: aggiorna dinamicamente la velocità anche in partita
  if (window.gameState && window.gameState.isMobile) {
    window.gameState.mobileShipSpeed = speed;
    console.log("Nuova velocità impostata in applyMobileSettings:", speed, "window.gameState.mobileShipSpeed:", window.gameState.mobileShipSpeed);

    if (window.gameState.player) {
      // Se vuoi puoi forzare l’update su player
      window.gameState._forceMobileSpeedUpdate = true;
    }
  }

  // Applica dimensione e colore ai pulsanti live
  document.querySelectorAll('.mobile-action-btn').forEach(btn => {
    btn.style.width = size + 'px';
    btn.style.height = size + 'px';
    btn.style.backgroundColor = color;
  });

  // PATCH: aggiorna anche i controlli touch se serve
  if (window.gameState && window.gameState.isMobile && typeof setupMobileControls === "function") {
    setupMobileControls();
  }

  // Aggiorna nickname sopra la navicella (se serve)
  let nickEl = document.getElementById('nicknameAboveShipDisplay');
  if (!nickEl) {
    nickEl = document.createElement('div');
    nickEl.id = 'nicknameAboveShipDisplay';
    nickEl.style.position = 'absolute';
    nickEl.style.pointerEvents = 'none';
    nickEl.style.fontFamily = "'Orbitron', monospace";
    nickEl.style.fontWeight = '900';
    nickEl.style.textShadow = '0 0 8px rgba(0,0,0,0.6)';
    nickEl.style.zIndex = 2000;
    nickEl.style.transform = 'translate(-50%,-120%)';
    document.getElementById('gameContainer').appendChild(nickEl);
  }
  nickEl.textContent = nick;
  nickEl.style.color = nickColor;

  // PATCH: aggiorna la posizione del nickname subito
  if (typeof updateNicknamePosition === "function") updateNicknamePosition();

  // Notifica
  if (typeof showNotification === 'function') {
    showNotification('Mobile settings applicati ✅');
  } else {
    alert('Mobile settings applicati ✅');
  }
}

// resettare le impostazioni (facoltativo)
function resetMobileSettings() {
  // ripristina valori di default
  document.getElementById('shipSpeedSlider').value = 0.7;
  document.getElementById('shipSpeedValue').textContent = '0.70x';
  document.getElementById('buttonSizeSlider').value = 80;
  document.getElementById('buttonSizeValue').textContent = '80px';
  document.getElementById('buttonColorPicker').value = '#00bcd4';
  document.getElementById('nicknameAboveShip').value = '';
  document.getElementById('nicknameColorPicker').value = '#ffffff';
  applyMobileSettings();
}


function updateNicknamePosition() {
  const nickEl = document.getElementById('nicknameAboveShipDisplay');
  if (!nickEl || !window.playerShip) return;
  // supponiamo playerShip abbia .x e .y in coordinate del canvas
  const rect = document.getElementById('gameCanvas').getBoundingClientRect();
  const shipScreenX = rect.left + (window.playerShip.x / GAME_WIDTH) * rect.width;
  const shipScreenY = rect.top + (window.playerShip.y / GAME_HEIGHT) * rect.height;
  nickEl.style.left = shipScreenX + 'px';
  nickEl.style.top = shipScreenY + 'px';
}


function loadMobileSettings() {
  const saved = JSON.parse(localStorage.getItem('sg_mobileSettings') || "{}");
  // Ship speed
  if (saved.shipSpeed !== undefined) {
    document.getElementById('shipSpeedSlider').value = saved.shipSpeed;
    document.getElementById('shipSpeedValue').textContent = parseFloat(saved.shipSpeed).toFixed(2) + "x";
  }
  // Button size
  if (saved.buttonSize) {
    document.getElementById('buttonSizeSlider').value = parseInt(saved.buttonSize, 10);
    document.getElementById('buttonSizeValue').textContent = saved.buttonSize + "px";
  }
  // Button color
  if (saved.buttonColor) {
    document.getElementById('buttonColorPicker').value = saved.buttonColor;
  }
  // Nickname sopra la nave
  if (saved.nicknameAboveShip) {
    document.getElementById('nicknameAboveShip').value = saved.nicknameAboveShip;
  }
  // Nickname color
  if (saved.nicknameColor) {
    document.getElementById('nicknameColorPicker').value = saved.nicknameColor;
  }
}


function applyPowerupEffect(type) {
  switch(type) {
    case 'heal': window.gameState.player.health = Math.min(window.gameState.player.maxHealth, window.gameState.player.health + 40); showNotification("💚 Healed!"); break;
    case 'shield': window.gameState.player.invulnerabilityFrames = 120; showNotification("🛡 Shield!"); break;
    case 'damage': window.gameState.player.damageBuff = 100; showNotification("🔫 Damage Up!"); break;
    case 'speed': window.gameState.player.speedBuff = 1.7; showNotification("⚡ Speed Up!"); break;
  }
}


function checkPowerupPickup() {
  window.gameState.powerups.forEach(p => {
    const dx = window.gameState.player.x - p.x;
    const dy = window.gameState.player.y - p.y;
    if (Math.sqrt(dx*dx + dy*dy) < 32 && p.active) {
      window.socket.emit('duel_update', { room: duelRoomId, player: {...window.gameState.player}, action: 'powerup_pick', powerupId: p.id });
      p.active = false;
      applyPowerupEffect(p.type); // <--- AGGIUNGI QUESTA RIGA QUI!
    }
  });
}


function renderDuelPowerups(ctx, powerups) {
  powerups.forEach(p => {
    if (!p.active) return;
    ctx.save();

    // Glow sottostante
    ctx.globalAlpha = 0.23;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 32, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.globalAlpha = 1;

    // Disegna sprite
    const img = POWERUP_SPRITES[p.type] || POWERUP_SPRITES['heal'];
    ctx.drawImage(img, p.x - 24, p.y - 24, 48, 48);

    // Bordo dorato (facoltativo)
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  });
}
if (gameState.gameMode === "duel1v1") renderDuelPowerups(ctx, window.gameState.powerups);


function checkObstacleHit() {
  window.gameState.obstacles.forEach((o, idx) => {
    const dx = window.gameState.player.x - o.x;
    const dy = window.gameState.player.y - o.y;
    if (Math.sqrt(dx*dx + dy*dy) < o.size/2 + 20 && !o.hit) {
      window.socket.emit('duel_update', { room: duelRoomId, player: {...window.gameState.player}, action: 'obstacle_hit', obstacleId: o.id });
      o.hit = true;
      window.gameState.player.health -= 20;
      showNotification("💥 Mine hit!");
    }
  });
}
if (gameState.gameMode === "duel1v1") checkObstacleHit();


function updateDuelEmojiBar() {
  const bar = document.getElementById('duelEmojiBar');
  if (!bar) return;
  // FORZA la barra emoji sempre visibile in gameScreen (debug)
  bar.style.display = (gameState.currentScreen === "gameScreen") ? "flex" : "none";
}
window.showScreen = (function(orig){
  return function(screenId) {
    orig(screenId);
    updateDuelEmojiBar();
  };
})(window.showScreen);


function sendDuelEmote(emote) {
  if (window.socket && duelRoomId) {
    window.socket.emit('duel_update', {
      room: duelRoomId,
      player: {...window.gameState.player},
      action: 'emote',
      emote: emote
    });
    showDuelEmoteOnScreen(emote, true); // Mostra anche lato tuo!
  }
}


function showDuelEmoteOnScreen(emote, isSelf = false) {
  const div = document.createElement('div');
  div.style.position = 'fixed';
  div.style.left = isSelf ? 'calc(25% - 38px)' : 'calc(75% - 38px)';
  div.style.bottom = '120px';
  div.style.background = isSelf ? '#00bcd4' : '#ffd700';
  div.style.color = '#222';
  div.style.fontSize = '2.5rem';
  div.style.padding = '1.1em';
  div.style.borderRadius = '50%';
  div.style.boxShadow = '0 0 28px ' + (isSelf ? '#00bcd4' : '#ffd700');
  div.style.zIndex = 99999;
  div.style.textAlign = 'center';
  div.style.opacity = '0.92';
  div.style.transition = 'all 0.7s cubic-bezier(.5,2,.3,1)';
  div.textContent = emote;
  document.body.appendChild(div);
  setTimeout(() => { div.style.opacity = '0'; div.style.transform = 'scale(1.6)'; }, 900);
  setTimeout(() => { div.remove(); }, 1400);
}


// === PATCH: DUEL 1v1 Best of 3 + Barra vita in alto ===

// 1. Variabili di stato per i round
let duelRounds = 0;
let myRoundWins = 0;
let oppRoundWins = 0;
let duelMaxRounds = 3;

// 2. UI per i round (aggiungi in HTML subito dopo il canvas, oppure via JS)
(function() {
  // Crea la barra vita avversario in alto a destra
  let bar = document.getElementById('duelOpponentHealthBar');
  if (!bar) {
    bar = document.createElement('div');
    bar.id = 'duelOpponentHealthBar';
    bar.style.top = '24px';
bar.style.left = '24px';
bar.style.right = 'auto';
    bar.style.background = 'rgba(30,30,30,0.93)';
    bar.style.borderRadius = '12px';
    bar.style.padding = '0.7em 1.4em';
    bar.style.zIndex = '9001';
    bar.style.minWidth = '160px';
    bar.style.boxShadow = '0 0 30px #ffd70088';
    bar.style.display = 'none';
    bar.innerHTML = `
      <div id="duelOpponentNick" style="font-weight:900;color:#ffd700;font-size:1.2em;margin-bottom:2px;">OPPONENT</div>
      <div style="width:100%;height:18px;background:#333;border-radius:8px;overflow:hidden;box-shadow:0 0 8px #ffd700;">
        <div id="duelOpponentHealthBarFill" style="height:100%;width:100%;background:linear-gradient(90deg,#4caf50,#ffd700,#f44336);transition:width .3s;"></div>
      </div>
      <div id="duelOpponentHealthText" style="font-size:0.96em;color:#fff;margin-top:2px;">500 / 500</div>
      <div id="duelRoundInfo" style="margin-top:8px;font-size:1.12em;color:#ffd700;">Round: 1 / 3</div>
      <div id="duelRoundsScore" style="font-size:0.99em;color:#00bcd4;">You: 0 | Opponent: 0</div>
    `;
    document.getElementById('gameContainer').appendChild(bar);
  }
})();

// 3 Barra vita avversario + round info (già presente nel tuo codice, ma puoi personalizzare)
function updateDuelOpponentHealthBar() {
  const bar = document.getElementById('duelOpponentHealthBar');
  if (!bar) return;
  if (gameState.currentScreen === "gameScreen" && gameState.gameMode === "duel1v1") {
    bar.style.display = 'block';
    // Aggiorna dati
    if (gameState.opponentState) {
      const health = Math.max(0, Math.floor(gameState.opponentState.health || 0));
      const maxHealth = Math.max(1, Math.floor(gameState.opponentState.maxHealth || 100));
      const percent = Math.min(100, 100 * health / maxHealth);
      document.getElementById('duelOpponentHealthBarFill').style.width = percent + "%";
      document.getElementById('duelOpponentHealthText').textContent = `${health} / ${maxHealth}`;
      document.getElementById('duelOpponentNick').textContent = duelOpponent?.nickname || "Opponent";
    }
    document.getElementById('duelRoundInfo').textContent = `Round: ${duelRounds+1} / ${duelMaxRounds}`;
    document.getElementById('duelRoundsScore').textContent = `You: ${myRoundWins} | Opponent: ${oppRoundWins}`;
  } else {
    bar.style.display = 'none';
  }
}


window.showScreen = (function(orig){
  return function(screenId) {
    orig(screenId);
    updateDuelEmojiBar();
  };
})(window.showScreen);

// 5. Logica per gestire i round (best of 3)
function handleDuelRoundEnd(winnerId) {
  duelRounds++;
  if (winnerId === (window.socket && window.socket.id)) myRoundWins++;
  else oppRoundWins++;

  // Aggiorna la barra subito
  updateDuelOpponentHealthBar();

  // MOSTRA OVERLAY SUBITO!
  if (winnerId === (window.socket && window.socket.id)) {
    showDuelRoundOverlay("win", duelRounds);
  } else if (winnerId === "draw") {
    showDuelRoundOverlay("draw", duelRounds);
  } else {
    showDuelRoundOverlay("lose", duelRounds);
  }

  // Controlla se qualcuno ha vinto 2 round
  if (myRoundWins >= 2 || oppRoundWins >= 2 || duelRounds >= duelMaxRounds) {
    // Fine match: mostra schermata finale
    setTimeout(() => {
      hideDuelRoundOverlay(); // Nascondi overlay prima della schermata finale
      showDuelEnd(
        myRoundWins > oppRoundWins
          ? (window.socket && window.socket.id)
          : (myRoundWins === oppRoundWins ? "draw" : (duelOpponent?.id || "opponent")),
        { /* puoi passare stats qui */ }
      );
    }, 1200);
    return;
  }

  // Se non è finito, prepara nuovo round!
  setTimeout(() => {
    hideDuelRoundOverlay(); // Nascondi overlay quando riparte il prossimo round
    startNextDuelRound();
  }, 1800);
}
  
  
  // RIMUOVI QUESTA SEZIONE BUGGY:
  // ❌ CANCELLA QUESTE RIGHE (erano il problema):
  /*
  if (winnerId !== window.socket.id) {
    duelRounds++;  // <-- DOPPIO INCREMENTO!
    updateDuelOpponentHealthBar();
    showDuelEnd("lose", { });  // <-- SCHERMATA PERDENTE NEI ROUND INTERMEDI!
  }
  */

function startNextDuelRound() {
  // Reset stato giocatori
  gameState.player.x = 300;
  gameState.player.y = 600;
  gameState.player.health = 500;
  gameState.player.energy = 100;
  gameState.opponentState.x = 900;
  gameState.opponentState.y = 600;
  gameState.opponentState.health = 500;
  gameState.opponentState.energy = 100;
  gameState.bullets = [];
  gameState.enemyBullets = [];
  // Countdown visivo?
  showNotification(`Round ${duelRounds+1} — Get Ready!`);
  updateDuelOpponentHealthBar();
  // Puoi riavviare il loop se serve (startDuelLoop();)
}

// 6. Modifica la funzione checkCollisionsDuel per gestire i round
function checkCollisionsDuel() {
  console.log('[CHECK COLLISIONS] Player HP:', gameState.player.health, 'Opponent HP:', gameState.opponentState?.health);

  if (!duelGameActive || !gameState.opponentState) return;
  for (let i = gameState.bullets.length - 1; i >= 0; i--) {
    const bullet = gameState.bullets[i];
    const opp = gameState.opponentState;
    const dist = Math.sqrt((bullet.x - opp.x) ** 2 + (bullet.y - opp.y) ** 2);
    const hitbox = 32;
    if (dist < hitbox && opp.health > 0) {
      // NON MODIFICARE la health qui!
      gameState.bullets.splice(i, 1);
      createHitParticles(bullet.x, bullet.y, bullet.color || "#ffd700");
      if (window.socket && duelRoomId) {
        window.socket.emit("duel_hit", {
          room: duelRoomId,
          damage: bullet.damage || 20
        });
      }
    }
  }
  updateDuelOpponentHealthBar();
  // Patch: round end
  // La fine round va gestita SOLO quando ricevi la health aggiornata dal server nella socket 'duel_state'
}

// 7. Quando inizi un nuovo duello, resetta i round
window.startDuelGame = (function(orig){
  return function() {
    duelGameActive = true;
    duelRounds = 0;
    myRoundWins = 0;
    oppRoundWins = 0;
    showScreen('gameScreen');
    window.gameState.gameMode = 'duel1v1';
    window.gameState.duelRoomId = duelRoomId;
    window.gameState.opponent = duelOpponent;
    gameState.enemy = null;
    initDuelArena();
    duelSyncLoop();
    startDuelEntryAnimation();
    startDuelLoop();
    updateDuelOpponentHealthBar();
  };
})(window.startDuelGame);

// 8. Aggiorna la barra vita avversario ogni frame nel loop
function startDuelLoop() {
  console.log('[startDuelLoop] Avviato con:', duelGameActive, window.gameState.currentScreen, window.gameState.gameMode);

  function duelLoop() {
    // Log per ogni frame!
    console.log('[duelLoop tick]', duelGameActive, window.gameState.currentScreen, window.gameState.gameMode, window.gameState.bullets.length);

    
      if (duelEntryAnimation.active) {
    duelEntryAnimation.progress += 1 / duelEntryAnimation.duration;
    if (duelEntryAnimation.progress >= 1) {
      duelEntryAnimation.active = false;
      duelEntryAnimation.progress = 1;
    }
  }
    
    
    if (!duelGameActive || window.gameState.currentScreen !== 'gameScreen' || window.gameState.gameMode !== 'duel1v1') return;
    updatePlayer(1); updatePlayerTrail(); updateObstacles(1); updateBullets(1); updateEnemyBullets(1); updateParticles(1);
    checkCollisionsDuel();
    render();
    updateDuelOpponentHealthBar();
    requestAnimationFrame(duelLoop);
  }
  duelLoop();
}

// FINE PATCH


function getEloLeague(elo) {
  if (elo < 1100) return { name: "Bronze", color: "#b97a57", icon: "🥉" };
  if (elo < 1300) return { name: "Silver", color: "#bdbdbd", icon: "🥈" };
  if (elo < 1500) return { name: "Gold", color: "#ffd700", icon: "🥇" };
  if (elo < 1700) return { name: "Platinum", color: "#aeefff", icon: "💠" };
  if (elo < 1900) return { name: "Diamond", color: "#00e0ff", icon: "🔷" };
  if (elo < 2200) return { name: "Master", color: "#9c27b0", icon: "🎖️" };
  return { name: "Legend", color: "#ff9800", icon: "🏆" };
}


const DUEL_LEADERBOARD_TAG = "duel1v1";

function fetchDuelLeaderboard(callback) {
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw";
  const tag = DUEL_LEADERBOARD_TAG;
  const url = `https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`;
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [name, score] = row.split('|');
          if (!name || isNaN(parseInt(score))) return null;
          return { name, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score)
        .slice(0, 20); // top 20
      callback(leaderboard);
    });
}

function showDuelLeaderboard() {
  showScreen('duelLeaderboardScreen');
  document.getElementById('duelLeaderboardList').innerHTML = 'Loading...';
  fetchDuelLeaderboard(leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.name}</b> — <span style="color:#ffd700;">${entry.score}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>No duel scores yet!</li>";
    html += '</ol>';
    document.getElementById('duelLeaderboardList').innerHTML = html;
  });
}



/* startFirstMission: prova a chiamare le funzioni esistenti (startMission / startGame),
   con fallback non distruttivi se non trovate. */
function startFirstMission(){
  console.log('startFirstMission called');
  // 1) preferiamo una funzione che accetta il livello: startMission(1)
  if (typeof startMission === 'function'){
    try { startMission(1); return; } catch(e){ console.warn('startMission error', e); }
  }

  // 2) fallback a startGame(true) (se il tuo startGame supporta skipAd o flag)
  if (typeof startGame === 'function'){
    try { startGame(true); return; } catch(e) {
      try { startGame(); return; } catch(e2) { console.warn('startGame error', e2); }
    }
  }

  // 3) fallback: apri la schermata di selezione livelli se esiste
  if (typeof showScreen === 'function'){
    try { showScreen('levelSelect'); return; } catch(e){ console.warn('showScreen error', e); }
  }

  // 4) ultima risorsa: avvisa l'utente
  alert('Impossibile avviare automaticamente la partita: controlla la console per errori.');
}


// === Spettatore 1v1 ===

document.getElementById('spectatorBtn').onclick = function() {
  const roomId = document.getElementById('spectatorRoomInput').value || 'room123';
  joinAsSpectator(roomId);
};

function joinAsSpectator(roomId) {
  if (!window.spectatorSocket) {
    window.spectatorSocket = io();
  }
  window.spectatorSocket.emit('duel_join', { roomId, role: 'spectator', nickname: "Spectator" });

  window.spectatorSocket.on('duel_state', (data) => {
    updateSpectatorView(data.players, data.spectators);
  });

  // Mostra overlay
  document.getElementById('spectatorPanel').style.display = 'block';
  document.getElementById('spectatorPanel').style.background = 'rgba(20,30,40,0.94)';
}

function updateSpectatorView(players, spectators) {
  let html = '';
  players.forEach((p, i) => {
    html += `
      <div style="margin-bottom:6px;${i===0?'':'border-top:1px solid #333; padding-top:5px;'}">
        <span style="color:#00bcd4;font-weight:bold;">Player ${i+1}:</span>
        <b style="color:#ffd700">${p.nickname || 'Player'}</b><br>
        Pos: <span style="color:#fff;">${Math.round(p.x)},${Math.round(p.y)}</span><br>
        HP: <span style="color:#4caf50">${p.hp}</span> | Score: <span style="color:#ffd700">${p.score}</span>
      </div>
    `;
  });
  document.getElementById('spectatorPlayers').innerHTML = html || "<i>No players in game</i>";
  document.getElementById('spectatorCount').textContent = spectators + " spettatori attuali";
}



function resetDuelRound(data) {
  console.log('[resetDuelRound] Chiamato', data);

  // Reset stato player
  gameState.player.x = data.playerStates[window.socket.id].x;
  gameState.player.y = data.playerStates[window.socket.id].y;
  gameState.player.health = 500;
  gameState.player.energy = 100;
  gameState.player.invulnerabilityFrames = 0;

  // Reset opponent
  const oppId = Object.keys(data.playerStates).find(id => id !== window.socket.id);
  gameState.opponentState.x = data.playerStates[oppId].x;
  gameState.opponentState.y = data.playerStates[oppId].y;
  gameState.opponentState.health = 500;
  gameState.opponentState.energy = 100;
  gameState.opponentState.invulnerabilityFrames = 0;
  gameState.opponentState.maxHealth = 500;

  // Azzera bullets, powerups, ostacoli
  gameState.bullets = [];
  gameState.enemyBullets = [];
  gameState.powerups = [];
  gameState.obstacles = [];

  duelGameActive = true; // <-- AGGIUNGI QUI!
  gameState.player.specialCooldown = 0; // Reset cooldown

  // LOG stato dopo il reset
  console.log('[resetDuelRound] Stato:', {
    bullets: gameState.bullets.length,
    enemyBullets: gameState.enemyBullets.length,
    powerups: gameState.powerups.length,
    obstacles: gameState.obstacles.length,
    duelGameActive
  });

  updateDuelOpponentHealthBar();
  updateUI();
}
  


window.socket.on('duel_next_round', function(data) {
  hideDuelRoundOverlay();
  resetDuelRound(data);

  
      duelRounds = data.round - 1;      // <-- QUI!

  duelGameActive = false;
  window.gameState.gameMode = 'duel1v1';
  window.gameState.currentScreen = 'gameScreen';

  // Mostra overlay con countdown
  showNextRoundOverlay(data.round, duelMaxRounds || 3, 7, function() {
    duelGameActive = true;
    window.gameState.gameMode = 'duel1v1';
    window.gameState.currentScreen = 'gameScreen';
    startDuelLoop();
    updateDuelOpponentHealthBar();     // <-- QUI!
    console.log('[duel_next_round] startDuelLoop() chiamato');
  });
});



function forceRestartDuelLoop() {
  duelGameActive = false;
  setTimeout(() => {
    duelGameActive = true;
    startDuelLoop();
  }, 50); // piccolo delay, serve a "sbloccare" eventuali stalli
}


function showDuelRoundOverlay(status, round) {
  let msg = "";
  if (status === "win") msg = "✅ HAI VINTO IL ROUND " + round + "!";
  else if (status === "lose") msg = "❌ HAI PERSO IL ROUND " + round + "!";
  else if (status === "draw") msg = "🤝 PAREGGIO nel round " + round;
  else msg = status;
  document.getElementById("duelRoundOverlayMsg").textContent = msg;
  document.getElementById("duelRoundOverlay").style.display = "block";
}

function hideDuelRoundOverlay() {
  document.getElementById("duelRoundOverlay").style.display = "none";
}


function showNextRoundOverlay(roundNum, maxRounds, seconds, cb) {
  const overlay = document.getElementById('duelRoundOverlay');
  const msg = document.getElementById('duelRoundOverlayMsg');
  const countdown = document.getElementById('duelNextRoundCountdown');
  overlay.style.display = 'block';
  msg.textContent = `🌀 ROUND ${roundNum} / ${maxRounds}`;
  
  let remaining = seconds;
  countdown.textContent = `Prossimo round in ${remaining}...`;

  const interval = setInterval(() => {
    remaining--;
    if (remaining > 0) {
      countdown.textContent = `Prossimo round in ${remaining}...`;
    } else {
      clearInterval(interval);
      overlay.style.display = 'none';
      countdown.textContent = '';
      if (typeof cb === "function") cb(); // <---- QUESTA RIGA!!
    }
  }, 1000);
}



function updateDuelScoreBar(p1Score, round, p2Score) {
  document.getElementById('scorePlayer1').innerHTML = `👤 You: <b>${p1Score}</b>`;
  document.getElementById('scorePlayer2').innerHTML = `Opponent: <b>${p2Score}</b>`;
  document.getElementById('scoreRound').innerHTML = `Round: <b>${round}</b>/3`;
}


function startDuelEntryAnimation() {
  duelEntryAnimation.active = true;
  duelEntryAnimation.progress = 0;
}


function showDuelLoadingScreen(player1, ship1, elo1, player2, ship2, elo2, phrase) {
  document.getElementById('duelLoadNick1').textContent = player1;
  document.getElementById('duelLoadShip1').src = ship1;
  document.getElementById('duelLoadElo1').textContent = elo1;
  document.getElementById('duelLoadNick2').textContent = player2;
  document.getElementById('duelLoadShip2').src = ship2;
  document.getElementById('duelLoadElo2').textContent = elo2;
  document.getElementById('duelLoadingPhrase').textContent = phrase || "Prepare for cosmic battle!";
  document.getElementById('duelLoadingScreen').style.display = 'flex';

  let count = 3;
  document.getElementById('duelLoadingCountdown').textContent = count;
  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      document.getElementById('duelLoadingCountdown').textContent = count;
    } else if (count === 0) {
      document.getElementById('duelLoadingCountdown').textContent = "GO!";
    } else {
      clearInterval(interval);
      hideDuelLoadingScreen();
      startDuelGame(); // Avvia la partita 1v1!
    }
  }, 1000);
}

function hideDuelLoadingScreen() {
  document.getElementById('duelLoadingScreen').style.display = 'none';
}


function showGoOverlay(text = "GO!", duration = 900) {
  const el = document.getElementById('duelGoOverlay');
  el.textContent = text;
  el.style.display = 'block';
  el.style.opacity = '1';
  el.style.transform = 'translate(-50%,-50%) scale(1.3)';
  setTimeout(() => {
    el.style.opacity = '0';
    el.style.transform = 'translate(-50%,-50%) scale(1.0)';
    setTimeout(() => { el.style.display = 'none'; }, 500);
  }, duration);
}


// ---- PATCH: DUEL BOT CON DIFFICOLTÀ E MOVIMENTO INTELLIGENTE ----



function updateDuelBot() {
  // Bot si muove solo orizzontalmente in alto
  const speed = getDuelBotParams().speed * 3; // regola il moltiplicatore a piacere
  duelBot.y = 90; // sempre alto
  duelBot.x += speed * botDirection;
  if (duelBot.x < 100 || duelBot.x > canvas.width - 100) botDirection *= -1;

  duelBot.cooldownShoot = Math.max(0, duelBot.cooldownShoot-1);

  if (duelBot.cooldownShoot <= 0) {
    shootAsBot();
    duelBot.cooldownShoot = 60 * getDuelBotParams().fireRate + Math.random()*16;
  }
}

function shootAsBot() {
  const patterns = ['basic', 'spread', 'aimed'];
  const pattern = patterns[Math.floor(Math.random() * patterns.length)];
  const bulletSpeed = 10 + Math.random() * 3;
  const botY = Math.max(40, Math.min(duelBot.y, canvas.height-60));
  
  switch (pattern) {
    case 'basic':
      for (let i = -1; i <= 1; i++) {
        gameState.enemyBullets.push({
          x: duelBot.x + i * 18,
          y: botY + 40,
          vx: i * 1.5,
          vy: bulletSpeed,
          color: "#ffd700",
          size: 9,
          damage: 18
        });
      }
      break;
    case 'spread':
      for (let i = 0; i < 5; i++) {
        const angle = (-0.6 + i * 0.3) + Math.PI/2;
        gameState.enemyBullets.push({
          x: duelBot.x,
          y: botY + 40,
          vx: Math.cos(angle) * bulletSpeed,
          vy: Math.sin(angle) * bulletSpeed,
          color: "#e91e63",
          size: 8,
          damage: 12
        });
      }
      break;
    case 'aimed':
      const dx = gameState.player.x - duelBot.x;
      const dy = gameState.player.y - (botY + 40);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      gameState.enemyBullets.push({
        x: duelBot.x,
        y: botY + 40,
        vx: (dx / dist) * bulletSpeed,
        vy: (dy / dist) * bulletSpeed,
        color: "#9c27b0",
        size: 10,
        damage: 15
      });
      break;
  }
  if (gameState.enemyBullets.length > 30) {
    gameState.enemyBullets = gameState.enemyBullets.slice(-30);
  }
  // Debug
  console.log("Bot spara!", duelBot.x, botY, "Tot:", gameState.enemyBullets.length);
}

function renderDuelBot(ctx) {
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.drawImage(playerImage, duelBot.x - 32, duelBot.y - 32, 64, 64);
  ctx.restore();
}



function startDuelAIBoss() {
  gameState.gameMode = "duelAI";
  // Player come sempre
  gameState.player.x = 100;
  gameState.player.y = 600;
  gameState.player.health = 500;
  gameState.player.energy = 100;
  gameState.player.maxHealth = 500;
  gameState.player.maxEnergy = 100;

  // Prendi un boss difficile dal LEVEL_DATA
  const levelIndex = 10; // Scegli il boss che vuoi, qui è livello 11 (indice 10)
  const bossData = LEVEL_DATA[levelIndex];
  gameState.enemy = {
    ...bossData,
    x: canvas.width / 2,
    y: 120,
    health: bossData.health,
    maxHealth: bossData.health,
    speed: bossData.speed,
    attackPatterns: bossData.attackPatterns,
    phases: bossData.phases,
    attackCooldown: 0,
    moveDirection: 1,
    angle: 0
  };

  gameState.bullets = [];
  gameState.enemyBullets = [];
  gameState.particles = [];

  showScreen('gameScreen');
  gameState.gameRunning = true;
  gameLoop();
}

// (poi puoi chiamare startDuelAIBoss() dal menu)

// Applica la difficoltà scelta dal menu
document.getElementById('duelBotDifficultySelect').value = duelBotDifficulty;
document.getElementById('duelBotDifficultySelect').addEventListener('change', function() {
  duelBotDifficulty = this.value;
  localStorage.setItem('duelBotDifficulty', duelBotDifficulty);
});



// --- FUNZIONE COLLISIONI DUEL BOT (1v1 BOT) ---
function checkDuelAICollisions() {
  // Player colpisce bot
  for (let i = gameState.bullets.length - 1; i >= 0; i--) {
    const b = gameState.bullets[i];
    const dx = b.x - duelBot.x;
    const dy = b.y - duelBot.y;
    if (Math.sqrt(dx*dx + dy*dy) < 32) {
      duelBot.health -= b.damage || 20;
      gameState.bullets.splice(i, 1);
    }
  }
  // Bot colpisce player
  for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
    const b = gameState.enemyBullets[i];
    const dx = b.x - gameState.player.x;
    const dy = b.y - gameState.player.y;
    if (Math.sqrt(dx*dx + dy*dy) < 32) {
      gameState.player.health -= b.damage || 20;
      gameState.enemyBullets.splice(i, 1);
    }
  }
}



</script>
  
</body>
</html>
